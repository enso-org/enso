//! This module re-exports a lot of useful stuff. It is not meant to be used
//! by libraries, but it is definitely usefull for bigger projects. It also
//! defines several aliases and utils which may find their place in new
//! libraries in the future.

// === Features ===
#![feature(concat_idents)]
#![feature(specialization)]
#![feature(trait_alias)]
#![feature(generators)]
#![feature(step_trait)]
#![feature(allocator_api)]
#![feature(auto_traits)]
#![feature(negative_impls)]
#![feature(pattern)]
#![feature(cfg_version)]
// === Standard Linter Configuration ===
#![deny(non_ascii_idents)]
#![warn(unsafe_code)]
#![allow(clippy::bool_to_int_with_if)]
#![allow(clippy::let_and_return)]
#![allow(incomplete_features)] // To be removed, see: https://github.com/enso-org/ide/issues/1559
#![warn(missing_copy_implementations)]
#![warn(missing_debug_implementations)]
#![warn(unsafe_code)]
#![recursion_limit = "256"]

mod bool;
mod cell;
pub mod channel;
mod clear_and_reuse;
mod collections;
mod data;
pub mod debug;
pub mod env;
mod fail;
pub mod future;
mod hash;
mod item;
mod leak;
mod macros;
mod not_same;
mod option;
mod phantom;
pub mod prealloc;
mod range;
mod rc;
mod refcell;
mod reference;
mod result;
mod serde;
mod smallvec;
mod std_reexports;
mod string;
mod switch;
pub mod sync;
mod test;
mod tp;
mod unsafe_cell;
mod vec;
mod void;
mod zeroable;

pub use crate::bool::*;
pub use crate::serde::*;
pub use crate::smallvec::*;
pub use enso_zst::*;

pub use anyhow;
pub use cell::*;
pub use clear_and_reuse::*;
pub use collections::*;
pub use data::*;
pub use debug::*;
pub use enso_shapely as shapely;
pub use enso_shapely::before_main;
pub use enso_shapely::clone_ref::*;
pub use enso_shapely::impl_clone_ref_as_clone;
pub use enso_shapely::root_call_path;
pub use fail::*;
pub use hash::*;
pub use item::*;
pub use leak::Leak;
pub use leak::*;
pub use macros::*;
pub use not_same::*;
pub use option::*;
pub use phantom::*;
pub use range::traits::*;
pub use rc::*;
pub use refcell::*;
pub use reference::*;
pub use result::*;
pub use std_reexports::*;
pub use string::*;
pub use switch::*;
pub use test::traits::*;
pub use tp::*;
pub use unsafe_cell::*;
pub use vec::*;
pub use void::*;
pub use zeroable::*;

pub use assert_approx_eq::assert_approx_eq;
pub use boolinator::Boolinator;
pub use derivative::Derivative;
pub use derive_more::*;
pub use failure::Fail;
pub use itertools::Itertools;
pub use lazy_static::lazy_static;
pub use paste::paste;

pub use weak_table;
pub use weak_table::traits::WeakElement;
pub use weak_table::traits::WeakKey;
pub use weak_table::WeakKeyHashMap;
pub use weak_table::WeakValueHashMap;

pub use gen_iter::gen_iter;
pub use std::collections::hash_map::DefaultHasher;
pub use std::hash::Hash;
pub use std::hash::Hasher;

/// Re-export of [`wasm_bindgen`] is needed because the code generated by [`before_main`] macro
/// uses it. Unfortunately, `$crate` does not exist in proc macros, so it is not possible to
/// refer to [`wasm_bindgen`] from the macro in a generic way.
pub use wasm_bindgen;

pub use enso_reflect::prelude::*;

pub use std::ops::AddAssign;
pub use std::ops::SubAssign;

use std::cell::UnsafeCell;


mod anyhow_macros {
    pub use anyhow::anyhow;
}
pub use anyhow_macros::*;


/// Module designed to be used in an explicit way. After importing `prelude::*` you can use it for
/// example as `std_ext::range::merge_overlapping_ranges(...)`.
#[allow(missing_docs)]
pub mod std_ext {
    pub mod range {
        pub use crate::range::*;
    }
}

/// Serde reexports for the code generated by declarative macros.
///
/// They cannot be directly reexported from prelude, as the methods `serialize` and `deserialize`
/// that would be brought into scope by this, would collide with the other IDE-defined traits.
pub mod serde_reexports {
    pub use serde::Deserialize;
    pub use serde::Serialize;
}



// ================
// === Printing ===
// ================

pub use web_sys;

#[macro_export]
macro_rules! console_log {
    ( $( $t:tt )* ) => {
        $crate::web_sys::console::log_1(&format!( $( $t )* ).into());
    }
}


// ===============
// === Logging ===
// ===============

pub use enso_logging::debug;
pub use enso_logging::debug_span;
pub use enso_logging::error;
pub use enso_logging::error_span;
pub use enso_logging::info;
pub use enso_logging::info_span;
pub use enso_logging::prelude::*;
pub use enso_logging::trace;
pub use enso_logging::trace_span;
pub use enso_logging::warn;
pub use enso_logging::warn_span;

/// Instruction of how to report important errors.
pub const REPORT_INSTRUCTION: &str = "We will be thankful for reporting this issue here: \
https://github.com/enso-org/enso/issues. Please, provide us with as much information as possible, \
including your system specification, browser version, and a detailed description of the steps you \
made before this error happened.";

#[macro_export]
macro_rules! reportable_warn {
    ($($ts:tt)*) => {
        $crate::warn!{$($ts)*}
        $crate::warn!("{}", $crate::REPORT_INSTRUCTION)
    };
}

#[macro_export]
macro_rules! reportable_error {
    ($($ts:tt)*) => {
        $crate::error!{$($ts)*}
        $crate::error!("{}", $crate::REPORT_INSTRUCTION)
    };
}

pub fn init_global() {
    init_global_internal();
}

#[cfg(target_arch = "wasm32")]
fn init_global_internal() {
    enso_web::register_panic_hook();
    enso_web::set_stack_trace_limit();
}

#[cfg(not(target_arch = "wasm32"))]
fn init_global_internal() {}



// =================
// === Immutable ===
// =================

/// A zero-overhead newtype which provides immutable access to its content. Of course this does not
/// apply to internal mutability of the wrapped data. A good use case of this structure is when you
/// want to pass an ownership to a structure, allow access all its public fields, but do not allow
/// their modification.
#[derive(Clone, Copy, Default, Eq, PartialEq)]
#[repr(transparent)]
pub struct Immutable<T> {
    data: T,
}

/// Constructor of the `Immutable` struct.
#[allow(non_snake_case)]
pub fn Immutable<T>(data: T) -> Immutable<T> {
    Immutable { data }
}

impl<T: Debug> Debug for Immutable<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.data.fmt(f)
    }
}

impl<T: Display> Display for Immutable<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.data.fmt(f)
    }
}

impl<T: Clone> CloneRef for Immutable<T> {
    fn clone_ref(&self) -> Self {
        Self { data: self.data.clone() }
    }
}

impl<T> AsRef<T> for Immutable<T> {
    fn as_ref(&self) -> &T {
        &self.data
    }
}

impl<T> std::borrow::Borrow<T> for Immutable<T> {
    fn borrow(&self) -> &T {
        &self.data
    }
}

impl<T> Deref for Immutable<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.data
    }
}

// ==============
// === ToImpl ===
// ==============

/// Provides method `to`, which is just like `into` but allows fo superfish syntax.
pub trait ToImpl: Sized {
    fn to<P>(self) -> P
    where Self: Into<P> {
        self.into()
    }
}
impl<T> ToImpl for T {}



#[macro_export]
macro_rules! clone_boxed {
    ( $name:ident ) => {
        paste! {
            #[allow(missing_docs)]
            pub trait [<CloneBoxedFor $name>] {
                fn clone_boxed(&self) -> Box<dyn $name>;
            }

            impl<T:Clone+$name+'static> [<CloneBoxedFor $name>] for T {
                fn clone_boxed(&self) -> Box<dyn $name> {
                    Box::new(self.clone())
                }
            }

            impl Clone for Box<dyn $name> {
                fn clone(&self) -> Self {
                    self.clone_boxed()
                }
            }
        }
    };
}

/// Alias for `for<'t> &'t Self : Into<T>`.
pub trait RefInto<T> = where for<'t> &'t Self: Into<T>;

// =================
// === CloneCell ===
// =================

#[derive(Debug)]
pub struct CloneCell<T> {
    data: UnsafeCell<T>,
}

impl<T> CloneCell<T> {
    pub fn new(elem: T) -> CloneCell<T> {
        CloneCell { data: UnsafeCell::new(elem) }
    }

    #[allow(unsafe_code)]
    pub fn get(&self) -> T
    where T: Clone {
        unsafe { (*self.data.get()).clone() }
    }

    #[allow(unsafe_code)]
    pub fn set(&self, elem: T) {
        unsafe {
            *self.data.get() = elem;
        }
    }

    #[allow(unsafe_code)]
    pub fn take(&self) -> T
    where T: Default {
        let ptr: &mut T = unsafe { &mut *self.data.get() };
        std::mem::take(ptr)
    }
}

impl<T: Clone> Clone for CloneCell<T> {
    fn clone(&self) -> Self {
        Self::new(self.get())
    }
}

impl<T: Default> Default for CloneCell<T> {
    fn default() -> Self {
        Self::new(default())
    }
}

// ====================
// === CloneRefCell ===
// ====================

#[derive(Debug)]
pub struct CloneRefCell<T: ?Sized> {
    data: UnsafeCell<T>,
}

impl<T> CloneRefCell<T> {
    pub fn new(elem: T) -> CloneRefCell<T> {
        CloneRefCell { data: UnsafeCell::new(elem) }
    }

    #[allow(unsafe_code)]
    pub fn get(&self) -> T
    where T: CloneRef {
        unsafe { (*self.data.get()).clone_ref() }
    }

    #[allow(unsafe_code)]
    pub fn set(&self, elem: T) {
        unsafe {
            *self.data.get() = elem;
        }
    }

    #[allow(unsafe_code)]
    pub fn take(&self) -> T
    where T: Default {
        let ptr: &mut T = unsafe { &mut *self.data.get() };
        std::mem::take(ptr)
    }
}

impl<T: CloneRef> Clone for CloneRefCell<T> {
    fn clone(&self) -> Self {
        Self::new(self.get())
    }
}

impl<T: CloneRef> CloneRef for CloneRefCell<T> {
    fn clone_ref(&self) -> Self {
        Self::new(self.get())
    }
}

impl<T: Default> Default for CloneRefCell<T> {
    fn default() -> Self {
        Self::new(default())
    }
}



// ===============================
// === CellGetter / CellSetter ===
// ===============================

/// Generalization of the [`Cell::get`] mechanism. Can be used for anything similar to [`Cell`].
pub trait CellGetter: HasItem {
    fn get(&self) -> Self::Item;
}

/// Generalization of the [`Cell::set`] mechanism. Can be used for anything similar to [`Cell`].
pub trait CellSetter: HasItem {
    fn set(&self, value: Self::Item);
}

/// Generalization of modify utilities for structures similar to [`Cell`].
pub trait CellProperty: CellGetter + CellSetter + ItemClone {
    /// Update the contained value using the provided function and return the new value.
    fn update<F>(&self, f: F) -> Self::Item
    where F: FnOnce(Self::Item) -> Self::Item {
        let new_val = f(self.get());
        self.set(new_val.clone());
        new_val
    }

    /// Modify the contained value using the provided function and return the new value.
    fn modify<F>(&self, f: F) -> Self::Item
    where F: FnOnce(&mut Self::Item) {
        let mut new_val = self.get();
        f(&mut new_val);
        self.set(new_val.clone());
        new_val
    }

    /// Update the contained value using the provided function without returning the new value.
    fn update_<F>(&self, f: F)
    where F: FnOnce(Self::Item) -> Self::Item {
        self.update(f);
    }

    /// Modify the contained value using the provided function without returning the new value.
    fn modify_<F>(&self, f: F)
    where F: FnOnce(&mut Self::Item) {
        self.modify(f);
    }
}

impl<T: CellGetter + CellSetter + ItemClone> CellProperty for T {}

// === Impls ===

impl<T: Copy> CellGetter for Cell<T> {
    fn get(&self) -> Self::Item {
        self.get()
    }
}
impl<T: Copy> CellSetter for Cell<T> {
    fn set(&self, value: Self::Item) {
        self.set(value)
    }
}

// ================================
// === Strong / Weak References ===
// ================================

/// Abstraction for a strong reference like `Rc` or newtypes over it.
pub trait StrongRef: CloneRef {
    /// Downgraded reference type.
    type WeakRef: WeakRef<StrongRef = Self>;
    /// Creates a new weak reference of this allocation.
    fn downgrade(&self) -> Self::WeakRef;
}

/// Abstraction for a weak reference like `Weak` or newtypes over it.
pub trait WeakRef: CloneRef {
    /// Upgraded reference type.
    type StrongRef: StrongRef<WeakRef = Self>;
    /// Attempts to upgrade the weak referenc to a strong one, delaying dropping of the inner value
    /// if successful.
    fn upgrade(&self) -> Option<Self::StrongRef>;
}

impl<T: ?Sized> StrongRef for Rc<T> {
    type WeakRef = Weak<T>;
    fn downgrade(&self) -> Self::WeakRef {
        Rc::downgrade(self)
    }
}

impl<T: ?Sized> WeakRef for Weak<T> {
    type StrongRef = Rc<T>;
    fn upgrade(&self) -> Option<Self::StrongRef> {
        Weak::upgrade(self)
    }
}



// ======================
// === ImplementsDrop ===
// ======================

/// Check whether the structure implements custom drop behavior. Used mainly by the
/// [`NoCloneBecauseOfCustomDrop`] macro.
#[allow(drop_bounds)]
pub trait ImplementsDrop: Drop {}
