from Base import all
from Database.Data.Column as Column_Module import all
import Database.Data.Internal.Helpers
import Database.Data.Internal.IR

## Represents a column-oriented table data structure backed by a database.
type Table
    # type Table (name : Text) (connection : Connection)
    #            (internal_columns : Vector (Pair Text IR.Expression))
    #            (context : IR.Context)
    type Table name connection internal_columns context

    ## Returns a text containing an ASCII-art table displaying this data.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
         - format_terminal: whether ANSI-terminal formatting should be used
    display : Integer -> Boolean -> Text
    display show_rows=10 format_terminal=False =
        this.to_dataframe.display show_rows format_terminal

    ## Prints an ASCII-art table with this data to the standard output.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
    print show_rows=10 =
        IO.println (this.display show_rows format_terminal=True)
        IO.println ''

    ## Converts this table to a JSON structure.
    to_json : Json
    to_json =
        col_jsons = this.columns.map .to_json
        cols_json = Json.Array col_jsons
        fields = Map.singleton "columns" cols_json
        Json.Object fields

    ## Returns the column with the given name.
    at : Text -> Column | Nothing
    at name = case this.internal_columns.find (p -> p.first == name) of
        Nothing -> Nothing
        p -> this.make_column p

    ## Selects only the rows of this table that correspond to `True` values in
       `filter`.
       This is useful for filtering the rows by given predicate.
       > Example
         Select only the rows of `my_table` where the `"Status"` column has the
         value `"Valid"`
             my_table.where (my_table.at "Status" == "Valid")
    where : Column -> Table
    where filter =
        case Helpers.check_integrity this filter of
            False ->
                # TODO [RW] more descriptive errors
                Error.throw "Filtering over a column with differing context."
            True ->
                new_filters = this.context.where_filters + [filter.expression]
                new_ctx = this.context.set_where_filters new_filters
                this.updated_context new_ctx

    ## Sets the column value at the given name. If a column with the given name
       already exists, it will be replaced. Otherwise a new column is added.
    set : Text -> Column -> Table
    set name column = case Helpers.ensure_name_is_sane name of
        True ->
            new_col = Pair name column.expression
            replace = this.internal_columns.exists (c -> c.first == name)
            case replace of
                True ->
                    new_cols = this.internal_columns.map (c -> if c.first == name then new_col else c)
                    this.updated_columns new_cols
                False ->
                    this.updated_columns (this.internal_columns + [new_col])

    ## Returns the vector of columns contained in this table.
    columns : Vector Column
    columns = this.internal_columns . map this.make_column

    ## Sets the index of this table, using the column with the provided name.
    set_index : Text | Vector Text -> Table
    set_index index =
        # TODO [RW, MK] do we want to allow to set index by an expression? (Column)
        new_index = (Helpers.unify_vector_singleton index).map (name -> this.internal_at name . second)
        new_ctx = this.context.set_index new_index
        this.updated_context new_ctx

    # TODO [RW] how to handle multiple orders asc desc?
    order : Nothing | Text | Vector Text | Column | Vector Column -> Table
    order by=Nothing =
        exprs = Helpers.resolve_index "order by" this by . map (e -> Pair e IR.Ascending)
        new_ctx = this.context.set_orders exprs
        this.updated_context new_ctx

    ## Selects a subset of columns from this table by name.
    select : Vector Text -> Table
    select columns =
        find_col = (name -> this.internal_columns.find (p -> p.name == name))
        selected_cols = columns.map find_col . filter (!= Nothing)
        this.updated_columns selected_cols

    ## Efficiently joins two tables based on either the index or a key column.

       The resulting table contains rows of `this` extended with rows of
       `other` with matching indexes. If the index in `other` is not unique,
       the corresponding rows of `this` will be duplicated in the result.

       Arguments:
         - other: the table being the right operand of this join operation.
         - on: the column(s) of `this` that should be used as the join key. If
               this argument is not provided, the index of `this` will be used.
         - drop_unmatched: whether the rows of `this` without corresponding
                           matches in `other` should be dropped from the result.
         - left_suffix: a suffix that should be added to the columns of `this`
                        when there's a name conflict with a column of `other`.
         - right_suffix: a suffix that should be added to the columns of `other`
                         when there's a name conflict with a column of `this`.
    join : Table -> Vector Text | Text | Nothing -> Boolean -> Text -> Text -> Table
    join other on=Nothing drop_unmatched=False left_suffix='_left' right_suffix='_right' =
        kind = if drop_unmatched then IR.InnerJoin else IR.LeftJoin
        my_index : Vector Expression
        my_index = case on == Nothing of
            True -> this.context.meta_index
            False ->
                (Helpers.unify_vector_singleton on).map (name -> this.internal_at name . second)
        other_index = other.context.meta_index
        case my_index.length == other_index.length of
            False -> Error.throw "Cannot join with multi-indexes of different lengths."
            True ->
                ## TODO [RW] we may be able to avoid creating subqueries if there are no groups, orders or wheres,
                   so it may be worth optimizing that here

                new_table_name = this.name + "_" + other.name
                aliases = case this.name == other.name of
                    True -> Pair this.name+"_left" other.name+"_right"
                    False -> Pair this.name other.name
                left_alias = aliases.first
                right_alias = aliases.second

                left_query = IR.SubQuery this.internal_columns this.context left_alias
                right_query = IR.SubQuery other.internal_columns other.context right_alias

                left_renamed_index = my_index.map (IR.substitute_origin this.name left_alias)
                right_renamed_index = other_index.map (IR.substitute_origin other.name right_alias)
                on_exprs = left_renamed_index.zip right_renamed_index (l -> r -> IR.Operation "=" [l, r])

                new_index = left_renamed_index
                new_from = IR.Join kind left_query right_query on_exprs
                new_ctx = IR.Context new_from [] [] [] new_index

                left_names = Map.from_vector (this.internal_columns.map (p -> [p.first, True]))
                right_names = Map.from_vector (this.internal_columns.map (p -> [p.first, True]))
                rename suffix other_names this_name =
                    if other_names.get_or_else this_name False then this_name+suffix else this_name
                rename_left = rename "_left" right_names
                rename_right = rename "_right"  left_names

                new_left_columns = this.internal_columns.map p->
                    Pair (rename_left p.first) (IR.Column left_alias p.first)
                new_right_columns = other.internal_columns.map p->
                    Pair (rename_right p.first) (IR.Column right_alias p.first)

                new_columns = new_left_columns + new_right_columns

                Table new_table_name this.connection new_columns new_ctx

    ## Returns an aggregate table resulting from grouping the elements by the
       value of the specified column.

       If the `by` argument is not set, the index is used for grouping instead.

       > Example
         Creates a simple table and computes aggregation statistics:
            name = ['name', ["foo", "bar", "foo", "baz", "foo", "bar", "quux"]]
            price = ['price', [0.4, 3.5, Nothing, 6.7, Nothing, 97, Nothing]]
            quantity = ['quantity', [10, 20, 30, 40, 50, 60, 70]]
            t = Table.new [name, price, quantity] # TODO [RW] DB example

            agg = t.group by='name'

            records_num = agg.count
            total_quantity = agg.at 'quantity' . sum
            mean_price = agg.at 'price' . mean

            Table.join [records_num, total_quantity, mean_price]
    group : Vector Text | Text | Nothing -> Aggregate_Table
    group by=Nothing =
        exprs = Helpers.resolve_index "group by" this by
        new_ctx = this.context.set_orders exprs
        this.updated_context new_ctx
        Error.throw "TODO: aggregates"

    ## Returns a new Table without rows that contained missing values in any of
       the columns.
    drop_missing_rows : Table
    drop_missing_rows =
        filters = this.columns.map (c -> c.is_missing.not)
        new_ctx = this.context.set_where_filters (this.context.where_filters + filters)
        this.updated_context new_ctx

    ## Returns a new Table without columns that contained any missing values.
    drop_missing_columns : Table
    drop_missing_columns =
        Error.throw "TODO"

    ## Returns the amount of rows in this table.
    nrows : Integer
    nrows = Error.throw "TODO"

    to_dataframe : (Integer | Nothing) -> Table.Table
    to_dataframe limit=Nothing =
        Error.throw "TODO"

    ## Returns an SQL statement that will be used for materializing this table.
    to_sql : SQL.Statement
    to_sql =
        cols = this.internal_columns
        query = IR.Select cols this.context
        this.connection.dialect.generate_sql query

    explain_query_plan : Text
    explain_query_plan =
        this.connection.explain_query_plan this.to_sql

    ## Returns a Table describing this table's contents.

       The table lists all columns, counts of non-null items and storage types
       of each column.
    info : Table
    info =
        cols = this.columns
        here.new [["Column", cols.map .name], ["Items Count", cols.map .count], ["Storage Type", cols.map .storage_type]]

    ## PRIVATE
    make_column : Pair Text IR.Expression -> Column
    make_column pair =
        Column pair.first this.connection pair.second this.context

    ## PRIVATE
    internal_at : Text -> InternalColumn
    internal_at name =
        res = this.internal_columns.find (c -> c.first == name)
        case res of
            Nothing -> Error.throw "Column "+name+" not found."
            _ -> res

    ## PRIVATE
    updated_columns columns = Table this.name this.connection columns this.context

    ## PRIVATE
    updated_context ctx = Table this.name this.connection this.internal_columns ctx


type InternalColumn
    type InternalColumn external_name internal_name expression

## PRIVATE
make_table : Connection -> Text -> Vector Text -> Table
make_table connection table_name column_names =
    ctx = IR.make_ctx_from table_name
    cols = column_names.map (name -> Pair name (IR.Column table_name name))
    Table table_name connection cols ctx
