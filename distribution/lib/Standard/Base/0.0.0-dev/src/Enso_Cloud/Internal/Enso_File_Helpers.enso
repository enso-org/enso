private

import project.Any.Any
import project.Data.Color.Color
import project.Data.Dictionary.Dictionary
import project.Data.Hashset.Hashset
import project.Data.Json.Invalid_JSON
import project.Data.Json.JS_Object
import project.Data.Text.Text
import project.Data.Vector.Vector
import project.Enso_Cloud.Enso_File.Enso_Asset_Type
import project.Enso_Cloud.Enso_File.Enso_File
import project.Enso_Cloud.Errors.Enso_Cloud_Error
import project.Enso_Cloud.Internal.Existing_Enso_Asset.Asset_Cache
import project.Enso_Cloud.Internal.Existing_Enso_Asset.Existing_Enso_Asset
import project.Enso_Cloud.Internal.Utils
import project.Error.Error
import project.Errors.File_Error.File_Error
import project.Errors.Illegal_Argument.Illegal_Argument
import project.Errors.Illegal_State.Illegal_State
import project.Network.HTTP.HTTP_Method.HTTP_Method
import project.Network.HTTP.Request_Error
import project.Network.URI.URI
import project.Nothing.Nothing
import project.Random.Random
import project.System.File.File
import project.System.Output_Stream.Output_Stream
from project.Data.Boolean import Boolean, False, True
from project.Data.Text.Extensions import all
from project.Enso_Cloud.Data_Link_Helpers import data_link_encoding, data_link_extension
from project.Enso_Cloud.Public_Utils import get_required_field

## PRIVATE
upload_file (local_file : File) (destination : Enso_File) (replace_existing : Boolean) -> Enso_File =
    result = perform_upload destination replace_existing [local_file, destination]
    result.catch Enso_Cloud_Error error->
        is_source_file_not_found = case error of
            Enso_Cloud_Error.Connection_Error cause -> case cause of
                request_error : Request_Error -> request_error.error_type == 'java.io.FileNotFoundException'
                _ -> False
            _ -> False
        if is_source_file_not_found then Error.throw (File_Error.Not_Found local_file) else result

## PRIVATE
   A helper function that gathers the common logic for checking existence of
   a created asset and its parent directory.

   The `create_action` function is called with the existing asset for the parent
   directory and for the file, if it already exists, or `Nothing` otherwise, and
   with a mapping of error handlers that may be added to the request.
generic_create_asset (destination : Enso_File) (allow_existing : Boolean) (create_action : Existing_Enso_Asset -> (Existing_Enso_Asset | Nothing) -> Dictionary -> Any) -> Any =
    parent_directory = destination.parent
    if parent_directory.is_nothing then Error.throw (Illegal_Argument.Error "Please provide an asset name inside of the root directory.") else
        parent_directory_asset = Existing_Enso_Asset.get_asset_reference_for parent_directory
        # If the parent directory does not exist, we fail.
        parent_directory_asset.if_not_error <|
            existing_asset = Existing_Enso_Asset.get_asset_reference_for destination
                . catch File_Error error-> case error of
                    File_Error.Not_Found _ -> Nothing
                    _ -> Error.throw error
            if existing_asset.is_nothing.not && allow_existing.not then Error.throw (File_Error.Already_Exists destination) else
                error_handlers = if existing_asset.is_nothing.not then Dictionary.empty else
                    ## Currently we just report the race condition and request the user to re-run.
                       We don't retry automatically because it is harder than it seems - the `create_action` usually
                       depends on some user code that is writing to a stream (the callback given to `with_output_stream`).
                       This action is generally not expected to be run more than once, but a simple retry logic would do exactly that.
                       If ever needed, we could implement a more sophisticated retry mechanism, that saves the payload
                       into memory or a temporary file and relies on that for the retry.
                       For now, reporting the race condition in a sane way seemed like the simplest choice.
                       This situation should be very rare.
                    Dictionary.from_vector [["resource_already_exists", Error.throw (Illegal_State.Error "A race-condition has been encountered - another process has created a colliding resource at "+destination.path+". Please try re-running the operation.")]]
                create_action parent_directory_asset existing_asset error_handlers

## PRIVATE
   `generate_request_body_and_result` should return a pair,
   where the first element is the request body and the second element is the result to be returned.
   It is executed lazily, only after all pre-conditions are successfully met.
perform_upload (destination : Enso_File) (allow_existing : Boolean) (~generate_request_body_and_result) =
    generic_create_asset destination allow_existing parent_directory_asset-> existing_asset-> error_handlers->
        if existing_asset.is_nothing.not && existing_asset.asset_type != Enso_Asset_Type.File then Error.throw (Illegal_Argument.Error "The destination must be a path to a file, not "+existing_asset.asset_type.to_text+".") else
            existing_asset_id = existing_asset.if_not_nothing <| existing_asset.id
            file_name = destination.name
            base_uri = URI.from Utils.files_api
                . add_query_argument "parent_directory_id" parent_directory_asset.id
                . add_query_argument "file_name" file_name
            full_uri = case existing_asset_id of
                Nothing -> base_uri
                _ -> base_uri . add_query_argument "file_id" existing_asset_id
            pair = generate_request_body_and_result
            Asset_Cache.invalidate destination
            response = Utils.http_request_as_json HTTP_Method.Post full_uri pair.first error_handlers=error_handlers
            response.if_not_error <|
                id = get_required_field "id" response expected_type=Text
                Asset_Cache.update destination (Existing_Enso_Asset.new id file_name) . if_not_error <|
                    pair.second

## PRIVATE
   Creates a directory at the given path, also creating parent directories if needed.
create_directory_with_parents (target : Enso_File) -> Existing_Enso_Asset =
    parent_file = target.parent
    parent_asset = Existing_Enso_Asset.get_asset_reference_for parent_file . catch File_Error error-> case error of
        File_Error.Not_Found _ ->
            if parent_file.enso_path.is_root then Error.throw (Illegal_State.Error "Unexpected error: when creating directory "+target.path+", reached the root directory and the backend reported that it does not exist - which should not happen. Please report this error.") else
                create_directory_with_parents parent_file
        _ -> error
    if parent_asset.is_directory.not then Error.throw (File_Error.Not_A_Directory parent_file) else
        body = JS_Object.from_pairs [["title", target.name], ["parentId", parent_asset.id]]
        Asset_Cache.invalidate target
        response = Utils.http_request_as_json HTTP_Method.Post Utils.directory_api body
        id = get_required_field "id" response expected_type=Text
        title = get_required_field "title" response expected_type=Text
        created_asset = Existing_Enso_Asset.new id title
        created_asset.if_not_error <|
            Asset_Cache.update target created_asset
            created_asset

## PRIVATE
create_datalink_from_stream_action (destination : Enso_File) (allow_existing : Boolean) (stream_action : Output_Stream -> Any) =
    generic_create_asset destination allow_existing parent_directory_asset-> existing_asset-> error_handlers->
        if existing_asset.is_nothing.not && existing_asset.asset_type != Enso_Asset_Type.Data_Link then Error.throw (Illegal_Argument.Error "The destination must be a path to a Data Link, not "+existing_asset.asset_type.to_text+".") else
            file_name = destination.name
            if file_name.ends_with data_link_extension . not then Error.throw (Illegal_Argument.Error "A datalink must have a name ending with "+data_link_extension+", but the provided name was: "+file_name) else
                title = file_name.drop (..Last data_link_extension.length)
                stream_result = Output_Stream.with_memory_stream stream_action
                raw_bytes = stream_result.first
                action_result = stream_result.second
                raw_json = Text.from_bytes raw_bytes data_link_encoding . parse_json . catch Invalid_JSON error->
                    Error.throw (Illegal_Argument.Error "A datalink can be created only with a valid JSON payload, but the written payload was invalid: "+error.to_display_text cause=error)
                stream_result.if_not_error <|
                    payload = JS_Object.from_pairs <|
                        [["parentDirectoryId", parent_directory_asset.id], ["name", title], ["value", raw_json]]
                            + (if existing_asset.is_nothing then [] else [["datalinkId", existing_asset.id]])

                    Asset_Cache.invalidate destination
                    response = Utils.http_request_as_json HTTP_Method.Post Utils.datalinks_api payload error_handlers=error_handlers
                    response.if_not_error <|
                        id = get_required_field "id" response expected_type=Text
                        Asset_Cache.update destination (Existing_Enso_Asset.new id title) . if_not_error <|
                            action_result

## PRIVATE
update_asset_description (asset : Enso_File) (description : Text) =
    existing_asset = Existing_Enso_Asset.get_asset_reference_for asset
    payload = JS_Object.from_pairs [["description", description]]
    Asset_Cache.invalidate asset
    Utils.http_request HTTP_Method.Patch existing_asset.asset_uri payload

## PRIVATE
update_asset_labels (asset : Enso_File) (new_labels : Vector Text) =
    existing_asset = Existing_Enso_Asset.get_asset_reference_for asset
    payload = JS_Object.from_pairs [["labels", new_labels]]
    Asset_Cache.invalidate asset
    Utils.http_request HTTP_Method.Patch existing_asset.asset_uri+"/labels" payload

## PRIVATE
create_tag (name : Text) (color : Color) =
    color_as_json = JS_Object.from_pairs <| case color of
        Color.HCL h c l -> [["lightness", l], ["chroma", c], ["hue", h]]
        _ -> Error.throw (Illegal_Argument.Error "Only colors expressed in HCL color-space are supported when creating labels.")
    payload = JS_Object.from_pairs <|
        [["value", name], ["color", color_as_json]]
    Utils.http_request_as_json HTTP_Method.Post Utils.tags_api payload

## PRIVATE
   Returns a list of known tags.
list_tags -> Vector Tag =
    response = Utils.http_request_as_json HTTP_Method.Get Utils.tags_api
    tags = get_required_field "tags" response expected_type=Vector
    tags.map tag_json->
        id = get_required_field "id" tag_json expected_type=Text
        value = get_required_field "value" tag_json expected_type=Text
        Tag.Value value id

## PRIVATE
type Tag
    ## PRIVATE
       We are not including the color, as we are not using it yet.
       Once needed, it should be added.
    Value value:Text id:Text

## PRIVATE
random_tag_color -> Color =
    lightness = 50
    chroma = 66
    hue = Random.integer 0 360
    Color.HCL hue chroma lightness

## PRIVATE
does_tag_exist (name : Text) -> Boolean =
    existing_tags = Hashset.from_vector <| list_tags.map .value
    existing_tags.contains name

## PRIVATE
create_tags_if_not_exist (names : Vector Text) =
    existing_tags = Hashset.from_vector <| list_tags.map .value
    tags_to_create = (Hashset.from_vector names).difference existing_tags . to_vector
    tags_to_create.each name->
        create_tag name random_tag_color
