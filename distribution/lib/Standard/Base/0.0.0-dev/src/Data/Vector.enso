import project.Any.Any
import project.Data.Array.Array
import project.Data.Filter_Condition.Filter_Condition
import project.Data.Index_Sub_Range.Index_Sub_Range
import project.Data.List.List
import project.Data.Numbers.Integer
import project.Data.Pair.Pair
import project.Data.Range.Range
import project.Data.Sort_Direction.Sort_Direction
import project.Data.Text.Text
import project.Error.Error
import project.Errors.Common.Incomparable_Values
import project.Errors.Common.Index_Out_Of_Bounds
import project.Errors.Common.No_Such_Method
import project.Errors.Common.Not_Found
import project.Errors.Common.Type_Error
import project.Errors.Empty_Error.Empty_Error
import project.Errors.Illegal_Argument.Illegal_Argument
import project.Errors.Problem_Behavior.Problem_Behavior
import project.Errors.Wrapped_Error.Wrapped_Error
import project.Function.Function
import project.Internal.Array_Like_Helpers
import project.Math
import project.Meta
import project.Nothing.Nothing
import project.Panic.Panic
import project.Random.Random
import project.Warning.Warning
from project.Data.Boolean import Boolean, False, True
from project.Data.Ordering import all
from project.Data.Range.Extensions import all
from project.Metadata import Display, Widget
from project.Runtime import assert

polyglot java import java.lang.IndexOutOfBoundsException

## The basic, immutable, vector type.
   A vector allows to store an arbitrary number of elements, in linear memory.
   It is the recommended data structure for most applications.

   > Example
     A vector containing the elements `1`, `2`, and `3`, in this order is:
         [1, 2, 3]

   > Example
     A vector containing 50 elements, each being the number `42`, can be
     created by:
         Vector.fill length=50 item=42

@Builtin_Type
type Vector a
    ## PRIVATE
       ADVANCED
       Creates a new vector of the given length, initializing elements using
       the provided constructor function.

       Arguments:
       - length: The length of the vector (>= 0).
       - constructor: A function taking the index in the vector and returning an
         item for that index in the vector.

       A vector allows to store an arbitrary number of elements in linear memory. It
       is the recommended data structure for most applications.

       > Example
         Create a vector containing the numbers 1 through 50.
             Vector.new 50 (ix -> ix + 1)

       > Example
         Create a copy of the given vector (`my_vec`).

             Vector.new my_vec.length (ix -> my_vec.at ix)
    new : Integer -> (Integer -> Any) -> Vector Any
    new length constructor = Array_Like_Helpers.vector_from_function length constructor Problem_Behavior.Report_Error

    ## PRIVATE
       ADVANCED
       Collects elements of a sequence into a new vector. Various structures can be
       converted into vector of elements. This helper methods allows to do so in an
       iterative fashion. Enough to describe how to extract value from current item
       and how to advance to next item.

       Arguments:
       - seq: the sequence to process.
       - element: A function taking the `seq` and follow ups and extracting the value to put into the vector
       - next: A function to advance to next _item_ of the sequence
       - limit: maximal number of elements to collect. Defaults to infinity.
       - stop_at: optional function like `(_==List.Nil)` to check for _end of sequence condition_.
          By default checks for `Nothing` being the terminal element of a collection.

       > Example
         Turn a list into a vector.
             Vector.collect (List.Cons 1 <| List.Cons 2 <| List.Nil) .x .xs stop_at=(_==List.Nil)
    collect : Any -> (Any -> Any) -> (Any -> Any) -> Integer | Nothing -> (Any -> Boolean) -> Vector Any
    collect seq element:(Any -> Any) next:(Any -> Any) limit:(Integer | Nothing)=Nothing stop_at:(Any -> Boolean)=(_==Nothing) =
        Vector.build initial_capacity=(if limit.is_nothing then 10 else limit) builder->
            iterate item remaining =
                done = remaining == 0 || (stop_at item)
                if done.not then
                    builder.append <| element item
                    @Tail_Call iterate (next item) (if remaining.is_nothing then Nothing else remaining-1)
            iterate seq limit

    ## PRIVATE
       ADVANCED

       Converts an array into a vector by copying content of the array.

       Arguments:
       - array: The array with content to copy into the new vector.

       A vector allows to store an arbitrary number of elements in linear memory. It
       is the recommended data structure for most applications.
    from_array : Array -> Vector
    from_array array = @Builtin_Method "Vector.from_array"

    ## PRIVATE
       A helper method that takes a vector or an array or a single element and
       returns a vector.

       If it got a vector or array, a vector containing the same elements is
       returned.
       If it got a single element, a vector containing this element is returned.
    unify_vector_or_element value = case value of
        vec : Vector -> vec
        arr : Array -> Vector.from_polyglot_array arr
        single_element -> [single_element]

    ## ALIAS repeat
       GROUP Constants
       ICON data_input
       Creates a new vector of the given length, filling the elements with
       the provided constant.

       Arguments:
       - length: The length of the vector (>= 0).
       - item: A value to be placed into each element of the vector.

       A vector allows to store an arbitrary number of elements in linear memory. It
       is the recommended data structure for most applications.

       > Example
         Create a vector containing 50 elements, each being the number `42`.

             Vector.fill length=50 item=42
    fill : Integer -> Any -> Vector Any
    fill length item =
        Vector.new length _->item

    ## PRIVATE
       ADVANCED
       Creates a new `Vector` by passing a `Builder` to the provided function.

       A vector `Builder` is a mutable data structure, that allows for gathering
       a number of elements and then converting them into a vector. This is
       particularly useful when the number of elements is not known upfront.

       `.build` creates a new `Builder`, passes it to the provided function,
       which can add elements using the `Builder`'s `.append` and
       `.append_vector_range` methods. When the function is done, `.build` then
       closes the `Builder` and returns the resulting `Vector`.

       The provided function should call `.append` or `.append_vector_range` to
       add new elements to the `Builder`. The return value of the provided
       function is not used, unless it is a dataflow error, in which case the
       `Vector` is not built, and the dataflow error is propagted instead.

       A vector allows to store an arbitrary number of elements in linear
       memory. It is the recommended data structure for most applications.

       Arguments:
       - function: a function taking a `Builder` and adding elements to it.
       - initial_capacity: Initial capacity of the `Builder`; this is for
         pre-allocation and does not affect the size of the resulting `Vector`.
       - propagate_warnings: If False, do not gather warnings from values
         added to the builder. Defaults to True.

       ! Error Conditions

         - If the provided function throws a dataflow error, the `Vector` is not
           built, and the error is propagted instead.

       > Example
         Construct a vector using a builder that contains the items 1 to 5.

             Vector.build builder->
                 builder.append 1
                 builder.append 2
                 builder.append 3
             # => [1, 2, 3]
    build : (Builder -> Any) -> Integer -> Boolean -> Vector
    build (function : Builder -> Any) (initial_capacity : Integer = 10) (propagate_warnings : Boolean = True) -> Vector =
        # Delegate to .build_multiple
        results_multiple = Vector.build_multiple 1 (builders-> function (builders.at 0)) initial_capacity propagate_warnings
        results_multiple.if_not_error (results_multiple.at 0)

    ## PRIVATE
       ADVANCED
       Creates multiple new `Vector`s by passing an array of `Builder`s to the
       provided function.

       A vector `Builder` is a mutable data structure, that allows for gathering
       a number of elements and then converting them into a vector. This is
       particularly useful when the number of elements is not known upfront.

       `.build_multiple` creates an array of new `Builder`s, passes it to the
       provided function, which can add elements to the individual `Builder`s
       using their `.append` and `.append_vector_range` methods. When the
       function is done, `.build_multiple` then closes the `Builder`s and
       returns an array of the resulting `Vector`s.

       The provided function should call `.append` or `.append_vector_range` to
       add new elements to the `Builder`s. The return value of the provided
       function is not used, unless it is a dataflow error, in which case the
       `Vector`s are not built, and the dataflow error is propagted instead.

       A vector allows to store an arbitrary number of elements in linear
       memory. It is the recommended data structure for most applications.

       Arguments:
       - function: a function taking an array of `Builder`s and adding elements
         to them.
       - initial_capacity: Initial capacity of the `Builder`s; this is for
         pre-allocation and does not affect the size of the resulting `Vector`s.

       ! Error Conditions

         - If the provided function throws a dataflow error, the `Vector`s are
         not built, and the error is propagted instead.

       > Example
         Construct two vectors using builders that contains the items 1 to 6.

             Vector.build_multiple 2 builders->
                 builder0 = builders.at 0
                 builder0.append 0
                 builder0.append 1
                 builder0.append 2
                 builder1 = builders.at 1
                 builder1.append 3
                 builder1.append 4
                 builder1.append 5
             # => [[0, 1, 2], [3, 4, 5]]
    build_multiple : Integer -> (Builder -> Any) -> Integer -> Boolean -> Vector Vector
    build_multiple (count : Integer) (function : Builder -> Any) (initial_capacity : Integer = 10) (propagate_warnings : Boolean = True) -> Vector Vector =
        if count < 0 then Error.throw (Illegal_Argument.Error "count must be non-negative: "+count.to_text) else
            builders = Range.new 0 count . map (_-> Builder.new initial_capacity propagate_warnings)
            Panic.handle_wrapped_dataflow_error <|
                function builders . if_not_error (builders.map .to_vector)

    ## PRIVATE
       ADVANCED

       Converts a polyglot value representing an array into a vector.

       Arguments:
       - arr: The polyglot array value to wrap into a vector.

       This is useful when wrapping polyglot APIs for further use in Enso.

       A vector allows to store an arbitrary number of elements in linear memory. It
       is the recommended data structure for most applications.
    from_polyglot_array : Any -> Vector Any
    from_polyglot_array array = @Builtin_Method "Vector.from_polyglot_array"

    ## PRIVATE
       ADVANCED
       Copies content of a vector into an Array.
    to_array self = Array_Like_Helpers.vector_to_array self

    ## GROUP Metadata
       ICON metadata
       Returns the number of elements stored in this vector.

       > Example
         Checking the length of a vector.

             [1, 2, 3, 4].length
    length : Integer
    length self = Array_Like_Helpers.length self

    ## GROUP Selections
       ICON parse3
       Gets an element from the vector at a specified index (0-based).

       Arguments:
       - index: The location in the vector to get the element from. The index is
         also allowed be negative, then the elements are indexed from the back
         of the vector, i.e. -1 will correspond to the last element.

       > Example
         Get the second element of a vector.

             [1, 2, 3].at 1 == 2

       > Example
         Get the last element of a vector.

             [1, 2, 3].at -1 == 3
    @index (t-> Widget.Numeric_Input minimum=0 maximum=t.length-1 display=Display.Always)
    at : Integer -> Any ! Index_Out_Of_Bounds
    at self index:Integer=0 = Array_Like_Helpers.at self index

    ## ICON parse3
       Gets an element from the vector at a specified index (0-based).
       If the index is invalid then `if_missing` is returned.

       Arguments:
       - index: The location in the vector to get the element from. The index is
         also allowed be negative, then the elements are indexed from the back
         of the vector, i.e. -1 will correspond to the last element.
       - if_missing: The value to return if the index is out of bounds.
    @index (t-> Widget.Numeric_Input minimum=0 maximum=t.length-1 display=Display.Always)
    get : Integer -> Any -> Any
    get self index:Integer=0 ~if_missing=Nothing =
        Array_Like_Helpers.get self index if_missing

    ## ICON column_add
       Combines all the elements of the vector, by iteratively applying the
       passed function with next elements of the vector.

       Arguments:
       - init: The initial value for the fold.
       - function: A function taking two elements and combining them.

       In general, the result of
           [l0, l1, ..., ln] . fold init f
       is the same as
           f (...(f (f init l0) l1)...) ln

       > Example
         Compute the sum of all of the elements in a vector.

             [0, 1, 2] . fold 0 (+)
    fold : Any -> (Any -> Any -> Any) -> Any
    fold self init function =
        Array_Like_Helpers.fold self init function

    ## ICON column_add
       Combines all the elements of the vector, by iteratively applying the
       passed function with next elements of the vector.

       Arguments:
       - init: The initial value for the fold.
       - function: A function taking the current value, an index and an item
         and combining them.

       > Example
         Compute the sum of all of the elements and indexes in a vector.

             [0, 1, 2] . fold_with_index 0 (s->i->e->s+i+e)
    fold_with_index : Any -> (Any -> Integer -> Any -> Any) -> Any
    fold_with_index self init function =
        Array_Like_Helpers.fold_with_index self init function

    ## ICON column_add
       Combines all the elements of the vector, by iteratively applying the
       passed function with the next element of the vector. After each step the
       value is stored resulting in a new vector of the same size as self.

       Arguments:
       - init: The initial value for the fold.
       - function: A function taking two elements and combining them.

       > Example
         Compute the running sum of all of the elements in a vector

            [1, 2, 3].running_fold 0 (+)
    running_fold : Any -> (Any -> Any -> Any) -> Vector Any
    running_fold self init function =
        Array_Like_Helpers.running_fold self init function

    ## ICON column_add
       Combines all the elements of a non-empty vector using a binary operation.
       If the vector is empty, it returns `if_empty`.

       Arguments:
       - function: A binary operation that takes two items and combines them.
       - if_empty: Value returned if the vector is empty.

       > Example
         Compute the sum of all the elements in a vector.

             [0, 1, 2] . reduce (+)
    reduce : (Any -> Any -> Any) -> Any -> Any
    reduce self function ~if_empty=(Error.throw (Empty_Error.Error Vector)) =
        Array_Like_Helpers.reduce self function if_empty

    ## GROUP Selections
       ICON find
       Returns the first element of the vector that satisfies the condition or
       `if_missing` if no elements of the vector satisfy it.

       Arguments:
       - condition: A `Filter_Condition` or a function that takes an element and
         returns a boolean value specifying if it satisfies the condition.
       - start: The index to start searching from. If the index is negative, it
         is counted from the end of the vector.
       - if_missing: Value returned if no element satisfies the predicate.

       > Example
         Finding a first element of the vector that is larger than 3.

             [1, 2, 3, 4, 5].find (> 3)
    @condition Filter_Condition.default_widget
    find : (Filter_Condition | (Any -> Boolean)) -> Integer -> Any -> Any
    find self (condition : Filter_Condition | (Any -> Boolean)) (start : Integer = 0) ~if_missing=(Error.throw Not_Found) =
        Array_Like_Helpers.find self condition start if_missing

    ## GROUP Values
       ICON find
       Returns the index of an element in the vector.
       Returns Nothing if the element is not found.

       Arguments:
       - condition: Either the element to search for, a `Filter_Condition` or a
         predicate function to test each element.
       - start: The index to start searching from. If the index is negative, it
         is counted from the end of the vector.

       > Example
         Find the index of an element in a vector.

             [1, 2, 3].index_of 2 == 1

       > Example
         Find the index of the first palindrome.

             ["ab", "abab", "aba", "bbb"].index_of (s-> s == s.reverse) == 2
    @condition Filter_Condition.default_widget
    index_of : (Any | Filter_Condition | (Any -> Boolean)) -> Integer -> Integer | Nothing
    index_of self condition (start : Integer = 0) =
        Array_Like_Helpers.index_of self condition start

    ## GROUP Values
       ICON find
       Returns the last index of an element in the vector.
       Returns `Nothing` if the element is not found.

       Arguments:
       - condition: Either the element to search for, a `Filter_Condition` or a
         predicate function to test each element.
       - start: The index to start searching backwards from. If the index is
         negative, it is counted from the end of the vector.

       > Example
         Find the last index of an element in a vector.

             [1, 2, 3, 1, 2, 3].last_index_of 2 == 4

       > Example
         Find the index of the last palindrome.

             ["ab", "abab", "aba", "bbb"].last_index_of (s-> s == s.reverse) == 3
    @condition Filter_Condition.default_widget
    last_index_of : (Any | Filter_Condition | (Any -> Boolean)) -> Integer -> Integer | Nothing
    last_index_of self condition (start : Integer = -1) =
        Array_Like_Helpers.last_index_of self condition start

    ## GROUP Logical
       ICON preparation
       Checks whether a predicate holds for at least one element of self vector.

       Arguments:
       - condition: A `Filter_Condition` or a predicate function to test each
         element.

       > Example
         Checking if any element of the vector is larger than 3.

             [1, 2, 3, 4, 5].any (..Greater than=3)

       > Example
         Checking if any element of the vector is even.

             [1, 2, 3, 4, 5].any (x-> x%2 == 0)
    @condition Filter_Condition.default_widget
    any : (Filter_Condition | (Any -> Boolean)) -> Boolean
    any self (condition : Filter_Condition | (Any -> Boolean)) =
        Array_Like_Helpers.any self condition

    ## GROUP Logical
       ICON preparation
       Checks whether a condition holds for all elements in this vector.

       Arguments:
       - condition: A `Filter_Condition` or a predicate function to test each
         element.

       > Example
         Check if all elements in the vector are less than zero.

             [-1, 1, 5, 8].all (..Less than=0)

       > Example
         Check if all elements in the vector are even.

             [-1, 1, 5, 8].all (x-> x%2 == 0)
    @condition Filter_Condition.default_widget
    all : (Filter_Condition | (Any -> Boolean)) -> Boolean
    all self (condition : Filter_Condition | (Any -> Boolean)) =
        Array_Like_Helpers.all self condition

    ## GROUP Logical
       ICON preparation
       Checks whether this vector contains a given value as an element.

       Arguments:
       - elem: The item to see if it exists in the vector.

       > Example
         Checking if the vector contains the number 72.

             [1, 383, 72, 301].contains 72
    contains : Any -> Boolean
    contains self elem = self.any (== elem)

    ## GROUP Logical
       ICON metadata
       Checks if this vector is empty.

       > Example
         Checking for emptiness.

             [].is_empty
    is_empty : Boolean
    is_empty self = self.length == 0

    ## GROUP Logical
       ICON metadata
       Checks if this vector is not empty.

       > Example
         Checking for non-emptiness.

             [1].not_empty
    not_empty : Boolean
    not_empty self = self.is_empty.not

    ## GROUP Selections
       ICON preparation
       Selects all elements of this vector which satisfy a condition.

       Arguments:
       - filter: The filter to apply to the vector. It can either be an instance
         of `Filter_Condition` or a predicate taking a value and returning a
         boolean value indicating whether the corresponding element should be
         kept or not.

       > Example
         Selecting all elements that are greater than 3.

             [1, 2, 3, 4, 5].filter (> 3)
             [1, 2, 3, 4, 5].filter (..Greater than=3)
    @filter Filter_Condition.default_widget
    filter : (Filter_Condition | (Any -> Boolean)) -> Vector Any
    filter self (filter : Filter_Condition | (Any -> Boolean)) =
        Array_Like_Helpers.filter self filter

    ## GROUP Selections
       ICON preparation
       Selects all elements of this vector which satisfy a predicate.

       Arguments:
       - predicate: A function that takes an index and a list element and
         returns a boolean value that says whether that value should be included
         in the result.

       > Example
         Selecting all elements which are equal to their position in the vector.

             [0, 10, 2, 2].filter (==) == [0, 2]
    filter_with_index : (Integer -> Any -> Boolean) -> Vector Any
    filter_with_index self predicate =
        Array_Like_Helpers.filter_with_index self predicate

    ## GROUP Selections
       ICON split
       Partitions the vector into `Vector`s of elements which satisfy a given
       condition and ones that do not.

       Returns a `Pair` whose `first` element is the `Vector` of elements
       satisfying the predicate and the `second` element is a `Vector` of elements
       which did not satisfy it.

       The relative order of elements kept in each returned list is the same as
       in the input vector.

       Arguments:
       - condition: A `Filter_Condition` or a predicate function to test each
         element.

       > Example
         Splitting a vector into elements that start with a prefix.

             ["a", "b", "ax", "bx"].partition (..Starts_With "a") == (Pair ["a", "ax"] ["b", "bx"])

       > Example
         Splitting a vector into even and odd elements.

             [1, 2, 3, 4, 5].partition (x -> x % 2 == 0) == (Pair [2, 4] [1, 3, 5])
    @condition Filter_Condition.default_widget
    partition : (Filter_Condition | (Any -> Boolean)) -> Pair (Vector Any) (Vector Any)
    partition self (condition : Filter_Condition | (Any -> Boolean)) =
        Array_Like_Helpers.partition self condition

    ## ICON preparation
       Partitions the vector into `Vector`s of elements which satisfy a given
       predicate and ones that do not.

       Returns a `Pair` whose `first` element is the `Vector` of elements
       satisfying the predicate and the `second` element is a `Vector` of elements
       which did not satisfy it.

       The relative order of elements kept in each returned list is the same as
       in the input vector.

       Arguments:
       - predicate: A function that takes an index and an element and returns a
         boolean value.

       > Example
         Splitting a vector into elements at even and odd positions.

             ["a", "b", "c", "d"].partition_with_index (ix -> _ -> ix % 2 == 0) == (Pair ["a", "c"] ["b", "d"])
    partition_with_index : (Integer -> Any -> Boolean) -> Pair (Vector Any) (Vector Any)
    partition_with_index self predicate =
        Array_Like_Helpers.partition_with_index self predicate

    ## GROUP Selections
       ICON map_row
       Swaps the rows and columns of a matrix represented by a vector of vectors.

       ! Error Conditions

         - If the rows (subvectors) do not all have the same length, an
         `Illegal_Argument` error is raised.

       > Example
         Transpose a vector of vectors.

             matrix = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
             # +---+---+---+
             # | 0 | 1 | 2 |
             # +---+---+---+
             # | 3 | 4 | 5 |
             # +---+---+---+
             # | 6 | 7 | 8 |
             # +---+---+---+

             transposed = [[0, 3, 6], [1, 4, 7], [2, 5, 8]]
             # +---+---+---+
             # | 0 | 3 | 6 |
             # +---+---+---+
             # | 1 | 4 | 7 |
             # +---+---+---+
             # | 2 | 5 | 8 |
             # +---+---+---+

             matrix.transposed == transposed
             # => True
    transpose : Vector (Vector Any) ! Illegal_Argument
    transpose self =
        Array_Like_Helpers.transpose self

    ## ICON column_add
       Applies a function to each element of the vector, returning the `Vector` of
       results.

       Arguments:
       - function: A function that takes an element in the vector and returns
         some transformation of that element.
       - on_problems: Specifies how to handle any problems that arise in
         `function`.

       ! Error Conditions

         The result of Errors thrown when executing the function depend on
         `on_problems`:
         - Report_Error: The first error is thrown, and is wrapped in
           `Map_Error`.
         - No_Wrap: The first error is thrown, and is not wrapped in
           `Map_Error`.
         - Report_Warning: The result for that element is `Nothing`,
           the error is attached as a warning. Currently unimplemented.
         - Ignore: The result is `Nothing`, and the error is
           ignored.

         Errors that are thrown when executing the supplied function are wrapped
         in `Map_Error`, which contains the index at which the error occurred.

         In the `Report_Warning` case, only `MAX_MAP_WARNINGS`
         warnings are attached to result values. After that, the warnings are
         dropped, but a count of the additional warnings is attached in an
         `Additional_Warnings` warning.

       > Example
         Add 1 to each element of the vector.

             [1, 2, 3] . map +1
    map : (Any -> Any) -> Problem_Behavior | No_Wrap -> Vector Any
    map self function on_problems:(Problem_Behavior | No_Wrap)=..Report_Error =
        Array_Like_Helpers.map self function on_problems

    ## ICON union
       Applies a function to each element of the vector, returning the `Vector`
       that contains all results concatenated.

       Arguments:
       - function: A function that takes an element in the vector, transforms
         it, and returns a `Vector`.
       - on_problems: Specifies how to handle any problems that arise in
         `function`.

       ! Error Conditions

         The result of Errors thrown when executing the function depend on
         `on_problems`:
         - Report_Error: The first error is thrown, and is wrapped in
           `Map_Error`.
         - No_Wrap: The first error is thrown, and is not wrapped in
           `Map_Error`.
         - Report_Warning: The result for that element is `Nothing`,
           the error is attached as a warning. Currently unimplemented.
         - Ignore: The result is `Nothing`, and the error is
           ignored.

         Errors that are thrown when executing the supplied function are wrapped
         in `Map_Error`, which contains the index at which the error occurred.

         In the `Report_Warning` case, only `MAX_MAP_WARNINGS`
         warnings are attached to result values. After that, the warnings are
         dropped, but a count of the additional warnings is attached in an
         `Additional_Warnings` warning.

       > Example
         Replace each number `n` in the vector with itself repeated n times.

            [0, 1, 2] . flat_map (n -> Vector.fill n n)
    flat_map : (Any -> Vector Any) -> Problem_Behavior | No_Wrap -> Vector Any
    flat_map self function on_problems:(Problem_Behavior | No_Wrap)=..Report_Error =
        Array_Like_Helpers.flat_map self function on_problems

    ## GROUP Calculations
       ICON union
       Transforms a vector of vectors into a `Vector` of inner elements - removes
       one layer of nesting from a stack of nested vectors.

       > Example
         Flatten a vector of vectors of numbers.

            [[1, 2, 3], [4, 10], [], [0], [0]] . flatten == [1, 2, 3, 4, 10, 0, 0]
    flatten : Vector Any
    flatten self = Array_Like_Helpers.flatten self

    ## ICON column_add
       Applies a function to each element of the vector, returning the `Vector`
       of results.

       Arguments:
       - function: A function that takes an index and an item and calculates a
         new value for at that index.
       - on_problems: Specifies how to handle any problems that arise in
         `function`.

       The function is called with both the element index as well as the
       element itself.

       ! Error Conditions

         The result of Errors thrown when executing the function depend on
         `on_problems`:
         - Report_Error: The first error is thrown, and is wrapped in
           `Map_Error`.
         - No_Wrap: The first error is thrown, and is not wrapped in
           `Map_Error`.
         - Report_Warning: The result for that element is `Nothing`,
           the error is attached as a warning. Currently unimplemented.
         - Ignore: The result is `Nothing`, and the error is
           ignored.

         Errors that are thrown when executing the supplied function are wrapped
         in `Map_Error`, which contains the index at which the error occurred.

         In the `Report_Warning` case, only `MAX_MAP_WARNINGS`
         warnings are attached to result values. After that, the warnings are
         dropped, but a count of the additional warnings is attached in an
         `Additional_Warnings` warning.

       > Example
         Sum numbers with their indices in a vector.

             [1, 2, 3].map_with_index (+)
    map_with_index : (Integer -> Any -> Any) -> Problem_Behavior | No_Wrap -> Vector Any
    map_with_index self function on_problems:(Problem_Behavior | No_Wrap)=..Report_Error =
        Array_Like_Helpers.map_with_index self function on_problems

    ## PRIVATE
       ADVANCED
       Applies a function to each element of the vector.

       Unlike `map`, this method does not return the individual results,
       therefore it is only useful for side-effecting computations.

       If the function returns a dataflow error, the error is converted to a
       panic and thrown immediately stopping further processing.

       Arguments:
       - function: A function to apply to each element of the vector.

       > Example
         Print each element in the vector to standard output.

             [1, 2, 3, 4, 5] . each IO.println
    each : (Any -> Any) -> Nothing
    each self f =
        Array_Like_Helpers.each self f

    ## PRIVATE
       ADVANCED
       Applies a function to each element of the vector.

       Arguments:
       - function: A function to apply that takes an index and an item.

       The function is called with both the element index as well as the
       element itself.

       Unlike `map`, this method does not return the individual results,
       therefore it is only useful for side-effecting computations.

       > Example
         Print each element in the vector to standard output.

             [1, 2, 3, 4, 5] . each_with_index (ix->elem-> IO.println Pair ix elem)
    each_with_index : (Integer -> Any -> Any) -> Nothing
    each_with_index self f =
        Array_Like_Helpers.each_with_index self f

    ## GROUP Selections
       ICON order
       Reverses the vector, returning a `Vector` with the same elements, but in
       the opposite order.

       > Example
         Reverse a two-element vector.

             [1, 2].reverse
    reverse : Vector Any
    reverse self =
        Array_Like_Helpers.reverse self

    ## PRIVATE
       Generates a human-readable text representation of the vector.
    to_text : Text
    to_text self = self.map .to_text . join ", " "[" "]"

    ## PRIVATE
    to_display_text : Text
    to_display_text self = self.short_display_text max_entries=40

    ## PRIVATE
       ADVANCED

       Generates a human-readable text representation of the vector, keeping its
       length limited.

       Arguments:
       - max_entries: The maximum number of entries that are displayed. If the
         vector contains more elements, the number of hidden elements is also
         displayed.

       > Example
         Convert a large vector of numbers to a short text.

             (0.up_to 100).to_vector.short_display_text max_entries=2 == "[0, 1 and 98 more elements]"
    short_display_text : Integer -> Text
    short_display_text self (max_entries : Integer = 10) =
        Array_Like_Helpers.short_display_text self max_entries

    ## ALIAS append, concatenate, union
       GROUP Operators
       ICON union
       Concatenates two vectors, resulting in a new `Vector`, containing all the
       elements of `self`, followed by all the elements of `that`.

       Arguments:
       - that: The vector to concatenate to the end of `self`.

       > Example
         Concatenate two single-element vectors.

             [1] + [2]
    + : Vector Any | Array -> Vector Any
    + self that:(Vector | Array) =
        Array_Like_Helpers.plus self that

    ## GROUP Calculations
       ICON row_add
       Inserts the given item into the vector at the given index.

       Arguments:
       - at: The index at which to insert the item before.
         If the index is less than 0, the index will be counted back from the
         end. If the index is equal to the length of the vector, the item will
         be appended to the end of the vector.
       - item: The item to insert into the vector.

       > Example
         Insert 'X' into a vector at different locations:

            ['a', 'b', 'c'].insert 1 'X' == ['a', 'X', 'b', 'c']
            ['a', 'b', 'c'].insert -1 'X' == ['a', 'b', 'X', 'c']
            ['a', 'b', 'c'].insert item='X' == ['a', 'b', 'c', 'X']
    insert : Integer -> Any -> Vector ! Index_Out_Of_Bounds
    insert self at=self.length item=Nothing =
        Array_Like_Helpers.insert self at item

    ## GROUP Selections
       ICON table_clean
       Removes the item at the given index from the vector.

       Arguments:
       - at: The index at which to remove the item.
         If the index is less than 0, the index will be counted back from the
         end.
    remove : Integer -> Vector
    remove self at=-1 =
        Array_Like_Helpers.remove self at

    ## GROUP Calculations
       ICON join
       When `self` is a vector of text values, concatenates all the values by
       interspersing them with `separator`.

       Arguments:
       - separator (optional): The text to use to join the textual elements of the vector.
       - prefix (optional): The prefix to add at the beginning.
       - suffix (optional): The suffix to add at the end.

       > Example
         Join the elements of the vector together as a string.

             ["foo", "bar", "baz"].join ", "
    join : Text -> Text -> Text -> Text
    join self separator:Text="" prefix:Text="" suffix:Text="" =
        Array_Like_Helpers.join self separator prefix suffix

    ## PRIVATE
       Creates a new vector with the skipping elements until `start` and then
       continuing until `end` index.

       Arguments:
       - start: The index of the first element to include.
       - end: The index to stop slicing at.

       > Example
         Remove the first 2 elements then continue until index 5 from the vector.

             [1, 2, 3, 4, 5, 6, 7, 8].slice 2 5 == [3, 4, 5]
    slice : Integer -> Integer -> Vector Any
    slice self start end = Array_Like_Helpers.slice self start end

    ## ALIAS first, head, last, limit, sample, slice, tail, top, keep
       GROUP Selections
       ICON parse3
       Creates a new `Vector` with only the specified range of elements from the
       input, removing any elements outside the range.

       Arguments:
       - range: The section of the this vector to return.
         If an `Index_Sub_Range`, then the selection is interpreted following
         the rules of that type.
         If a `Range`, the selection is specified by two indices, from and to.
    @range (self-> Index_Sub_Range.default_widget self.length)
    take : (Index_Sub_Range | Range | Integer) -> Vector Any
    take self range:(Index_Sub_Range | Range | Integer)=..First =
        Array_Like_Helpers.take self range

    ## ALIAS skip, remove
       GROUP Selections
       ICON parse3
       Creates a new `Vector`, removing any elements from the specified range.

       Arguments:
       - range: The section of the this vector to return.
         If an `Index_Sub_Range`, then the selection is interpreted following
         the rules of that type.
         If a `Range`, the selection is specified by two indices, from and to.
    @range (self-> Index_Sub_Range.default_widget self.length)
    drop : (Index_Sub_Range | Range | Integer) -> Vector Any
    drop self range:(Index_Sub_Range | Range | Integer)=..First =
        Array_Like_Helpers.drop self range

    ## ALIAS combine, join by row position, merge
       GROUP Calculations
       ICON join2-1
       Performs a pair-wise operation passed in `function` on consecutive
       elements of `self` and `that`.

       Arguments:
       - that: The vector to zip with `self`.
       - function: The function used to combine pairwise elements of `self` and
         `that`.
       - on_problems: Specifies how to handle any problems that arise in
         `function`.

       The result of this function is a `Vector` of length being the shorter of
       `self` and `that`, containing results of calling `function`.

       ! Error Conditions

         The result of Errors thrown when executing the function depend on
         `on_problems`:
         - Report_Error: The first error is thrown, and is wrapped in
           `Map_Error`.
         - No_Wrap: The first error is thrown, and is not wrapped in
           `Map_Error`.
         - Report_Warning: The result for that element is `Nothing`,
           the error is attached as a warning. Currently unimplemented.
         - Ignore: The result is `Nothing`, and the error is
           ignored.

         Errors that are thrown when executing the supplied function are wrapped
         in `Map_Error`, which contains the index at which the error occurred.

         In the `Report_Warning` case, only `MAX_MAP_WARNINGS`
         warnings are attached to result values. After that, the warnings are
         dropped, but a count of the additional warnings is attached in an
         `Additional_Warnings` warning.

       > Example
         Calculate the pairwise sum of two vectors.

             [1, 2, 3].zip [4, 5, 6] (+)

       > Example
         When the `function` is not provided, it defaults to creating a pair
         of both elements.

             [1, 2, 3].zip [4, 5, 6] == [[1, 4], [2, 5], [3, 6]]
    zip : Vector Any -> (Any -> Any -> Any) -> Problem_Behavior | No_Wrap -> Vector Any
    zip self that:Vector function=[_,_] on_problems:(Problem_Behavior | No_Wrap)=..Report_Error =
        len = self.length.min that.length
        Array_Like_Helpers.vector_from_function len (i-> function (self.at i) (that.at i)) on_problems

    ## GROUP Calculations
       ICON union
       Extend `self` vector to the length of `n` appending elements `elem` to
       the end.

       Arguments:
       - n: The length to pad `self` out to.
       - elem: The element to fill the new padded slots with.

       If the new length `n` is less than existing length, `self` vector is
       returned.

       > Example
         Extending vector to the length of 5

             [1, 2, 3].pad 5 0 == [1, 2, 3, 0, 0]

       > Example
         Extending vector to the length of 5

             [1, 2, 3, 4, 5].pad 5 0 == [1, 2, 3, 4, 5]
    pad : Integer -> Any -> Vector Any
    pad self n elem =
        Array_Like_Helpers.pad self n elem

    ## GROUP Selections
       ICON parse3
       Get the first element from the vector, or an `Index_Out_Of_Bounds` if the vector
       is empty.

       > Example
         The following code returns 1.

             [1, 2, 3, 4].first
    first : Any ! Index_Out_Of_Bounds
    first self = self.at 0

    ## GROUP Selections
       ICON select_row
       Get the last element of the vector, or an `Index_Out_Of_Bounds` if the vector is
       empty.

       > Example
         The following code returns 4.

             [1, 2, 3, 4].last
    last : Any ! Index_Out_Of_Bounds
    last self = self.at -1

    ## GROUP Selections
       ICON parse3
       Get the second element from the vector, or a `Index_Out_Of_Bounds` if the
       vector doesn't have a second element.

       Useful when tuples are implemented as vectors.

       > Example
         The following code returns 2.

             [1, 2, 3, 4].second
    second : Any ! Index_Out_Of_Bounds
    second self = self.at 1

    ## ALIAS order_by
       GROUP Calculations
       ICON order
       Sort the vector.

       Arguments:
       - order: The order in which the vector elements are sorted.
       - on: A projection from the element type to the value of that element
         being sorted on. If set to `Nothing` (the default),
         identity function will be used.
       - by: A function that compares the result of applying `on` to two
         elements, returning an an `Ordering` if the two elements are comparable
         or `Nothing` if they are not. If set to `Nothing` (the default argument),
         `Ordering.compare _ _` method will be used.
       - on_problems: A `Problem_Behavior` specifying what should happen if two
         incomparable values are encountered.

       By default, elements are sorted in ascending order.

       This is a stable sort, meaning that items that compare the same will not
       have their order changed by the sorting process.

       ! Computational Complexity
         The complexities for this sort are:
         - *Worst-Case Time:* `O(n * log n)`
         - *Best-Case Time:* `O(n)`
         - *Average Time:* `O(n * log n)`
         - *Worst-Case Space:* `O(n)` additional

       ? Incomparable values
         Incomparable values are either values with different comparators or with
         the same comparator returning `Nothing` from its `compare` method.
         See the documentation of the `Ordering` module for more info.

       ? Implementation Note
         The sort implementation is based upon an adaptive, iterative mergesort
         that requires far fewer than `n * log(n)` comparisons when the vector
         is partially sorted. When the vector is randomly ordered, the
         performance is equivalent to a standard mergesort.

       ? Multiple comparators
         Elements with different comparators are incomparable by definition.
         This case is handled by first grouping the `self` vector into groups
         with the same comparator, recursively sorting these groups, and then
         merging them back together. The order of the sorted groups in the
         resulting vector is based on the order of fully qualified names of
         the comparators in the `self` vector, with the exception of the group
         for the default comparator, which is always the first group.

         Additionally, an `Incomparable_Values` dataflow error will be returned
         if the `on_problems` parameter is set to `Report_Error`, or a warning
         attached if the `on_problems` parameter is set to `Report_Warning` in
         case of encountering incomparable values.

         It takes equal advantage of ascending and descending runs in the array,
         making it much simpler to merge two or more sorted arrays: simply
         concatenate them and sort.

       > Example
         Sorting a vector of numbers.

             [5, 2, 3, 45, 15].sort == [2, 3, 5, 15, 45]

       > Example
         Sorting a vector of `Pair`s on the first element, descending.

             [Pair 1 2, Pair -1 8].sort Sort_Direction.Descending (_.first)

       > Example
         Sorting a vector with elements with different comparators. Values `1`
         and `My_Type` have different comparators. `1` will be sorted before `My_Type`
         because it has the default comparator.

             [My_Type.Value 'hello', 1].sort == [1, My_Type.Value 'hello']
    sort : Sort_Direction -> (Any -> Any)|Nothing -> (Any -> Any -> (Ordering|Nothing))|Nothing -> Problem_Behavior -> Vector Any ! Incomparable_Values
    sort self (order = Sort_Direction.Ascending) on=Nothing by=Nothing on_problems:Problem_Behavior=..Ignore =
        Array_Like_Helpers.sort self order on by on_problems

    ## ALIAS deduplicate, unique
       GROUP Selections
       ICON preparation
       Keeps only unique elements within the vector, removing any duplicates.

       Arguments:
       - on: A projection from the element type to the value of that element
             which determines the uniqueness criteria.

       The returned unique elements are kept in the same order as they appeared
       in the input.

       Out of multiple equivalent (equal up to the `on` projection) elements,
       always the one appearing first in the input is kept.

       > Example
         Removing repeating entries.

             [1, 3, 1, 2, 2, 1] . distinct == [1, 3, 2]

       > Example
         Keeping only pairs whose first elements are unique.

             [Pair 1 "a", Pair 2 "b", Pair 1 "c"] . distinct (on = _.first) == [Pair 1 "a", Pair 2 "b"]
    distinct : (Any -> Any) -> Vector Any
    distinct self (on = x->x) =
        Array_Like_Helpers.distinct self on

    ## ALIAS duplicates
       GROUP Selections
       ICON preparation
       Returns only non-unique elements within the vector.

       Arguments:
       - on: A projection from the element type to the value of that element
             which determines the uniqueness criteria.

       The returned duplicate elements are kept in the same order as the
       first duplicate appeared in the input.

       > Example
         Removing unique entries.

             [1, 3, 1, 2, 2, 1] . duplicates == [1, 1, 2, 2, 1]
    duplicates : (Any -> Any) -> Vector Any
    duplicates self (on = x->x) =
        Array_Like_Helpers.duplicates self on

    ## ICON convert
       Returns the vector as a `Vector`.
    to_vector : Vector
    to_vector self = self

    ## ICON convert
       Converts the vector to a list with the same elements.
    to_list : List
    to_list self = Array_Like_Helpers.to_list self

## PRIVATE
type Builder
    ## PRIVATE

       A builder type for Enso vectors.

       Arguments:
       - elements_java_builder: The accumulator for the new vector.
       - warnings_java_builder: The accumulator for `Warning`s that were
         attached to values added to the builder.
       - propagate_warnings: If False, do not gather warnings from values
         added to the builder. Defaults to True.

       A vector builder is a mutable data structure, that allows to gather a
       number of elements and then convert them to a vector. This is
       particularly useful when the number of elements is not known upfront.

       There are two ways to create and use a `Builder`: `Builder.new`
       and `Vector.build`. `.build` is the preferred approach.
       - `Builder.new`: creates a new `Builder`, which you have to
         "close" with `.to_vector` at the end to get your newly-created
         `Vector`.
       - `Vector.build`: takes a function which uses the `Builder`, and
         automatically "closes" and returns the newly-created `Vector`.

       ! Error Conditions

         - If  an uncaught dataflow error is appended with `append` or
           `append_vector_range`, an internal panic is thrown, aborting the
           builder callback that attempted to add the error to the builder. This
           internal panic is caught by `Vector.build`, which then propagates the
           dataflow error. The vector is not built.

         - If a dataflow error is thrown from the builder callback, it is
           propagated by `Vector.build`. The vector is not built.

         - If a value with an attached warning is added to the builder, the
           vector is built, and the resulting `Vector` keeps the attached
           warning.

       > Example
         Append three items.

             Vector.build builder->
                 builder.append 1
                 builder.append 2
                 builder.append 3
             # => [1, 2, 3]
    private Value elements_java_builder warnings_java_builder (propagate_warnings : Boolean)

    ## PRIVATE
       ADVANCED

       Creates a new vector builder instance.

       `Vector.build` is the preferred way to build `Vector`s.

       A vector `Builder` is a mutable data structure, that allows for gathering
       a number of elements and then converting them into a vector. This is
       particularly useful when the number of elements is not known upfront.

       A vector allows to store an arbitrary number of elements in linear
       memory. It is the recommended data structure for most applications.

       The `Vector.build` method is preferred over direct use of `Builder.new`,
       since it automatically closes and returns the finished `Vector`. The
       `Builder.new` approach requires the caller to explicitly call `to_vector`
       at the end, which can be more flexible within imperative code.

       Arguments:
       - capacity: Initial capacity of the Vector.Builder
       - propagate_warnings: If False, do not gather warnings from values
         added to the builder. Defaults to True.

       > Example
         Construct a vector using a builder that contains the items 1 to 5.

             builder = Builder.new 5
             do_build start stop =
                 builder.append start
                 if start >= stop then Nothing else
                     @Tail_Call do_build start+1 stop
             do_build 1 5
             builder.to_vector
             # => [1, 2, 3, 4]
    new : Integer -> Boolean -> Builder
    new (capacity : Integer = 10) (propagate_warnings : Boolean = True) -> Builder = Builder.Value (Array_Like_Helpers.new_vector_builder capacity) (Array_Like_Helpers.new_vector_builder 0) propagate_warnings

    ## ICON join
       Appends a new element into this builder.

       Arguments:
       - item: The item to append to the vector builder.

       ? Appending Dataflow Errors

         If a dataflow error is added to the builder, the result depends on
         whether the `Builder` is being used from `.build` or created directly
         with `new`.

         - When using `.build`: The dataflow error is re-thrown by the containing
           invocation of `Vector.build`.  The error is not added to the builder.

         - When using `Builder.new` directly : The dataflow error is wrapped in
           a `Wrapped_Dataflow_Error` and thrown as a `Panic`. The error is not
           added to the builder.

       > Example
         Append three items.

             Vector.build builder->
                 builder.append 1
                 builder.append 2
                 builder.append 3
             # => [1, 2, 3]
    append : Any ! Error -> Nothing ! Error
    append self (item : Any ! Error) -> Nothing ! Error =
        Panic.rethrow_wrapped_if_error <|
            item.if_not_error <|
                self.unsafe_append item
                if self.propagate_warnings then
                    self.add_warnings item
                Nothing

    ## ICON join
       Appends a part of a given vector to this builder, propagating any errors
       that the provided elements could have contained.

       Arguments:
       - vector: The vector from which the elements are sourced.
       - start: The start index of the range to append.
       - end: The end index (the first index after the last element to be
         appended) of the range to be appended.

       ? Appending Dataflow Errors

         If a dataflow error is added to the builder, the result depends on
         whether the `Builder` is being used from `.build` or created directly
         with `new`.

         - When using `.build`: The dataflow error is re-thrown by the containing
           invocation of `Vector.build`.  The error is not added to the builder.

         - When using `Builder.new` directly : The dataflow error is wrapped in
           a `Wrapped_Dataflow_Error` and thrown as a `Panic`. The error is not
           added to the builder.

       > Example
         Append a vector.

            Vector.build builder->
                builder.append_vector_range [1, 2]
            # => [1, 2]

       > Example
         Append a part of a vector.

             Vector.build builder->
                 builder.append_vector_range [20, 30, 40, 50] 1 3
             # => [30, 40]
    append_vector_range : Vector Any ! Error -> Integer -> Integer -> Nothing ! Error
    append_vector_range self vector (start : Integer = 0) end=vector.length -> Nothing ! Error =
        subrange = vector.slice start end
        first_dataflow_error = subrange.find (x-> x.is_error) if_missing=Nothing
        Panic.rethrow_wrapped_if_error <|
            first_dataflow_error.if_not_error <|
                append_result = self.elements_java_builder.appendTo subrange
                assert (append_result.is_error.not)
                if self.propagate_warnings then
                    self.add_warnings subrange
                Nothing

    ## PRIVATE
       Save any attached warnings in self.warnings_java_builder.
    add_warnings : Any -> Nothing
    add_warnings self x -> Nothing =
        warnings = Warning.get_all x . map .value
        append_result = self.warnings_java_builder.appendTo warnings
        assert (append_result.is_error.not)
        Nothing

    ## PRIVATE
       Appends a new element into this builder.

       ? Propagating Dataflow Errors

         Since this is an imperative operation which returns Nothing, if the
         item to be appended contained a dataflow error, the operation will fail
         and unless its result is inspected, the error can very easily be
         ignored. To avoid this, prefer to use the `append` operation which will
         ensure that dataflow errors are propagated, and not added to the
         `Builder`.`

       Arguments:
       - item: The item to append to the vector builder.
    unsafe_append : Any -> Nothing
    unsafe_append self item = self.elements_java_builder.add item

    ## GROUP Selections
       ICON parse3
       Gets an element from the vector builder at a specified index (0-based).

       Arguments:
       - index: The location in the vector to get the element from. The index is
         also allowed be negative, then the elements are indexed from the back
         of the vector, i.e. -1 will correspond to the last element.
    at : Integer -> Any ! Index_Out_Of_Bounds
    at self index:Integer =
        actual_index = if index < 0 then self.length + index else index
        Panic.catch IndexOutOfBoundsException (self.elements_java_builder.get actual_index) _->
            Error.throw (Index_Out_Of_Bounds.Error index self.length)

    ## GROUP Selections
       ICON parse3
       Get the first element from the vector, or an `Index_Out_Of_Bounds` if the vector
       is empty.

       > Example
         The following code returns 1.

             [1, 2, 3, 4].first
    first : Vector ! Index_Out_Of_Bounds
    first self = self.at 0

    ## GROUP Selections
       ICON select_row
       Get the last element of the vector, or an `Index_Out_Of_Bounds` if the vector is
       empty.

       > Example
         The following code returns 4.

             [1, 2, 3, 4].last
    last : Vector ! Index_Out_Of_Bounds
    last self = self.at -1

    ## GROUP Metadata
       ICON metadata
       Gets the current length of the builder.
    length : Integer
    length self = self.elements_java_builder.getSize

    ## GROUP Logical
       ICON metadata
       Checks if this builder is empty.
    is_empty : Boolean
    is_empty self = self.elements_java_builder.isEmpty

    ## GROUP Logical
       ICON metadata
       Checks if this builder is not empty.
    not_empty : Boolean
    not_empty self = self.is_empty.not

    ## GROUP Logical
       ICON preparation
       Checks whether a predicate holds for at least one element of this builder.

       Arguments:
       - condition: A `Filter_Condition` or a function that takes a vector
         element and returns a boolean value that says whether that value
         satisfies a condition.
    @condition Filter_Condition.default_widget
    any : (Filter_Condition | (Any -> Boolean)) -> Boolean
    any self (condition : Filter_Condition | (Any -> Boolean)) =
        Array_Like_Helpers.any self condition

    ## GROUP Conversions
       ICON convert
       Clones the builder into a Vector.
    to_vector self -> Vector =
        ## This creates a fresh copy of the builders storage, so any future
           changes to the builder will not affect the returned vector.

           This also reattaches any warnings that were attached to the added
           values. It attaches them to the whole array, not the individual
           values.
        without_warnings = self.elements_java_builder.toArray
        if self.propagate_warnings.not then without_warnings else
            warnings_vector = self.warnings_java_builder.toArray
            Warning.attach_multiple warnings_vector without_warnings

## PRIVATE
   Describes an error attached to a value within a `Vector`. The `index` field
   contains the index into the `Vector` at which the error occurred.

   If a value is nested within multiple `Vector`s, its warnings are wrapped
   with `Map_Error` multiple times. The outermost `Map_Error` index indicates
   the index into the outermost `Vector`, the second `Map_Error` index the index
   into the sub-`Vector` within the outermost `Vector`, and so on.

   An error that is wrapped as a `Map_Error` can be caught as a `Map_Error`, or
   as itself. In the latter case, the `Map_Error` wrapper is stripped off.
@Builtin_Type
type Map_Error
    ## PRIVATE
       Creates a new `Map_Error` from the given index and underlying error.
    Error (index:Integer) inner_error

    ## PRIVATE
    to_display_text : Text
    to_display_text self = "Error at index " + self.index.to_text + ": " + self.inner_error.to_display_text

## PRIVATE
   Indicates that a method should not wrap thrown errors in `Map_Error`.
@Builtin_Type
type No_Wrap

## PRIVATE
Wrapped_Error.from (that : Map_Error) = Wrapped_Error.Value that that.inner_error
