## Methods for operating on `Text` in Enso.

from Standard.Base import all

import Standard.Base.Data.Text.Regex

import Standard.Base.Data.Text.Matching_Mode
import Standard.Base.Data.Text.Case
import Standard.Base.Data.Text.Location
import Standard.Base.Data.Text.Line_Ending_Style

import Standard.Base.Data.Index_Sub_Range
import Standard.Base.Data.Text.Text_Sub_Range

from Standard.Base.Error.Problem_Behavior import Report_Warning
import Standard.Base.Meta

export Standard.Base.Data.Text.Matching_Mode
export Standard.Base.Data.Text.Case
export Standard.Base.Data.Text.Location
export Standard.Base.Data.Text.Line_Ending_Style

polyglot java import com.ibm.icu.lang.UCharacter
polyglot java import com.ibm.icu.text.BreakIterator
polyglot java import java.lang.StringBuilder
polyglot java import org.enso.base.Text_Utils
polyglot java import org.enso.base.Encoding_Utils

## ALIAS Length

   Computes the number of characters in the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Getting the length of the string "건반(Korean)".

         "건반(Korean)".length
Text.length : Integer
Text.length self = Text_Utils.grapheme_length self

## Returns a new `Text` object with the characters in the reverse order of the input.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Reverse the text "Hello, world!".

         "Hello, world!".reverse
Text.reverse : Text
Text.reverse self =
    reverseStringBuilder = StringBuilder.new self.length
    iterator = BreakIterator.getCharacterInstance
    iterator.setText self

    iterate prev next = if next == -1 then reverseStringBuilder.toString else
      reverseStringBuilder.append (Text_Utils.substring self next prev)
      @Tail_Call iterate next iterator.previous
    iterate iterator.last iterator.previous

## Applies the provided `function` to each character in `self`.

   Arguments:
   - function: The operation to apply to each character in the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Print each character in the text "aaa".

         "aaa".each IO.println
Text.each : (Text -> Any) -> Nothing
Text.each self function =
    iterator = BreakIterator.getCharacterInstance
    iterator.setText self

    iterate prev nxt = if nxt == -1 then Nothing else
        function (Text_Utils.substring self prev nxt)
        @Tail_Call iterate nxt iterator.next
    iterate iterator.first iterator.next

## ALIAS Get Character

   Returns a character from the text at the specified index (0-based).

   Arguments:
     - index: The location in the text to get the character from. The
       index is also allowed be negative, then the characters are
       counted from the end of the text, i.e. -1 will correspond to the
       last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the individual characters in the text "건반(Korean)".

         "건반(Korean)".at 1 == "반"
Text.at : Integer -> Text ! Index_Out_Of_Bounds_Error
Text.at self index =
    case index < 0 of
        True ->
            length = self.length
            new_index = index + length
            if new_index < 0 then Error.throw (Index_Out_Of_Bounds_Error_Data index length) else
                self.at new_index
        False ->
            iterator = BreakIterator.getCharacterInstance
            iterator.setText self
            first = iterator.next index
            next = if first == -1 then -1 else iterator.next
            if (next == -1) then (Error.throw (Index_Out_Of_Bounds_Error_Data index self.length)) else
                Text_Utils.substring self first next

## ALIAS Get Characters

   Returns a vector containing all characters in the given text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the individual characters in the text "건반(Korean)".

         "건반(Korean)".characters
Text.characters : Vector.Vector Text
Text.characters self =
    bldr = Vector.new_builder
    self.each bldr.append
    bldr.to_vector

## ALIAS Match Text

   Matches the text in `self` against the provided regex `pattern`, returning
   the match(es) if present or `Nothing` if there are no matches.

   Arguments:
   - pattern: The pattern to match `self` against. We recommend using _raw text_
     to write your patterns.
   - mode: This argument specifies how many matches the engine will try and
     find. When mode is set to either `Regex_Mode.First` or `Regex_Mode.Full`,
     this method will return either a single `Match` or `Nothing`. If set to an
     `Integer` or `Regex_Mode.All`, this method will return either
     a `Vector Match` or `Nothing`.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - comments: Enables or disables the comments mode for the regular expression.
     In comments mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Find matches for a basic email regex in some text. NOTE: This regex is
     _not_ compliant with RFC 5322.

         example_match =
             regex = ".+@.+"
             "contact@enso.org".match regex
Text.match : Text | Engine.Pattern -> (Regex_Mode | Matching_Mode) -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Match | Vector.Vector Match | Nothing ! Regex.Compile_Error
Text.match self pattern mode=Regex_Mode.All match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    compiled_pattern = Regex.compile pattern match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
    compiled_pattern.match self mode

## ALIAS Check Matches

   Matches the text in `self` against the provided regex `pattern`, returning
   `True` if the text matches at least once, and `False` otherwise.

   Arguments:
   - pattern: The pattern to match `self` against. We recommend using _raw text_
     to write your patterns.
   - mode: This argument specifies how many matches the engine will try and
     find. When mode is set to either `Regex_Mode.First` or `Regex_Mode.Full`,
     this method will return either a single `Match` or `Nothing`. If set to an
     `Integer` or `Regex_Mode.All`, this method will return either
     a `Vector Match` or `Nothing`.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - comments: Enables or disables the comments mode for the regular expression.
     In comments mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceeded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceeded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Checks if some text matches a basic email regex. NOTE: This regex is _not_
     compliant with RFC 5322.

         example_match =
             regex = ".+@.+"
             "contact@enso.org".matches regex
Text.matches : Text | Engine.Pattern -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Boolean ! Regex.Compile_Error
Text.matches self pattern match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    compiled_pattern = Regex.compile pattern match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
    compiled_pattern.matches self

## ALIAS Find Text

   Finds all occurrences of `pattern` in the text `self`, returning the text(s)
   if present, or `Nothing` if there are no matches.

   Arguments:
   - pattern: The pattern to match `self` against. We recommend using _raw text_
     to write your patterns.
   - mode: This argument specifies how many matches the engine will try and
     find. When mode is set to either `Regex_Mode.First` or `Regex_Mode.Full`,
     this method will return either a single `Text` or `Nothing`. If set to an
     `Integer` or `Regex_Mode.All`, this method will return either
     a `Vector Text` or `Nothing`.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - comments: Enables or disables the comments mode for the regular expression.
     In comments mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceeded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceeded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Find words that contain three or less letters in text`"\w{1,3}"`

         example_find =
             text = "Now I know my ABCs"
             text.find "\w{1,3}"
Text.find : Text | Engine.Pattern -> (Regex_Mode | Matching_Mode) -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Text | Vector.Vector Text | Nothing
Text.find self pattern mode=Regex_Mode.All match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    compiled_pattern = Regex.compile pattern match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
    compiled_pattern.find self mode

## ALIAS Split Text

   Takes a delimiter and returns the vector that results from splitting `self`
   on each of its occurrences.

   Arguments:
   - delimiter: The pattern used to split the text.
   - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
     rules specified in the matcher. If a `Regex_Matcher`, the term is used as a
     regular expression and matched using the associated options.

   > Example
     Split the text on any occurrence of the separator `"::"`.

         example_split =
             text = "Namespace::package::package::Type"
             text.split "::" == ["Namespace", "package", "package", "Type"]

   > Example
     Split the text on a regex pattern.

         "abc--def==>ghi".split "[-=>]+" Regex_Matcher.Regex_Matcher_Data == ["abc", "def", "ghi"]

   > Example
     Split the text on any whitespace.

         'abc  def\tghi'.split '\\s+' Regex_Matcher.Regex_Matcher_Data == ["abc", "def", "ghi"]
Text.split : Text -> (Text_Matcher | Regex_Matcher) -> Vector.Vector Text
Text.split self delimiter="," matcher=Text_Matcher.Case_Sensitive = if delimiter.is_empty then Error.throw (Illegal_Argument_Error_Data "The delimiter cannot be empty.") else
    case Meta.type_of matcher of
        Text_Matcher.Text_Matcher ->
            delimiters = Vector.from_polyglot_array <| case matcher of
                Text_Matcher.Case_Sensitive ->
                    Text_Utils.span_of_all self delimiter
                Text_Matcher.Case_Insensitive locale ->
                    Text_Utils.span_of_all_case_insensitive self delimiter locale.java_locale
            Vector.new delimiters.length+1 i->
                start = if i == 0 then 0 else
                    delimiters.at i-1 . codeunit_end
                end = if i == delimiters.length then (Text_Utils.char_length self) else
                    delimiters.at i . codeunit_start
                Text_Utils.substring self start end
        Regex_Matcher.Regex_Matcher ->
            compiled_pattern = matcher.compile delimiter
            compiled_pattern.split self mode=Regex_Mode.All

## ALIAS Replace Text
   Replaces the first, last, or all occurrences of term with new_text in the
   input. If `term` is empty, the function returns the input unchanged.

   Arguments:
   - term: The term to find.
   - new_text: The new text to replace occurrences of `term` with.
     If `matcher` is a `Regex_Matcher`, `new_text` can include replacement
     patterns (such as `$<n>`) for a marked group.
   - mode: Specifies which instances of term the engine tries to find. When the
     mode is `First` or `Last`, this method replaces the first or last instance
     of term in the input. If set to `All`, it replaces all instances of term in
     the input.
   - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
     rules specified in the matcher. If a `Regex_Matcher`, the term is used as a
     regular expression and matched using the associated options.

   > Example
     Replace letters in the text "aaa".

         'aaa'.replace 'aa' 'b' == 'ba'

   > Example
     Replace all occurrences of letters 'l' and 'o' with '#'.

         "Hello World!".replace "[lo]" "#" matcher=Regex_Matcher == "He### W#r#d!"

   > Example
     Replace the first occurrence of letter 'l' with '#'.

         "Hello World!".replace "l" "#" mode=Matching_Mode.First == "He#lo World!"

   > Example
     Replace texts in quotes with parentheses.

          '"abc" foo "bar" baz'.replace '"(.*?)"' '($1)' matcher=Regex_Matcher == '(abc) foo (bar) baz'

   ! Matching Grapheme Clusters
     In case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in this mode, it is sometimes possible for a term to
     match only a part of some single grapheme cluster, for example in the text
     `ﬃa` the term `ia` will match just one-third of the first grapheme `ﬃ`.
     Since we do not have the resolution to distinguish such partial matches, a
     match which matched just a part of some grapheme cluster is extended and
     treated as if it matched the whole grapheme cluster. Thus the whole
     grapheme cluster may be replaced with the replacement text even if just a
     part of it was matched.

   > Example
     Extended partial matches in case-insensitive mode.

          # The ß symbol matches the letter `S` twice in case-insensitive mode, because it folds to `ss`.
         'ß'.replace 'S' 'A' matcher=(Text_Matcher Case_Insensitive) . should_equal 'AA'
         # The 'ﬃ' ligature is a single grapheme cluster, so even if just a part of it is matched, the whole grapheme is replaced.
         'aﬃb'.replace 'i' 'X' matcher=(Text_Matcher Case_Insensitive) . should_equal 'aXb'

   ! Last Match in Regex Mode
     Regex always performs the search from the front and matching the last
     occurrence means selecting the last of the matches while still generating
     matches from the beginning. This will lead to slightly different behavior
     for overlapping occurrences of a pattern in Regex mode than in exact text
     matching mode where the matches are searched for from the back.

   > Example
     Comparing Matching in Last Mode in Regex and Text mode

         "aaa".replace "aa" "c" mode=Matching_Mode.Last matcher=Text_Matcher . should_equal "ac"
         "aaa".replace "aa" "c" mode=Matching_Mode.Last matcher=Regex_Matcher . should_equal "ca"

         "aaa aaa".replace "aa" "c" matcher=Text_Matcher . should_equal "ca ca"
         "aaa aaa".replace "aa" "c" mode=Matching_Mode.First matcher=Text_Matcher . should_equal "ca aaa"
         "aaa aaa".replace "aa" "c" mode=Matching_Mode.Last matcher=Text_Matcher . should_equal "aaa ac"
         "aaa aaa".replace "aa" "c" matcher=Regex_Matcher . should_equal "ca ca"
         "aaa aaa".replace "aa" "c" mode=Matching_Mode.First matcher=Regex_Matcher . should_equal "ca aaa"
         "aaa aaa".replace "aa" "c" mode=Matching_Mode.Last matcher=Regex_Matcher . should_equal "aaa ca"
Text.replace : Text -> Text -> Matching_Mode | Regex_Mode -> (Text_Matcher | Regex_Matcher) -> Text
Text.replace self term="" new_text="" mode=Regex_Mode.All matcher=Text_Matcher.Case_Sensitive = if term.is_empty then self else
    case Meta.type_of matcher of
        Text_Matcher.Text_Matcher ->
            array_from_single_result result = case result of
                Nothing -> Array.empty
                _ -> Array.new_1 result
            spans_array = case matcher of
                Text_Matcher.Case_Sensitive -> case mode of
                    Regex_Mode.All ->
                        Text_Utils.span_of_all self term
                    Matching_Mode.First ->
                        array_from_single_result <| Text_Utils.span_of self term
                    Matching_Mode.Last ->
                        array_from_single_result <| Text_Utils.last_span_of self term
                    _ -> Error.throw (Illegal_Argument_Error_Data "Invalid mode.")
                Text_Matcher.Case_Insensitive locale -> case mode of
                    Regex_Mode.All ->
                        Text_Utils.span_of_all_case_insensitive self term locale.java_locale
                    Matching_Mode.First ->
                        array_from_single_result <|
                            Text_Utils.span_of_case_insensitive self term locale.java_locale False
                    Matching_Mode.Last ->
                        array_from_single_result <|
                            Text_Utils.span_of_case_insensitive self term locale.java_locale True
                    _ -> Error.throw (Illegal_Argument_Error_Data "Invalid mode.")
            Text_Utils.replace_spans self spans_array new_text
        Regex_Matcher.Regex_Matcher ->
            compiled_pattern = matcher.compile term
            compiled_pattern.replace self new_text mode=mode

## ALIAS Get Words

   Returns a vector containing all words in the given text.

   Arguments:
   - keep_whitespace: Whether or not the whitespace around the words should be
     preserved. If set to `True`, the whitespace will be included as a "word" in
     the output.

   ! What is a Word?
     A word is defined based on the definition of Word Boundaries in the Unicode
     Standard Annex 29, supplemented by language-specific dictionaries for
     Chinese, Japanese, Thai, and Khmer.

   > Example
     Getting the words in the sentence "I have not one, but two cats."

        "I have not one, but two cats.".words == ['I', 'have', 'not', 'one', ',', 'but', 'two', 'cats', '.']

   > Example
     Getting the words in the Thai sentence "แมวมีสี่ขา"

         "แมวมีสี่ขา".words == ['แมว', 'มี', 'สี่', 'ขา']
Text.words : Boolean -> Vector.Vector Text
Text.words self keep_whitespace=False =
    iterator = BreakIterator.getWordInstance
    iterator.setText self
    bldr = Vector.new_builder
    fst = iterator.first
    nxt = iterator.next

    build prev nxt = if nxt == -1 then Nothing else
        word = Text_Utils.substring self prev nxt
        word_not_whitespace = (Text_Utils.is_all_whitespace word).not
        if word_not_whitespace || keep_whitespace then bldr.append word

        next_nxt = iterator.next
        @Tail_Call build nxt next_nxt

    build fst nxt

    bldr.to_vector

## ALIAS Get Lines

   Splits the text into lines, based on '\n', '\r' or '\r\n' line endings.

   Empty lines are added for leading newlines. Multiple consecutive
   newlines will also yield additional empty lines. A line ending at the end of
   the line is not required, but if it is present it will not cause an empty
   line to be added at the end.

   > Example
     Split the text 'a\nb\nc' into lines.

        'a\nb\nc'.lines == ['a', 'b', 'c']

   > Example
     Split the text '\na\n\nb\n\n' into lines.

        '\na\n\nb\n\n\n'.lines == ['', 'a', '', 'b', '', '']

   > Example
     Split the text '\na\nb\n' into lines, keeping the line endings.

        '\na\nb\n'.lines keep_endings=True == ['\n', 'a\n', 'b\n']
Text.lines : Boolean -> Vector.Vector Text
Text.lines self keep_endings=False =
    Vector.from_polyglot_array (Text_Utils.split_on_lines self keep_endings)

## Checks whether `self` is equal to `that`, ignoring the case of the texts.

   Arguments:
   - that: The text to compare `self` for case-insensitive equality with.

   Two texts are considered equal ignoring case if they are of the same length
   and corresponding characters are equal ignoring case.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

   > Example
     The string 'É' (i.e. the character U+00C9, LATIN CAPITAL LETTER E WITH
     ACUTE) is equal ignore case to the string 'é' (i.e. the character U+00E9,
     LATIN SMALL LETTER E WITH ACUTE), which is canonically the same as the
     string 'e\u0301' (i.e. the letter `e` followed by U+0301, COMBINING ACUTE
     ACCENT). Therefore:

         (('É' . equals_ignore_case 'é') && ('é' . equals_ignore_case 'e\u0301')) == True
Text.equals_ignore_case : Text -> Locale -> Boolean
Text.equals_ignore_case self that locale=Locale.default =
    Text_Utils.equals_ignore_case self that locale.java_locale

## ADVANCED
   PRIVATE
   UNSTABLE
   Unifies the case of all letters in the text, generating a key which can be
   used to perform case-insensitive comparisons.
Text.to_case_insensitive_key : Locale -> Text
Text.to_case_insensitive_key self locale=Locale.default =
    Text_Utils.case_insensitive_key self locale.java_locale

## Compare two texts to discover their ordering.

   Arguments:
   - that: The text to order `self` with respect to.

   > Example
     Checking how "a" orders in relation to "b".

         "a".compare_to "b"
Text.compare_to : Text -> Ordering
Text.compare_to self that =
    comparison_result = Text_Utils.compare_normalized self that
    if comparison_result == 0 then Ordering.Equal else
        if comparison_result < 0 then Ordering.Less else
            Ordering.Greater

## Compare two texts to discover their ordering.

   Arguments:
   - that: The text to order `self` with respect to.

   > Example
     Checking how "a" orders in relation to "b".

         "a".compare_to_ignore_case "b"
Text.compare_to_ignore_case : Text -> Locale -> Ordering
Text.compare_to_ignore_case self that locale=Locale.default =
    comparison_result = Text_Utils.compare_normalized_ignoring_case self that locale.java_locale
    if comparison_result == 0 then Ordering.Equal else
        if comparison_result < 0 then Ordering.Less else
            Ordering.Greater

## ALIAS Check Emptiness

   Check if `self` is empty.

   ! What is Empty?
     Text is considered to be empty when its length is zero.

   > Example
     Check if the text "aaa" is empty.

         "aaa".is_empty
Text.is_empty : Boolean
Text.is_empty self = self == ""

## ALIAS Check Non-Emptiness

   Check if `self` is not empty.

   ! What is Not Empty?
     Text is considered to be not empty when its length is greater than zero.

   > Example
     Check if the text "aaa" is not empty.

         "aaa".not_empty
Text.not_empty : Boolean
Text.not_empty self = self.is_empty.not

## Inserts text value at the specified index.

   Arguments:
     - index: The position (0-based) in the text to inset text at.
       When the index is non-negative the text is inserted before the
       specified position.
       When the index is negative, then the characters are counted from
       the end of the text and the text is inserted after the specified
       position, i.e. -1 will insert the text after the last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
    Insert text at a specified index

         "Hello World!".insert 0 " Cruel" == " CruelHello World!"
         "Hello World!".insert 5 " Cruel" == "Hello Cruel World!"
         "Hello World!".insert -1 " Cruel" == "Hello World! Cruel"
Text.insert : Integer -> Text -> Text ! Index_Out_Of_Bounds_Error
Text.insert self index that =
    len = self.length
    idx = if index < 0 then len + index + 1 else index
    if (idx < 0) || (idx > len) then Error.throw (Index_Out_Of_Bounds_Error_Data index len) else
        if idx == 0 then that + self else
            if idx == len then self + that else
                pre = self.take (Range_Data 0 idx)
                post = self.take (Range_Data idx len)
                pre + that + post

## Returns if a character from the text at the specified index (0-based) is a
   digit (0-9).

   Arguments:
     - index: The location in the text to get the character from. The
       index is also allowed to be negative, then the characters are
       counted from the end of the text, i.e. -1 will correspond to the
       last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Check if an individual character is a digit:

         "0".is_digit == True
         "A0".is_digit == False
         "A0".is_digit 1 == True
         "건반(Korean)".is_digit 1 == False
Text.is_digit : Integer -> Boolean ! Index_Out_Of_Bounds_Error
Text.is_digit self (index=0) =
    grapheme = self.at index
    char = (Text_Utils.get_chars grapheme).at 0
    char>=48 && char<=57

## Checks if the text consists only of whitespace characters.

   > Example
     Check if a text is whitespace only.

         ' \t'.is_whitespace == True
         "0 ".is_whitespace == False
Text.is_whitespace : Boolean
Text.is_whitespace self =
    Text_Utils.is_all_whitespace self

## Returns a vector containing bytes representing the specified encoding of the
   input text.

   This is useful for low-level operations, such as binary data encoding.

   Arguments:
   - encoding: The text encoding to encode self with. Defaults to UTF-8.
   - on_problems: Specifies the behavior when a problem occurs during the
     function.
     By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.

   > Example
     Get the ASCII bytes of the text "Hello".

         "Hello".bytes (Encoding.ascii)
Text.bytes : Encoding -> Problem_Behavior -> Vector.Vector Byte
Text.bytes self encoding on_problems=Report_Warning =
    result = Encoding_Utils.get_bytes self (encoding . to_java_charset)
    vector = Vector.from_polyglot_array result.result
    if result.warnings.is_nothing then vector else
        on_problems.attach_problems_after vector [Encoding_Error_Data result.warnings]

## Takes a vector of bytes and returns Text resulting from decoding it using the
   specified encoding.

   Arguments:
   - bytes: The vector of UTF-8 bytes.
   - encoding: The text encoding to decode the bytes with. Defaults to UTF-8.
   - on_problems: Specifies the behavior when a problem occurs during the
     function.
     By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.

   > Example
     Get the ASCII bytes of the text "Hello".

         "Hello".bytes (Encoding.ascii)
Text.from_bytes : Vector.Vector Byte -> Encoding -> Text
Text.from_bytes bytes encoding on_problems=Report_Warning =
    result = Encoding_Utils.from_bytes bytes.to_array (encoding . to_java_charset)
    if result.warnings.is_nothing then result.result else
        on_problems.attach_problems_after result.result [Encoding_Error_Data result.warnings]

## Returns a vector containing bytes representing the UTF-8 encoding of the
   input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   Arguments:
   - on_problems: Specifies the behavior when a problem occurs during the
     function.
     By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.

   > Example
     Get the UTF-8 bytes of the text "Hello".

         "Hello".utf_8
Text.utf_8 : Problem_Behavior -> Vector.Vector Byte
Text.utf_8 self on_problems=Report_Warning =
    self.bytes Encoding.utf_8 on_problems

## Takes a vector of bytes and returns Text resulting from decoding it as UTF-8.

   Arguments:
   - bytes: The vector of UTF-8 bytes.
   - on_problems: Specifies the behavior when a problem occurs during the
     function.
     By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Decoding the bytes to get a text.

         Text.from_utf_8 [-32, -92, -107, -32, -91, -115, -32, -92, -73, -32, -92, -65]
Text.from_utf_8 : Vector.Vector Byte -> Problem_Behavior -> Text
Text.from_utf_8 bytes on_problems=Report_Warning =
    Text.from_bytes bytes Encoding.utf_8 on_problems

## Returns a vector containing the UTF-16 characters that encode the input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Get the character vector of the text "Hello".

         "Hello".char_vector
Text.char_vector : Vector.Vector Integer
Text.char_vector self = Vector.from_polyglot_array (Text_Utils.get_chars self)

## Takes a vector of characters and returns the text that results from it.

   Arguments:
   - chars: The vector of UTF-16 characters.

   This is useful for low-level operations, such as binary data encoding and
   decoding.
Text.from_char_vector : Vector.Vector Integer -> Text
Text.from_char_vector chars = Text_Utils.from_chars chars.to_array

## Returns a vector containing integers representing the Unicode codepoints of
   the input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Get the codepoints of the text "Hello".

         "Hello".codepoints
Text.codepoints : Vector.Vector Integer
Text.codepoints self = Vector.from_polyglot_array (Text_Utils.get_codepoints self)

## Takes an array of numbers and returns the text resulting from interpreting it
   as a sequence of Unicode codepoints.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Converting a vector of codepoints back into a text.
         Text.from_codepoints [129318, 127996, 8205, 9794, 65039]
Text.from_codepoints : Vector.Vector Integer -> Text
Text.from_codepoints codepoints = Text_Utils.from_codepoints codepoints.to_array

## ALIAS Check Prefix

   Checks whether `self` starts with `prefix`.

   Arguments:
   - prefix: The prefix to see if `self` starts with.
   - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
     rules specified in the matcher.
     If a `Regex_Matcher`, the term is used as a regular expression and matched
     using the associated options.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

     This however is not always well handled by the regex engine. The behaviour
     is as follows:

         'ś' . starts_with 's' == False
         's\u{301}' . starts_with 's' == False
         's\u{301}' . starts_with 'ś' == True
         'ś' . starts_with 's\u{301}' == True

         'ś' . starts_with 's' Regex_Matcher == True
         's\u{301}' . starts_with 's' Regex_Matcher == True
         's\u{301}' . starts_with 'ś' Regex_Matcher == True
         'ś' . starts_with 's\u{301}' Regex_Matcher == True

   > Example
     See if the text "Hello!" starts with the specified prefix.

         "Hello!".starts_with "Hello" == True
         "Hello!".starts_with "hello" == False
         "Hello!".starts_with "hello" (Text_Matcher Case_Insensitive) == True
         "Hello!".starts_with "[a-z]" Regex_Matcher == False
         "Hello!".starts_with "[A-Z]" Regex_Matcher == True
Text.starts_with : Text -> Matcher -> Boolean
Text.starts_with self prefix matcher=Text_Matcher.Case_Sensitive = case matcher of
    Text_Matcher.Case_Sensitive -> Text_Utils.starts_with self prefix
    Text_Matcher.Case_Insensitive locale ->
            self.take (Text_Sub_Range.First prefix.length) . equals_ignore_case prefix locale=locale
    Regex_Matcher.Regex_Matcher_Data _ _ _ _ _ ->
        preprocessed_pattern = "\A(?:" + prefix + ")"
        compiled_pattern = matcher.compile preprocessed_pattern
        match = compiled_pattern.match self Regex_Mode.First
        match.is_nothing.not

## ALIAS Check Suffix

   Checks whether `self` ends with `suffix`.

   Arguments:
   - suffix: The suffix to see if `self` ends with.
   - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
     rules specified in the matcher.
     If a `Regex_Matcher`, the term is used as a regular expression and matched
     using the associated options.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

   > Example
     See if the text "Hello World" ends with the specified suffix.

         "Hello World".ends_with "World" == True
         "Hello World".ends_with "world" == False
         "Hello World".ends_with "world" (Text_Matcher Case_Insensitive) == True
         "Hello World".ends_with "[A-Z][a-z]{4}" Regex_Matcher == True
Text.ends_with : Text -> Matcher -> Boolean
Text.ends_with self suffix matcher=Text_Matcher.Case_Sensitive = case matcher of
    Text_Matcher.Case_Sensitive -> Text_Utils.ends_with self suffix
    Text_Matcher.Case_Insensitive locale ->
            self.take (Text_Sub_Range.Last suffix.length) . equals_ignore_case suffix locale=locale
    Regex_Matcher.Regex_Matcher_Data _ _ _ _ _ ->
        preprocessed_pattern = "(?:" + suffix + ")\z"
        compiled_pattern = matcher.compile preprocessed_pattern
        match = compiled_pattern.match self Regex_Mode.First
        match.is_nothing.not

## ALIAS Contains

   Checks whether `self` contains `sequence` as its substring.

   Arguments:
   - term: The term to find.
   - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
     rules specified in the matcher.
     If a `Regex_Matcher`, the term is used as a regular expression and matched
     using the associated options.

   Returns: `True` if term is found within `self`. `False` otherwise.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

     This however is not always well handled by the regex engine. The behaviour
     is as follows:

         'ś' . contains 's' == False
         's\u{301}' . contains 's' == False
         's\u{301}' . contains 'ś' == True
         'ś' . contains 's\u{301}' == True

         'ś' . contains 's' Regex_Matcher == True
         's\u{301}' . contains 's' Regex_Matcher == True
         's\u{301}' . contains 'ś' Regex_Matcher == True
         'ś' . contains 's\u{301}' Regex_Matcher == True

   > Example
     See if the text "Hello" contains the text "ell".

         "Hello".contains "ell"

   > Example
     See if the text "Cześć" contains the text 's\u{301}' (which folds to 'ś').

         "Cześć".contains 's\u{301}'

   > Example
     See if the text "Hello!" contains the text 'LO', ignoring case.

         "Hello!".contains "LO" (Text_Matcher Case_Insensitive)

   > Example
     See if the text "Hello!" contains any lowercase letters, using a regex.

         "Hello!".contains "[a-z]" Regex_Matcher
Text.contains : Text -> Matcher -> Boolean
Text.contains self term="" matcher=Text_Matcher.Case_Sensitive = case matcher of
    Text_Matcher.Case_Sensitive -> Text_Utils.contains self term
    Text_Matcher.Case_Insensitive locale ->
            Text_Utils.contains_case_insensitive self term locale.java_locale
    Regex_Matcher.Regex_Matcher_Data _ _ _ _ _ ->
        compiled_pattern = matcher.compile term
        match = compiled_pattern.match self Regex_Mode.First
        match.is_nothing.not

## Text to JSON conversion.

   > Example
     Convert the text "cześć" to JSON.

         "cześć".to_json
Text.to_json : Json.String
Text.to_json self = Json.String self


## Takes an integer and returns a new text, consisting of `count` concatenated
   copies of `self`.

   Arguments:
   - count: The number of times that the text `self` should be repeated to make
     the new text.

   > Example
     Repeat the string "A" five times.

         "A" * 5 == "AAAAA"

   > Example
     Repeat the string "Hello " twice.

         "Hello " * 2 == "Hello Hello "
Text.* : Integer -> Text
Text.* self count = self.repeat count

## Takes an integer and returns a new text, consisting of `count` concatenated
   copies of `self`.

   Arguments:
   - count: The number of times that the text `self` should be repeated to make
     the new text.

   > Example
     Repeat the string "ABBA" five times.

         "ABBA".repeat 5 == "ABBAABBAABBAABBAABBA"

   > Example
     Repeat the string "Hello " twice.

         "Hello ".repeat 2 == "Hello Hello "
Text.repeat : Integer -> Text
Text.repeat self count=1 =
    ## TODO max is a workaround until Range is sorted to make 0..-1 not cause an infinite loop
       https://www.pivotaltracker.com/story/show/181435598
    0.up_to (count.max 0) . fold "" acc-> _-> acc + self

## ALIAS first, last, left, right, mid, substring
   Creates a new Text by selecting the specified range of the input.

   This can select a section of text from the beginning, end, or middle of the
   input using various criteria defined by the range parameter.

   Arguments:
   - range: The section of the self text to return.
     If a `Text_Sub_Range`, then the selection is interpreted following the rules of that type.
     If a `Range`, the selection is specified by two indices, from and to.

   Returns:
   The part of the input as specified by the range parameter.

   > Examples
     Various different ways to take part of "Hello World!"

         "Hello World!".take First == "H"
         "Hello World!".take (First 5) == "Hello"
         "Hello World!".take (First 0) == ""
         "Hello World!".take Last == "!"
         "Hello World!".take (Last 6) == "World!"
         "Hello World!".take (Before " ") == "Hello"
         "Hello World!".take (Before_Last "o") == "Hello W"
         "Hello World!".take (After " ") == "World!"
         "Hello World!".take (After_Last "o") == "rld!"
         "Hello World!".take (While c->c!=" ") == "Hello"
         "Hello World!".take (Range 3 5) == "lo"
         "Hello World!".take (Range 5 Nothing) == " World!"
         "Hello World!".take (Range 5 12) == " World!"
         "Hello World!".take (Range 6 12 2) == "Wrd"
         "Hello World!".take (Every 2 first=6) == "Wrd"
         "Hello World!".take (Every 3) == "Hl Wl"
         "Hello World!".take (By_Index 0) == "H"
         "Hello World!".take (By_Index [1, 0, 0, 6, 0]) == "eHHWH"
         "Hello World!".take (By_Index [Range 0 3, 6, Range 6 12 2]) == "HelWWrd"
         "Hello World!".take (Sample 3 seed=42) == "l d"
Text.take : (Text_Sub_Range | Index_Sub_Range | Range) -> Text ! Index_Out_Of_Bounds_Error
Text.take self range=(First 1) =
    ranges = Text_Sub_Range.find_codepoint_ranges self range
    case ranges of
        Range_Data start end _ ->
            Text_Utils.substring self start end
        Text_Sub_Range.Codepoint_Ranges_Data char_ranges _ ->
            slice_text self char_ranges

## ALIAS skip, remove
   Creates a new Text by removing the specified range of the input.

   This can select a section of text from the beginning, end, or middle of the
   input using various criteria defined by the range parameter.

   Arguments:
   - range: The section of the this text to return.
     If a `Text_Sub_Range`, then the selection is interpreted following the rules of that type.
     If a `Range`, the selection is specified by two indices, from and to.

   Returns:
   The part of the input as specified by the range parameter.

   > Examples
     Various different ways to take part of "Hello World!"

         "Hello World!".drop First == "ello World!"
         "Hello World!".drop (First 5) == " World!"
         "Hello World!".drop (First 0) == "Hello World!"
         "Hello World!".drop Last == "Hello World"
         "Hello World!".drop (Last 6) == "Hello "
         "Hello World!".drop (Before " ") == " World!"
         "Hello World!".drop (Before_Last "o") == "orld!"
         "Hello World!".drop (After " ") == "Hello "
         "Hello World!".drop (After_Last "o") == "Hello Wo"
         "Hello World!".drop (While c->c!=" ") == " World!"
         "Hello World!".drop (Range 3 5) == "Hel World!"
         "Hello World!".drop (Range 5 Nothing) == "Hello"
         "Hello World!".drop (Range 5 12) == "Hello"
         "Hello World!".drop (Range 6 12 2) == "Hello ol!"
         "Hello World!".drop (Every 2 first=6) == "Hello ol!"
         "Hello World!".drop (Every 3) == "elo ord!"
         "Hello World!".drop (By_Index 0) == "ello World!"
         "Hello World!".drop (By_Index [1, 0, 0, 6, 0]) == "llo orld!"
         "Hello World!".drop (By_Index [Range 0 3, 6, Range 6 12 2]) == "lo ol!"
         "Hello World!".drop (Sample 3 seed=42) == "HeloWorl!"
Text.drop : (Text_Sub_Range | Index_Sub_Range | Range) -> Text ! Index_Out_Of_Bounds_Error
Text.drop self range=(First 1) =
    ranges = Text_Sub_Range.find_codepoint_ranges self range
    case ranges of
        Range_Data start end _ ->
            if start == 0 then Text_Utils.drop_first self end else
                prefix = Text_Utils.substring self 0 start
                if end == (Text_Utils.char_length self) then prefix else
                    prefix + Text_Utils.drop_first self end
        Text_Sub_Range.Codepoint_Ranges_Data _ _ ->
            sorted_char_ranges_to_remove = ranges.sorted_and_distinct_ranges
            char_length = Text_Utils.char_length self
            inverted = Index_Sub_Range.invert_range_selection sorted_char_ranges_to_remove char_length needs_sorting=False
            slice_text self inverted

## ALIAS lower, upper, title, proper
   Converts each character in `self` to the specified case.

   Arguments:
   - case_option: specifies how to convert the characters.
   - locale: specifies the locale for character case mapping. Defaults to
     `Locale.default`.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   ! What is title case?
     Title case capitalizes the first letter of every word and ensures that all
     the remaining letters are in lower case. Some definitions of title case
     avoid capitalizing minor words (like the article "the" in English) but this
     implementation treats all words in the same way.

   > Example
     Converting a text to lower case in the default locale:

         "My TeXt!".to_case == "my text!"

   > Example
     Converting a text to upper case in a specified locale:

         from Standard.Base import all
         import Standard.Base.Data.Locale

         example_case_with_locale = "i".to_case Upper (Locale.new "tr") == "İ"
Text.to_case : Case -> Locale -> Text
Text.to_case self case_option=Case.Lower locale=Locale.default = case case_option of
    Case.Lower -> UCharacter.toLowerCase locale.java_locale self
    Case.Upper -> UCharacter.toUpperCase locale.java_locale self
    Case.Title -> UCharacter.toTitleCase locale.java_locale self Nothing

## Returns the input padded to the specified `length`, using the `with_pad`
   string repeated at the start or the end.

   Arguments:
   - length: The new length for the output. The result is the original string if
     the input length is more than length.
   - with_pad: The string to use to pad the input. If the last repetition
     exceeds the target length, it is truncated to the required size. If padding
     at the `End`, the beginning of the padding string is used and if padding at
     `Start`, the end of the string is used.
   - at: The location of where to pad the input.

   > Example
     Padding a text with whitespace at the end.

         "Hello World!".pad 15 == "Hello World!   "

   > Example
     Behavior of padding if the `with_pad` string has to be truncated.

         "HELLO".pad 9 "AB" == "HELLOABAB"
         "HELLO".pad 8 "AB" == "HELLOABA"
         "HELLO".pad 8 "AB" Start == "BABHELLO"

Text.pad : Integer -> Text -> (Location.Start | Location.End) -> Text
Text.pad self length=0 with_pad=' ' at=Location.End =
    with_pad_length = with_pad.length
    if with_pad_length == 0 then Error.throw (Illegal_Argument_Error_Data "`with_pad` must not be an empty string.") else
        pad_size = length - self.length
        if pad_size <= 0 then self else
            full_repetitions = pad_size.div with_pad_length
            remainder = pad_size % with_pad_length
            case at of
                Location.Start ->
                    with_pad.take (Text_Sub_Range.Last remainder) + with_pad.repeat full_repetitions + self
                Location.End ->
                    self + with_pad.repeat full_repetitions + with_pad.take (Text_Sub_Range.First remainder)

## This function removes the specified `trim_characters`, by default any
   whitespace, from the start, the end, or both ends of the input.

   Arguments:
   - trim_characters: A Text containing characters that should be removed or a
     predicate taking single character strings and specifying if they should be
     removed. By default, this should be any Unicode whitespace characters and
     all line terminator characters.
   - from: The location of where to trim the input. By default, this function
     trims both ends of the input.

   > Example
     Trimming whitespace from a string.

         " Hello! ".trim == "Hello!"
         " Hello! ".trim Start == "Hello! "
         " Hello! ".trim End == " Hello!"

   > Example
     Trimming a specific set of letters from a string.

        "ABC123".trim Start "ABC" == "123"
        "ABBA123".trim Start "ABC" == "123"
Text.trim : (Location.Start | Location.End | Location.Both) -> (Text | (Text -> Boolean)) -> Text
Text.trim self where=Location.Both what=_.is_whitespace =
    predicate = case what of
        _ : Text -> what.contains _
        _ -> what
    break_iterator = BreakIterator.getCharacterInstance
    break_iterator.setText self
    start_index = case where of
        Location.End -> 0
        _ ->
            loop current next =
                if next < 0 then current else
                    case predicate (Text_Utils.substring self current next) of
                        True ->
                            @Tail_Call loop next break_iterator.next
                        False -> current
            loop 0 break_iterator.next
    end_index = case where of
        Location.Start -> Text_Utils.char_length self
        _ ->
            loop current prev =
                if prev < 0 then current else
                    case predicate (Text_Utils.substring self prev current) of
                        True ->
                            @Tail_Call loop prev break_iterator.previous
                        False -> current
            current = break_iterator.last
            loop current break_iterator.previous
    if start_index >= end_index then "" else
        Text_Utils.substring self start_index end_index

## ALIAS find, index_of, position_of, span_of
   Find the location of the `term` in the input.
   Returns a Span representing the location at which the term was found, or
   `Nothing` if the term was not found in the input.

   Arguments:
   - term: The term to find.
   - mode: Specifies if the first or last occurrence of the term should be
     returned if there are multiple occurrences within the input. The first
     occurrence is returned by default.
   - matcher: Specifies how the term is matched against the input:
     - If a `Text_Matcher`, the text is compared using case-sensitively rules
       specified in the matcher.
     - If a `Regex_Matcher`, the `term` is used as a regular expression and
       matched using the associated options.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Finding location of a substring.

         "Hello World!".location_of "J" == Nothing
         "Hello World!".location_of "o" == Span (Range 4 5) "Hello World!"
         "Hello World!".location_of "o" mode=Matching_Mode.Last == Span (Range 7 8) "Hello World!"

   ! Match Length
     The  function returns not only the index of the match but a `Span` instance
     which contains both the start and end indices, allowing to determine the
     length of the match. This is useful not only with regex matches (where a
     regular expression can have matches of various lengths) but also for case
     insensitive matching. In case-insensitive mode, a single character can
     match multiple characters, for example `ß` will match `ss` and `SS`, and
     the ligature `ﬃ` will match `ffi` or `f` etc. Thus in case-insensitive
     mode, the length of the match can be shorter or longer than the term that
     was being matched, so it is extremely important to not rely on the length
     of the matched term when analysing the matches as they may have different
     lengths.

   > Example
     Match length differences in case-insensitive matching.

         term = "straße"
         text = "MONUMENTENSTRASSE 42"
         match = text . location_of term matcher=(Text_Matcher Case_Insensitive)
         term.length == 6
         match.length == 7

   ! Matching Grapheme Clusters
     In case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in this mode, it is sometimes possible for a term to
     match only a part of some single grapheme cluster, for example in the text
     `ﬃa` the term `ia` will match just one-third of the first grapheme `ﬃ`.
     Since we do not have the resolution to distinguish such partial matches
     (as that would require non-integer indices), so a match which matched just
     a part of some grapheme cluster is extended and treated as if it matched
     the whole grapheme cluster.

   > Example
     Extending matches to full grapheme clusters.

         ligatures = "ﬃﬄ"
         ligatures.length == 2
         term_1 = "IFF"
         match_1 = ligatures . location_of term_1 matcher=(Text_Matcher Case_Insensitive)
         term_1.length == 3
         match_1.length == 2
         term_2 = "ffiffl"
         match_2 = ligatures . location_of term_2 matcher=(Text_Matcher Case_Insensitive)
         term_2.length == 6
         match_2.length == 2
         # After being extended to full grapheme clusters, both terms "IFF" and "ffiffl" match the same span of grapheme clusters.
         match_1 == match_2

   ! Last Match in Regex Mode
     Regex always performs the search from the front and matching the last
     occurrence means selecting the last of the matches while still generating
     matches from the beginning. This will lead to slightly different behavior
     for overlapping occurrences of a pattern in Regex mode than in exact text
     matching mode where the matches are searched for from the back.

   > Example
     Comparing Matching in Last Mode in Regex and Text mode

         "aaa".location_of "aa" mode=Matching_Mode.Last matcher=Text_Matcher == Span (Range 1 3) "aaa"
         "aaa".location_of "aa" mode=Matching_Mode.Last matcher=Regex_Matcher == Span (Range 0 2) "aaa"

         "aaa aaa".location_of "aa" mode=Matching_Mode.Last matcher=Text_Matcher == Span (Range 5 7) "aaa aaa"
         "aaa aaa".location_of "aa" mode=Matching_Mode.Last matcher=Regex_Matcher == Span (Range 4 6) "aaa aaa"
Text.location_of : Text -> (Matching_Mode.First | Matching_Mode.Last) -> Matcher -> Span | Nothing
Text.location_of self term="" mode=Matching_Mode.First matcher=Text_Matcher.Case_Sensitive = case matcher of
    Text_Matcher.Case_Sensitive ->
        codepoint_span = case mode of
            Matching_Mode.First -> Text_Utils.span_of self term
            Matching_Mode.Last -> Text_Utils.last_span_of self term
        if codepoint_span.is_nothing then Nothing else
            start = Text_Utils.utf16_index_to_grapheme_index self codepoint_span.codeunit_start
            ## While the codepoint_span may have different code unit length
               from our term, the `length` counted in grapheme clusters is
               guaranteed to be the same.
            end = start + term.length
            Span_Data (Range_Data start end) self
    Text_Matcher.Case_Insensitive locale -> case term.is_empty of
        True -> case mode of
            Matching_Mode.First -> Span_Data (Range_Data 0 0) self
            Matching_Mode.Last ->
                end = self.length
                Span_Data (Range_Data end end) self
        False ->
            search_for_last = case mode of
                Matching_Mode.First -> False
                Matching_Mode.Last -> True
            case Text_Utils.span_of_case_insensitive self term locale.java_locale search_for_last of
                Nothing -> Nothing
                grapheme_span ->
                    Span_Data (Range_Data grapheme_span.grapheme_start grapheme_span.grapheme_end) self
    _ -> case mode of
        Matching_Mode.First ->
            case matcher.compile term . match self Matching_Mode.First of
                Nothing -> Nothing
                match -> match.span 0 . to_grapheme_span
        Matching_Mode.Last ->
            case matcher.compile term . match self Regex_Mode.All of
                Nothing -> Nothing
                matches -> matches.last.span 0 . to_grapheme_span

## ALIAS find_all, index_of_all, position_of_all, span_of_all
   Finds all the locations of the `term` in the input.
   If not found, the function returns an empty Vector.

   Arguments:
   - term: The term to find.
   - matcher: Specifies how the term is matched against the input:
     - If a `Text_Matcher`, the text is compared using case-sensitively rules
       specified in the matcher.
     - If a `Regex_Matcher`, the `term` is used as a regular expression and
       matched using the associated options.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Finding locations of all occurrences of a substring.

         "Hello World!".location_of_all "J" == []
         "Hello World!".location_of_all "o" . map .start == [4, 7]

   ! Match Length
     The  function returns not only the index of the match but a `Span` instance
     which contains both the start and end indices, allowing to determine the
     length of the match. This is useful not only with regex matches (where a
     regular expression can have matches of various lengths) but also for case
     insensitive matching. In case-insensitive mode, a single character can
     match multiple characters, for example `ß` will match `ss` and `SS`, and
     the ligature `ﬃ` will match `ffi` or `f` etc. Thus in case-insensitive
     mode, the length of the match can be shorter or longer than the term that
     was being matched, so it is extremely important to not rely on the length
     of the matched term when analysing the matches as they may have different
     lengths.

   > Example
     Match length differences in case-insensitive matching.

         term = "strasse"
         text = "MONUMENTENSTRASSE ist eine große Straße."
         match = text . location_of_all term matcher=(Text_Matcher Case_Insensitive)
         term.length == 7
         match . map .length == [7, 6]

   ! Matching Grapheme Clusters
     In case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in this mode, it is sometimes possible for a term to
     match only a part of some single grapheme cluster, for example in the text
     `ﬃa` the term `ia` will match just one-third of the first grapheme `ﬃ`.
     Since we do not have the resolution to distinguish such partial matches
     (as that would require non-integer indices), so a match which matched just
     a part of some grapheme cluster is extended and treated as if it matched
     the whole grapheme cluster.

   > Example
     Extending matches to full grapheme clusters.

         ligatures = "ﬃﬄFFIFF"
         ligatures.length == 7
         match_1 = ligatures . location_of_all "IFF" matcher=(Text_Matcher Case_Insensitive)
         match_1 . map .length == [2, 3]
         match_2 = ligatures . location_of_all "ffiff" matcher=(Text_Matcher Case_Insensitive)
         match_2 . map .length == [2, 5]
Text.location_of_all : Text -> Matcher -> [Span]
Text.location_of_all self term="" matcher=Text_Matcher.Case_Sensitive = if term.is_empty then Vector.new (self.length + 1) (ix -> Span_Data (Range_Data ix ix) self) else case matcher of
    Text_Matcher.Case_Sensitive ->
        codepoint_spans = Vector.from_polyglot_array <| Text_Utils.span_of_all self term
        grahpeme_ixes = Vector.from_polyglot_array <| Text_Utils.utf16_indices_to_grapheme_indices self (codepoint_spans.map .codeunit_start).to_array
        ## While the codepoint_spans may have different code unit lengths
           from our term, the `length` counted in grapheme clusters is
           guaranteed to be the same.
        offset = term.length
        grahpeme_ixes . map start->
            end = start+offset
            Span_Data (Range_Data start end) self
    Text_Matcher.Case_Insensitive locale ->
        grapheme_spans = Vector.from_polyglot_array <| Text_Utils.span_of_all_case_insensitive self term locale.java_locale
        grapheme_spans.map grapheme_span->
            Span_Data (Range_Data grapheme_span.grapheme_start grapheme_span.grapheme_end) self
    Regex_Matcher.Regex_Matcher_Data _ _ _ _ _ ->
        case matcher.compile term . match self Regex_Mode.All of
            Nothing -> []
            matches -> matches.map m-> m.span 0 . to_grapheme_span

## PRIVATE
   Returns a new Text constructed by slicing the input according to the provided
   ranges. The ranges are assumed to have step equal to 1 and bounds within the
   input's range.

   The input ranges are in UTF-16 code unit space.
slice_text text char_ranges =
    sb = StringBuilder.new
    char_ranges.map char_range->
       sb.append text char_range.start char_range.end
    sb.toString
