## Methods for operating on `Text` in Enso.

import project.Any.Any
import project.Data.Array.Array
import project.Data.Index_Sub_Range.Index_Sub_Range
import project.Data.Locale.Locale
import project.Data.Numbers.Integer
import project.Data.Range.Extensions
import project.Data.Range.Range
import project.Data.Text.Case.Case
import project.Data.Text.Case_Sensitivity.Case_Sensitivity
import project.Data.Text.Encoding.Encoding
import project.Data.Text.Location.Location
import project.Data.Text.Matching_Mode.Matching_Mode
import project.Data.Text.Regex
import project.Data.Text.Regex.Match.Match
import project.Data.Text.Regex.Regex_Syntax_Error
import project.Data.Text.Span.Span
import project.Data.Text.Span.Utf_16_Span
import project.Data.Text.Text
import project.Data.Text.Text_Sub_Range.Codepoint_Ranges
import project.Data.Text.Text_Sub_Range.Text_Sub_Range
import project.Data.Vector.Vector
import project.Errors.Common.Index_Out_Of_Bounds
import project.Error.Error
import project.Errors.Encoding_Error.Encoding_Error
import project.Errors.Illegal_Argument.Illegal_Argument
import project.Errors.Problem_Behavior.Problem_Behavior
import project.Meta
import project.Nothing.Nothing

from project.Data.Boolean import Boolean, True, False
from project.Data.Text.Text_Sub_Range import Codepoint_Ranges, Text_Sub_Range

import project.Data.Index_Sub_Range as Index_Sub_Range_Module

polyglot java import com.ibm.icu.lang.UCharacter
polyglot java import com.ibm.icu.text.BreakIterator
polyglot java import java.lang.StringBuilder
polyglot java import org.enso.base.Text_Utils
polyglot java import org.enso.base.Encoding_Utils
polyglot java import org.enso.base.Regex_Utils

## Returns a new `Text` object with the characters in the reverse order of the input.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Reverse the text "Hello, world!".

         "Hello, world!".reverse
Text.reverse : Text
Text.reverse self =
    reverseStringBuilder = StringBuilder.new self.length
    iterator = BreakIterator.getCharacterInstance
    iterator.setText self

    iterate prev next = if next == -1 then reverseStringBuilder.toString else
      reverseStringBuilder.append (Text_Utils.substring self next prev)
      @Tail_Call iterate next iterator.previous
    iterate iterator.last iterator.previous

## Applies the provided `function` to each character in `self`.

   Arguments:
   - function: The operation to apply to each character in the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Print each character in the text "aaa".

         "aaa".each IO.println
Text.each : (Text -> Any) -> Nothing
Text.each self function =
    iterator = BreakIterator.getCharacterInstance
    iterator.setText self

    iterate prev nxt = if nxt == -1 then Nothing else
        function (Text_Utils.substring self prev nxt)
        @Tail_Call iterate nxt iterator.next
    iterate iterator.first iterator.next

## ALIAS Get Character

   Returns a character from the text at the specified index (0-based).

   Arguments:
     - index: The location in the text to get the character from. The
       index is also allowed be negative, then the characters are
       counted from the end of the text, i.e. -1 will correspond to the
       last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the individual characters in the text "건반(Korean)".

         "건반(Korean)".at 1 == "반"
Text.at : Integer -> Text ! Index_Out_Of_Bounds
Text.at self index =
    self.get index (Error.throw (Index_Out_Of_Bounds.Error index self.length))

## ALIAS Get Character

   Returns a character from the text at the specified index (0-based).
   If the index is invalid then `if_missing` is returned.

   Arguments:
     - index: The location in the text to get the character from. The
       index is also allowed be negative, then the characters are
       counted from the end of the text, i.e. -1 will correspond to the
       last character.
     - if_missing: The value to return if the index is out of bounds.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the individual characters in the text "건반(Korean)".

         "건반(Korean)".get 1 == "반"
Text.get : Integer -> Any -> Any
Text.get self index ~if_missing=Nothing =
    case index < 0 of
        True ->
            length = self.length
            new_index = index + length
            if new_index < 0 then if_missing else
                self.at new_index
        False ->
            iterator = BreakIterator.getCharacterInstance
            iterator.setText self
            first = iterator.next index
            next = if first == -1 then -1 else iterator.next
            if (next == -1) then if_missing else
                Text_Utils.substring self first next

## Returns the first character from the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the first character in the text "건반(Korean)".

         "건반(Korean)".first == "건"
Text.first : Text ! Index_Out_Of_Bounds
Text.first self = self.at 0

## Returns the second character from the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the second character in the text "건반(Korean)".

         "건반(Korean)".second == "반"
Text.second : Text ! Index_Out_Of_Bounds
Text.second self = self.at 1

## Returns the last character from the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the last character in the text "건반(Korean)".

         "건반(Korean)".last == ")"
Text.last : Text ! Index_Out_Of_Bounds
Text.last self = self.at -1

## ALIAS Get Characters

   Returns a vector containing all characters in the given text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the individual characters in the text "건반(Korean)".

         "건반(Korean)".characters
Text.characters : Vector Text
Text.characters self =
    bldr = Vector.new_builder
    self.each bldr.append
    bldr.to_vector

## Find the regular expression `pattern` in `self`, returning the first match
   if present or `Nothing` if not found.

   Arguments:
   - pattern: The pattern to match `self` against.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   If an empty regex is used, `find` throws an Illegal_Argument error.

   If a non-default locale is used, `find` throws an Illegal_Argument error.

   > Example
     Find the first substring matching the regex.

         example_find =
             ## This matches `abc` @ character 11
             "aabbbbccccaabcaaaa".find "a[ab]c"
         example_find_insensitive =
             ## This matches `aBc` @ character 11
             "aabbbbccccaaBcaaaa".find "a[ab]c" Case_Sensitivity.Insensitive
Text.find : Text -> Case_Sensitivity -> Match | Nothing ! Regex_Syntax_Error | Illegal_Argument
Text.find self pattern=".*" case_sensitivity=Case_Sensitivity.Sensitive =
    case_insensitive = case_sensitivity.is_case_insensitive_in_memory
    compiled_pattern = Regex.compile pattern case_insensitive=case_insensitive
    compiled_pattern.match self

## Finds all the matches of the regular expression `pattern` in `self`,
   returning a Vector. If not found, will be an empty Vector.

   Arguments:
   - pattern: The pattern to match `self` against.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   If an empty regex is used, `find_all` throws an Illegal_Argument error.

   If a non-default locale is used, `find_all` throws an Illegal_Argument error.

   > Example
     Find the substring matching the regex.

         example_find_all =
              ## This matches `aabbbbc` @ character 0 and `abc` @ character 11
             "aabbbbccccaabcaaaa".find_all "a[ab]+c"
         example_find_all_insensitive =
              ## This matches `aABbbbc` @ character 0 and `aBC` @ character 11
             "aABbbbccccaaBCaaaa".find_all "a[ab]+c" Case_Sensitivity.Insensitive
Text.find_all : Text -> Case_Sensitivity -> Vector Match ! Regex_Syntax_Error | Illegal_Argument
Text.find_all self pattern=".*" case_sensitivity=Case_Sensitivity.Sensitive =
    case_insensitive = case_sensitivity.is_case_insensitive_in_memory
    compiled_pattern = Regex.compile pattern case_insensitive=case_insensitive
    compiled_pattern.match_all self

## ALIAS Check Matches

   Checks if the whole text in `self` matches a provided `pattern`.

   Arguments:
   - pattern: The pattern to match `self` against.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   If an empty regex is used, `match` throws an Illegal_Argument error.

   If a non-default locale is used, `match` throws an Illegal_Argument error.

   > Example
     Checks if whole text matches a basic email regex.

         example_match =
             regex = ".+ct@.+"
             # Evaluates to true
             "contact@enso.org".match regex
         example_match_insensitive =
             regex = ".+ct@.+"
             # Evaluates to true
             "CONTACT@enso.org".match regex Case_Sensitivity.Insensitive
Text.match : Text -> Case_Sensitivity -> Boolean ! Regex_Syntax_Error | Illegal_Argument
Text.match self pattern=".*" case_sensitivity=Case_Sensitivity.Sensitive =
    case_insensitive = case_sensitivity.is_case_insensitive_in_memory
    compiled_pattern = Regex.compile pattern case_insensitive=case_insensitive
    compiled_pattern.matches self

## ALIAS Split Text

   Takes a delimiter and returns the vector that results from splitting `self`
   on each of its occurrences.

   Arguments:
   - delimiter: The pattern used to split the text.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively. The values are compared case sensitively by default.
   - use_regex: If true, the term is used as a regular expression.

   > Example
     Split the text on any occurrence of the separator `"::"`.

         text = "Namespace::package::package::Type"
         text.split "::" == ["Namespace", "package", "package", "Type"]

   > Example
     Split the text on a regex pattern.

         "abc--def==>ghi".split "[-=>]+" use_regex=True == ["abc", "def", "ghi"]

   > Example
     Split the text on any whitespace.

         'abc  def\tghi'.split '\\s+' use_regex=True == ["abc", "def", "ghi"]

   > Example
     Split with a vector of strings.

         'azbzczdzezfzg'.split ['b', 'zez'] == ['az', 'zczd', 'fzg']
Text.split : Text | Vector Text  -> Case_Sensitivity -> Boolean -> Vector Text | Illegal_Argument
Text.split self delimiter="," case_sensitivity=Case_Sensitivity.Sensitive use_regex=False =
    delimiter_is_empty = case delimiter of
        _ : Text -> delimiter.is_empty
        _ : Vector -> delimiter.is_empty || delimiter.any (.is_empty)
        _ -> Error.throw (Illegal_Argument.Error "The delimiter must be a Text or Vector of Texts.")
    if delimiter_is_empty then Error.throw (Illegal_Argument.Error "The delimiter cannot be empty.") else
        delimiter_is_singleton_vector = case delimiter of
            _ : Vector -> delimiter.length == 1
            _ -> False
        # If it's a vector of one element, just call it on that one element.
        if delimiter_is_singleton_vector then self.split delimiter=(delimiter.first) case_sensitivity=case_sensitivity use_regex=use_regex else
            case use_regex of
                False ->
                    delimiters = split_find_delimiters self delimiter case_sensitivity
                    Vector.new delimiters.length+1 i->
                        start = if i == 0 then 0 else
                            delimiters.at i-1 . codeunit_end
                        end = if i == delimiters.length then (Text_Utils.char_length self) else
                            delimiters.at i . codeunit_start
                        Text_Utils.substring self start end
                True -> case delimiter of
                    _ : Text ->
                        case_insensitive = case_sensitivity.is_case_insensitive_in_memory
                        compiled_pattern = Regex.compile delimiter case_insensitive=case_insensitive
                        compiled_pattern.split self
                    _ : Vector ->
                        parenthesize s = "(?:" + s + ")"
                        combined_delimiter = parenthesize (delimiter.map parenthesize . join '|')
                        self.split combined_delimiter case_sensitivity=case_sensitivity use_regex=True

## ADVANCED
   Takes an input string and and a pattern and returns all the matches as a
   `Vector Text`. If the pattern contains marked groups, the values are
   concatenated together; otherwise the whole match is returned.

   Arguments:
   - input: The text to tokenize.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively. The values are compared case sensitively by default.

   > Example
     Split to blocks of 3 characters.

        "ABCDEF" . tokenize  "..." == ["ABC","DEF"]

   > Example
     Split to blocks of 3 characters taking first and third letters.

        "ABCDEF" . tokenize "(.).(.)" == ["AC","DF"]

   > Example
     Split a text on any white space.

        'Hello Big\r\nWide\tWorld\nGoodbye!' . tokenize "(\S+)(?:\s+|$)"
            == ["Hello","Big","Wide","World","Goodbye!"]
Text.tokenize : Text -> Case_Sensitivity -> Vector Text
Text.tokenize self pattern="." case_sensitivity=Case_Sensitivity.Sensitive =
    case_insensitive = case_sensitivity.is_case_insensitive_in_memory
    compiled_pattern = Regex.compile pattern case_insensitive=case_insensitive
    compiled_pattern.tokenize self

## ALIAS Replace Text
   Perform a text or regex replace.

   Returns the text with all matched elements replaced by the provided
   replacement. If `input` is empty, the function returns the input unchanged.

   The replacement string can contain references to groups matched by the
   regex. The following syntaxes are supported:
       $0: the entire match string
       $&: the entire match string
       $n: the nth group
       $<foo>: Named group `foo`

   Arguments:
   - term: The string or regex to find.
   - replacement: The text to replace matches with.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.
   - only_first: If True, only replace the first match.
   - use_regex: If true, the term is used as a regular expression.

   If an empty regex is used, `replace` throws an Illegal_Argument error.

   If a non-default locale is used with a regex, `replace` throws an
   Illegal_Argument error.

   > Example
     Replace letters in the text "aaa".

         'aaa'.replace 'aa' 'b' == 'ba'

   > Example
     Replace all occurrences of letters 'l' and 'o' with '#'.

         "Hello World!".replace "[lo]" "#" use_regex=True == "He### W#r#d!"

   > Example
     Replace the first occurrence of letter 'l' with '#'.

         "Hello World!".replace "l" "#" only_first=True == "He#lo World!"

   > Example
     Replace texts in quotes with parentheses.

          '"abc" foo "bar" baz'.replace '"(.*?)"' '($1)' use_regex=True == '(abc) foo (bar) baz'

   ! Matching Grapheme Clusters
     In case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in this mode, it is sometimes possible for a term to
     match only a part of some single grapheme cluster, for example in the text
     `ﬃa` the term `ia` will match just one-third of the first grapheme `ﬃ`.
     Since we do not have the resolution to distinguish such partial matches, a
     match which matched just a part of some grapheme cluster is extended and
     treated as if it matched the whole grapheme cluster. Thus the whole
     grapheme cluster may be replaced with the replacement text even if just a
     part of it was matched.

   > Example
     Extended partial matches in case-insensitive mode.

         # The ß symbol matches the letter `S` twice in case-insensitive mode, because it folds to `ss`.
         'ß'.replace 'S' 'A' case_sensitivity=Case_Sensitivity.Insensitive . should_equal 'AA'
         # The 'ﬃ' ligature is a single grapheme cluster, so even if just a part of it is matched, the whole grapheme is replaced.
         'aﬃb'.replace 'i' 'X' case_sensitivity=Case_Sensitivity.Insensitive . should_equal 'aXb'

   > Example
     Regexp replace.

     '<a href="url">content</a>'.replace '<a href="(.*?)">(.*?)</a>' '$2 is at $1' use_regex=True == 'content is at url'

Text.replace : Text -> Text -> Case_Sensitivity -> Boolean -> Boolean -> Text ! Illegal_Argument
Text.replace self term replacement case_sensitivity=Case_Sensitivity.Sensitive only_first=False use_regex=False =
    case use_regex of
        False -> if term.is_empty then self else
            array_from_single_result result = case result of
                Nothing -> Array.empty
                _ -> Array.new_1 result
            spans_array = case case_sensitivity of
                Case_Sensitivity.Sensitive -> case only_first of
                    False -> Text_Utils.span_of_all self term
                    True -> array_from_single_result <| Text_Utils.span_of self term
                Case_Sensitivity.Insensitive locale -> case only_first of
                    False ->
                        Text_Utils.span_of_all_case_insensitive self term locale.java_locale
                    True ->
                        array_from_single_result <|
                            Text_Utils.span_of_case_insensitive self term locale.java_locale False
            Text_Utils.replace_spans self spans_array replacement
        True ->
            case_insensitive = case_sensitivity.is_case_insensitive_in_memory
            compiled_pattern = Regex.compile term case_insensitive=case_insensitive
            compiled_pattern.replace self replacement only_first

## ALIAS Get Words

   Returns a vector containing all words in the given text.

   Arguments:
   - keep_whitespace: Whether or not the whitespace around the words should be
     preserved. If set to `True`, the whitespace will be included as a "word" in
     the output.

   ! What is a Word?
     A word is defined based on the definition of Word Boundaries in the Unicode
     Standard Annex 29, supplemented by language-specific dictionaries for
     Chinese, Japanese, Thai, and Khmer.

   > Example
     Getting the words in the sentence "I have not one, but two cats."

        "I have not one, but two cats.".words == ['I', 'have', 'not', 'one', ',', 'but', 'two', 'cats', '.']

   > Example
     Getting the words in the Thai sentence "แมวมีสี่ขา"

         "แมวมีสี่ขา".words == ['แมว', 'มี', 'สี่', 'ขา']
Text.words : Boolean -> Vector Text
Text.words self keep_whitespace=False =
    iterator = BreakIterator.getWordInstance
    iterator.setText self
    bldr = Vector.new_builder
    fst = iterator.first
    nxt = iterator.next

    build prev nxt = if nxt == -1 then Nothing else
        word = Text_Utils.substring self prev nxt
        word_not_whitespace = (Text_Utils.is_all_whitespace word).not
        if word_not_whitespace || keep_whitespace then bldr.append word

        next_nxt = iterator.next
        @Tail_Call build nxt next_nxt

    build fst nxt

    bldr.to_vector

## ALIAS Get Lines

   Splits the text into lines, based on '\n', '\r' or '\r\n' line endings.

   Empty lines are added for leading newlines. Multiple consecutive
   newlines will also yield additional empty lines. A line ending at the end of
   the line is not required, but if it is present it will not cause an empty
   line to be added at the end.

   > Example
     Split the text 'a\nb\nc' into lines.

        'a\nb\nc'.lines == ['a', 'b', 'c']

   > Example
     Split the text '\na\n\nb\n\n' into lines.

        '\na\n\nb\n\n\n'.lines == ['', 'a', '', 'b', '', '']

   > Example
     Split the text '\na\nb\n' into lines, keeping the line endings.

        '\na\nb\n'.lines keep_endings=True == ['\n', 'a\n', 'b\n']
Text.lines : Boolean -> Vector Text
Text.lines self keep_endings=False =
    Vector.from_polyglot_array (Text_Utils.split_on_lines self keep_endings)

## Inserts text value at the specified index.

   Arguments:
     - index: The position (0-based) in the text to inset text at.
       When the index is non-negative the text is inserted before the
       specified position.
       When the index is negative, then the characters are counted from
       the end of the text and the text is inserted after the specified
       position, i.e. -1 will insert the text after the last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
    Insert text at a specified index

         "Hello World!".insert 0 " Cruel" == " CruelHello World!"
         "Hello World!".insert 5 " Cruel" == "Hello Cruel World!"
         "Hello World!".insert -1 " Cruel" == "Hello World! Cruel"
Text.insert : Integer -> Text -> Text ! Index_Out_Of_Bounds
Text.insert self index that =
    len = self.length
    idx = if index < 0 then len + index + 1 else index
    if (idx < 0) || (idx > len) then Error.throw (Index_Out_Of_Bounds.Error index len) else
        if idx == 0 then that + self else
            if idx == len then self + that else
                pre = self.take (0.up_to idx)
                post = self.take (idx.up_to len)
                pre + that + post

## Returns if a character from the text at the specified index (0-based) is a
   digit (0-9).

   Arguments:
     - index: The location in the text to get the character from. The
       index is also allowed to be negative, then the characters are
       counted from the end of the text, i.e. -1 will correspond to the
       last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Check if an individual character is a digit:

         "0".is_digit == True
         "A0".is_digit == False
         "A0".is_digit 1 == True
         "건반(Korean)".is_digit 1 == False
Text.is_digit : Integer -> Boolean ! Index_Out_Of_Bounds
Text.is_digit self (index=0) =
    grapheme = self.at index
    char = (Text_Utils.get_chars grapheme).at 0
    char>=48 && char<=57

## Checks if the text consists only of whitespace characters.

   > Example
     Check if a text is whitespace only.

         ' \t'.is_whitespace == True
         "0 ".is_whitespace == False
Text.is_whitespace : Boolean
Text.is_whitespace self =
    Text_Utils.is_all_whitespace self

## Returns a vector containing bytes representing the specified encoding of the
   input text.

   This is useful for low-level operations, such as binary data encoding.

   Arguments:
   - encoding: The text encoding to encode self with. Defaults to UTF-8.
   - on_problems: Specifies the behavior when a problem occurs during the
     function.
     By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.

   > Example
     Get the ASCII bytes of the text "Hello".

         "Hello".bytes (Encoding.ascii)
Text.bytes : Encoding -> Problem_Behavior -> Vector Integer
Text.bytes self encoding on_problems=Problem_Behavior.Report_Warning =
    result = Encoding_Utils.get_bytes self (encoding . to_java_charset)
    vector = Vector.from_polyglot_array result.result
    if result.warnings.is_nothing then vector else
        on_problems.attach_problems_after vector [Encoding_Error.Error result.warnings]

## Takes a vector of bytes and returns Text resulting from decoding it using the
   specified encoding.

   Arguments:
   - bytes: The vector of UTF-8 bytes.
   - encoding: The text encoding to decode the bytes with. Defaults to UTF-8.
   - on_problems: Specifies the behavior when a problem occurs during the
     function. By default, a dataflow error is raised.

   > Example
     Get the ASCII bytes of the text "Hello".

         "Hello".bytes (Encoding.ascii)
Text.from_bytes : Vector Integer -> Encoding -> Problem_Behavior -> Text
Text.from_bytes bytes encoding on_problems=Problem_Behavior.Report_Error =
    result = Encoding_Utils.from_bytes bytes.to_array (encoding . to_java_charset)
    if result.warnings.is_nothing then result.result else
        on_problems.attach_problems_after result.result [Encoding_Error.Error result.warnings]

## Returns a vector containing bytes representing the UTF-8 encoding of the
   input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   Arguments:
   - on_problems: Specifies the behavior when a problem occurs during the
     function.
     By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.

   > Example
     Get the UTF-8 bytes of the text "Hello".

         "Hello".utf_8
Text.utf_8 : Problem_Behavior -> Vector Integer
Text.utf_8 self on_problems=Problem_Behavior.Report_Warning =
    self.bytes Encoding.utf_8 on_problems

## Takes a vector of bytes and returns Text resulting from decoding it as UTF-8.

   Arguments:
   - bytes: The vector of UTF-8 bytes.
   - on_problems: Specifies the behavior when a problem occurs during the
     function. By default, a dataflow error is raised.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Decoding the bytes to get a text.

         Text.from_utf_8 [-32, -92, -107, -32, -91, -115, -32, -92, -73, -32, -92, -65]
Text.from_utf_8 : Vector Integer -> Problem_Behavior -> Text
Text.from_utf_8 bytes on_problems=Problem_Behavior.Report_Error =
    Text.from_bytes bytes Encoding.utf_8 on_problems

## Returns a vector containing the UTF-16 characters that encode the input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Get the character vector of the text "Hello".

         "Hello".char_vector
Text.char_vector : Vector Integer
Text.char_vector self = Vector.from_polyglot_array (Text_Utils.get_chars self)

## Takes a vector of characters and returns the text that results from it.

   Arguments:
   - chars: The vector of UTF-16 characters.

   This is useful for low-level operations, such as binary data encoding and
   decoding.
Text.from_char_vector : Vector Integer -> Text
Text.from_char_vector chars = Text_Utils.from_chars chars.to_array

## Returns a vector containing integers representing the Unicode codepoints of
   the input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Get the codepoints of the text "Hello".

         "Hello".codepoints
Text.codepoints : Vector Integer
Text.codepoints self = Vector.from_polyglot_array (Text_Utils.get_codepoints self)

## Takes an array of numbers and returns the text resulting from interpreting it
   as a sequence of Unicode codepoints.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Converting a vector of codepoints back into a text.
         Text.from_codepoints [129318, 127996, 8205, 9794, 65039]
Text.from_codepoints : Vector Integer -> Text
Text.from_codepoints codepoints = Text_Utils.from_codepoints codepoints.to_array

## ALIAS Check Prefix

   Checks whether `self` starts with `prefix`.

   Arguments:
   - prefix: The prefix to see if `self` starts with.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

         'ś' . starts_with 's' == False
         's\u{301}' . starts_with 's' == False
         's\u{301}' . starts_with 'ś' == True
         'ś' . starts_with 's\u{301}' == True

   > Example
     See if the text "Hello!" starts with the specified prefix.

         "Hello!".starts_with "Hello" == True
         "Hello!".starts_with "hello" == False
         "Hello!".starts_with "hello" Case_Sensitivity.Insensitive == True
Text.starts_with : Text -> Case_Sensitivity -> Boolean
Text.starts_with self prefix case_sensitivity=Case_Sensitivity.Sensitive = case case_sensitivity of
    Case_Sensitivity.Default -> self.starts_with prefix Case_Sensitivity.Sensitive
    Case_Sensitivity.Sensitive -> Text_Utils.starts_with self prefix
    Case_Sensitivity.Insensitive locale ->
        self.take (Index_Sub_Range.First prefix.length) . equals_ignore_case prefix locale=locale

## ALIAS Check Suffix

   Checks whether `self` ends with `suffix`.

   Arguments:
   - suffix: The suffix to see if `self` ends with.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

   > Example
     See if the text "Hello World" ends with the specified suffix.

         "Hello World".ends_with "World" == True
         "Hello World".ends_with "world" == False
         "Hello World".ends_with "world" Case_Sensitivity.Insensitive == True
Text.ends_with : Text -> Case_Sensitivity -> Boolean
Text.ends_with self suffix case_sensitivity=Case_Sensitivity.Sensitive = case case_sensitivity of
    Case_Sensitivity.Default -> self.ends_with suffix Case_Sensitivity.Sensitive
    Case_Sensitivity.Sensitive -> Text_Utils.ends_with self suffix
    Case_Sensitivity.Insensitive locale ->
        self.take (Index_Sub_Range.Last suffix.length) . equals_ignore_case suffix locale=locale

## ALIAS Contains

   Checks whether `self` contains `sequence` as its substring.
   Returns: `True` if term is found within `self`. `False` otherwise.

   Arguments:
   - term: The term to find.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

         'ś' . contains 's' == False
         's\u{301}' . contains 's' == False
         's\u{301}' . contains 'ś' == True
         'ś' . contains 's\u{301}' == True

   > Example
     See if the text "Hello" contains the text "ell".

         "Hello".contains "ell"

   > Example
     See if the text "Cześć" contains the text 's\u{301}' (which folds to 'ś').

         "Cześć".contains 's\u{301}'

   > Example
     See if the text "Hello!" contains the text 'LO', ignoring case.

         "Hello!".contains "LO" Case_Sensitivity.Insensitive
Text.contains : Text -> Case_Sensitivity -> Boolean
Text.contains self term="" case_sensitivity=Case_Sensitivity.Sensitive = case case_sensitivity of
    Case_Sensitivity.Default -> self.contains term Case_Sensitivity.Sensitive
    Case_Sensitivity.Sensitive -> Text_Utils.contains self term
    Case_Sensitivity.Insensitive locale ->
        Text_Utils.contains_case_insensitive self term locale.java_locale

## Takes an integer and returns a new text, consisting of `count` concatenated
   copies of `self`.

   Arguments:
   - count: The number of times that the text `self` should be repeated to make
     the new text.

   > Example
     Repeat the string "A" five times.

         "A" * 5 == "AAAAA"

   > Example
     Repeat the string "Hello " twice.

         "Hello " * 2 == "Hello Hello "
Text.* : Integer -> Text
Text.* self count = self.repeat count

## Takes an integer and returns a new text, consisting of `count` concatenated
   copies of `self`.

   Arguments:
   - count: The number of times that the text `self` should be repeated to make
     the new text.

   > Example
     Repeat the string "ABBA" five times.

         "ABBA".repeat 5 == "ABBAABBAABBAABBAABBA"

   > Example
     Repeat the string "Hello " twice.

         "Hello ".repeat 2 == "Hello Hello "
Text.repeat : Integer -> Text
Text.repeat self count=1 =
    0.up_to count . fold "" acc-> _-> acc + self

## ALIAS first, last, left, right, mid, substring
   Creates a new Text by selecting the specified range of the input.

   This can select a section of text from the beginning, end, or middle of the
   input using various criteria defined by the range parameter.

   Arguments:
   - range: The section of the self text to return.
     If a `Text_Sub_Range`, then the selection is interpreted following the rules of that type.
     If a `Range`, the selection is specified by two indices, from and to.

   Returns:
   The part of the input as specified by the range parameter.

   > Examples
     Various different ways to take part of "Hello World!"

         "Hello World!".take First == "H"
         "Hello World!".take (First 5) == "Hello"
         "Hello World!".take (First 0) == ""
         "Hello World!".take Last == "!"
         "Hello World!".take (Last 6) == "World!"
         "Hello World!".take (Before " ") == "Hello"
         "Hello World!".take (Before_Last "o") == "Hello W"
         "Hello World!".take (After " ") == "World!"
         "Hello World!".take (After_Last "o") == "rld!"
         "Hello World!".take (While c->c!=" ") == "Hello"
         "Hello World!".take (Range 3 5) == "lo"
         "Hello World!".take (Range 5 Nothing) == " World!"
         "Hello World!".take (Range 5 12) == " World!"
         "Hello World!".take (Range 6 12 2) == "Wrd"
         "Hello World!".take (Every 2 first=6) == "Wrd"
         "Hello World!".take (Every 3) == "Hl Wl"
         "Hello World!".take (By_Index 0) == "H"
         "Hello World!".take (By_Index [1, 0, 0, 6, 0]) == "eHHWH"
         "Hello World!".take (By_Index [Range 0 3, 6, Range 6 12 2]) == "HelWWrd"
         "Hello World!".take (Sample 3 seed=42) == "l d"
Text.take : (Text_Sub_Range | Index_Sub_Range | Range | Integer) -> Text ! Index_Out_Of_Bounds
Text.take self range=(Index_Sub_Range.First 1) =
    ranges = Codepoint_Ranges.resolve self range
    case ranges of
        Range.Between start end 1 ->
            Text_Utils.substring self start end
        Codepoint_Ranges.Value char_ranges _ ->
            slice_text self char_ranges

## ALIAS skip, remove
   Creates a new Text by removing the specified range of the input.

   This can select a section of text from the beginning, end, or middle of the
   input using various criteria defined by the range parameter.

   Arguments:
   - range: The section of the this text to return.
     If a `Text_Sub_Range`, then the selection is interpreted following the rules of that type.
     If a `Range`, the selection is specified by two indices, from and to.

   Returns:
   The part of the input as specified by the range parameter.

   > Examples
     Various different ways to take part of "Hello World!"

         "Hello World!".drop First == "ello World!"
         "Hello World!".drop (First 5) == " World!"
         "Hello World!".drop (First 0) == "Hello World!"
         "Hello World!".drop Last == "Hello World"
         "Hello World!".drop (Last 6) == "Hello "
         "Hello World!".drop (Before " ") == " World!"
         "Hello World!".drop (Before_Last "o") == "orld!"
         "Hello World!".drop (After " ") == "Hello "
         "Hello World!".drop (After_Last "o") == "Hello Wo"
         "Hello World!".drop (While c->c!=" ") == " World!"
         "Hello World!".drop (Range 3 5) == "Hel World!"
         "Hello World!".drop (Range 5 Nothing) == "Hello"
         "Hello World!".drop (Range 5 12) == "Hello"
         "Hello World!".drop (Range 6 12 2) == "Hello ol!"
         "Hello World!".drop (Every 2 first=6) == "Hello ol!"
         "Hello World!".drop (Every 3) == "elo ord!"
         "Hello World!".drop (By_Index 0) == "ello World!"
         "Hello World!".drop (By_Index [1, 0, 0, 6, 0]) == "llo orld!"
         "Hello World!".drop (By_Index [Range 0 3, 6, Range 6 12 2]) == "lo ol!"
         "Hello World!".drop (Sample 3 seed=42) == "HeloWorl!"
Text.drop : (Text_Sub_Range | Index_Sub_Range | Range) -> Text ! Index_Out_Of_Bounds
Text.drop self range=(Index_Sub_Range.First 1) =
    ranges = Codepoint_Ranges.resolve self range
    case ranges of
        Range.Between start end 1 ->
            if start == 0 then Text_Utils.drop_first self end else
                prefix = Text_Utils.substring self 0 start
                if end == (Text_Utils.char_length self) then prefix else
                    prefix + Text_Utils.drop_first self end
        _ : Codepoint_Ranges ->
            sorted_char_ranges_to_remove = ranges.sorted_and_distinct_ranges
            char_length = Text_Utils.char_length self
            inverted = Index_Sub_Range_Module.invert_range_selection sorted_char_ranges_to_remove char_length needs_sorting=False
            slice_text self inverted

## ALIAS lower, upper, title, proper
   Converts each character in `self` to the specified case.

   Arguments:
   - case_option: specifies how to convert the characters.
   - locale: specifies the locale for character case mapping. Defaults to
     `Locale.default`.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   ! What is title case?
     Title case capitalizes the first letter of every word and ensures that all
     the remaining letters are in lower case. Some definitions of title case
     avoid capitalizing minor words (like the article "the" in English) but this
     implementation treats all words in the same way.

   > Example
     Converting a text to lower case in the default locale:

         "My TeXt!".to_case == "my text!"

   > Example
     Converting a text to upper case in a specified locale:

         from Standard.Base import all

         example_case_with_locale = "i".to_case Upper (Locale.new "tr") == "İ"
Text.to_case : Case -> Locale -> Text
Text.to_case self case_option=Case.Lower locale=Locale.default = case case_option of
    Case.Lower -> UCharacter.toLowerCase locale.java_locale self
    Case.Upper -> UCharacter.toUpperCase locale.java_locale self
    Case.Title -> UCharacter.toTitleCase locale.java_locale self Nothing

## Returns the input padded to the specified `length`, using the `with_pad`
   string repeated at the start or the end.

   Arguments:
   - length: The new length for the output. The result is the original string if
     the input length is more than length.
   - with_pad: The string to use to pad the input. If the last repetition
     exceeds the target length, it is truncated to the required size. If padding
     at the `End`, the beginning of the padding string is used and if padding at
     `Start`, the end of the string is used.
   - at: The location of where to pad the input.

   > Example
     Padding a text with whitespace at the end.

         "Hello World!".pad 15 == "Hello World!   "

   > Example
     Behavior of padding if the `with_pad` string has to be truncated.

         "HELLO".pad 9 "AB" == "HELLOABAB"
         "HELLO".pad 8 "AB" == "HELLOABA"
         "HELLO".pad 8 "AB" Location.Start == "BABHELLO"

Text.pad : Integer -> Text -> Location -> Text
Text.pad self length=0 with_pad=' ' at=Location.End = case at of
    Location.Both -> Error.throw (Illegal_Argument.Error "`Location.Both` cannot be used with `pad`.")
    _ ->
        with_pad_length = with_pad.length
        if with_pad_length == 0 then Error.throw (Illegal_Argument.Error "`with_pad` must not be an empty string.") else
            pad_size = length - self.length
            if pad_size <= 0 then self else
                full_repetitions = pad_size.div with_pad_length
                remainder = pad_size % with_pad_length
                case at of
                    Location.Start ->
                        with_pad.take (Index_Sub_Range.Last remainder) + with_pad.repeat full_repetitions + self
                    Location.End ->
                        self + with_pad.repeat full_repetitions + with_pad.take (Index_Sub_Range.First remainder)

## This function removes the specified `trim_characters`, by default any
   whitespace, from the start, the end, or both ends of the input.

   Arguments:
   - where: The location of where to trim the input. By default, this function
     trims both ends of the input.
   - what: Either a `Text` containing characters that should be removed or a
     predicate taking single character strings and specifying if they should be
     removed. By default, all Unicode whitespace is removed.

   > Example
     Trimming whitespace from a string.

         " Hello! ".trim == "Hello!"
         " Hello! ".trim Location.Start == "Hello! "
         " Hello! ".trim Location.End == " Hello!"

   > Example
     Trimming a specific set of letters from a string.

        "ABC123".trim Location.Start "ABC" == "123"
        "ABBA123".trim Location.Start "ABC" == "123"
Text.trim : Location -> (Text | (Text -> Boolean)) -> Text
Text.trim self where=Location.Both what=_.is_whitespace =
    predicate = case what of
        _ : Text -> what.contains _
        _ -> what
    break_iterator = BreakIterator.getCharacterInstance
    break_iterator.setText self
    start_index = case where of
        Location.End -> 0
        _ ->
            loop current next =
                if next < 0 then current else
                    case predicate (Text_Utils.substring self current next) of
                        True ->
                            @Tail_Call loop next break_iterator.next
                        False -> current
            loop 0 break_iterator.next
    end_index = case where of
        Location.Start -> Text_Utils.char_length self
        _ ->
            loop current prev =
                if prev < 0 then current else
                    case predicate (Text_Utils.substring self prev current) of
                        True ->
                            @Tail_Call loop prev break_iterator.previous
                        False -> current
            current = break_iterator.last
            loop current break_iterator.previous
    if start_index >= end_index then "" else
        Text_Utils.substring self start_index end_index

## ALIAS position_of, span_of
   Find the location of the `term` in the input.
   Returns a Span representing the location at which the term was found, or
   `Nothing` if the term was not found in the input.

   Arguments:
   - term: The term to find.
   - mode: Specifies if the first or last occurrence of the term should be
     returned if there are multiple occurrences within the input. The first
     occurrence is returned by default.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Finding location of a substring.

         "Hello World!".locate "J" == Nothing
         "Hello World!".locate "o" == Span (Range 4 5) "Hello World!"
         "Hello World!".locate "o" mode=Matching_Mode.Last == Span (Range 7 8) "Hello World!"

   ! Match Length
     The  function returns not only the index of the match but a `Span` instance
     which contains both the start and end indices, allowing to determine the
     length of the match. This is useful for case insensitive matching. In
     case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in case-insensitive mode, the length of the match
     can be shorter or longer than the term that was being matched, so it is
     extremely important to not rely on the length of the matched term when
     analysing the matches as they may have different lengths.

   > Example
     Match length differences in case-insensitive matching.

         term = "straße"
         text = "MONUMENTENSTRASSE 42"
         match = text . locate term case_sensitivity=Case_Sensitivity.Insensitive
         term.length . should_equal 6
         match.length . should_equal 7

   ! Matching Grapheme Clusters
     In case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in this mode, it is sometimes possible for a term to
     match only a part of some single grapheme cluster, for example in the text
     `ﬃa` the term `ia` will match just one-third of the first grapheme `ﬃ`.
     Since we do not have the resolution to distinguish such partial matches
     (as that would require non-integer indices), so a match which matched just
     a part of some grapheme cluster is extended and treated as if it matched
     the whole grapheme cluster.

   > Example
     Extending matches to full grapheme clusters.

         ligatures = "ﬃﬄ"
         ligatures.length == 2
         term_1 = "IFF"
         match_1 = ligatures . locate term_1 case_sensitivity=Case_Sensitive.Insensitive
         term_1.length == 3
         match_1.length == 2
         term_2 = "ffiffl"
         match_2 = ligatures . locate term_2 case_sensitivity=Case_Sensitive.Insensitive
         term_2.length == 6
         match_2.length == 2
         # After being extended to full grapheme clusters, both terms "IFF" and "ffiffl" match the same span of grapheme clusters.
         match_1 == match_2

Text.locate : Text -> Matching_Mode -> Case_Sensitivity -> Span | Nothing
Text.locate self term="" mode=Matching_Mode.First case_sensitivity=Case_Sensitivity.Sensitive = case case_sensitivity of
    Case_Sensitivity.Default -> self.locate term mode Case_Sensitivity.Sensitive
    Case_Sensitivity.Sensitive ->
        codepoint_span = case mode of
            Matching_Mode.First -> Text_Utils.span_of self term
            Matching_Mode.Last -> Text_Utils.last_span_of self term
        if codepoint_span.is_nothing then Nothing else
            start = Text_Utils.utf16_index_to_grapheme_index self codepoint_span.codeunit_start
            ## While the codepoint_span may have different code unit length
               from our term, the `length` counted in grapheme clusters is
               guaranteed to be the same.
            end = start + term.length
            Span.Value (start.up_to end) self
    Case_Sensitivity.Insensitive locale -> case term.is_empty of
        True -> case mode of
            Matching_Mode.First -> Span.Value (0.up_to 0) self
            Matching_Mode.Last ->
                end = self.length
                Span.Value (end.up_to end) self
        False ->
            search_for_last = case mode of
                Matching_Mode.First -> False
                Matching_Mode.Last -> True
            case Text_Utils.span_of_case_insensitive self term locale.java_locale search_for_last of
                Nothing -> Nothing
                grapheme_span ->
                    Span.Value (grapheme_span.grapheme_start.up_to grapheme_span.grapheme_end) self

## ALIAS index_of_all, position_of_all, span_of_all
   Finds all the locations of the `term` in the input.
   If not found, the function returns an empty Vector.

   Arguments:
   - term: The term to find.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Finding locations of all occurrences of a substring.

         "Hello World!".locate_all "J" == []
         "Hello World!".locate_all "o" . map .start == [4, 7]

   ! Match Length
     The  function returns not only the index of the match but a `Span` instance
     which contains both the start and end indices, allowing to determine the
     length of the match. This is useful for case insensitive matching. In
     case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in case-insensitive mode, the length of the match
     can be shorter or longer than the term that was being matched, so it is
     extremely important to not rely on the length of the matched term when
     analysing the matches as they may have different lengths.

   > Example
     Match length differences in case-insensitive matching.

         term = "strasse"
         text = "MONUMENTENSTRASSE ist eine große Straße."
         match = text . locate_all term case_sensitivity=Case_Sensitive.Insensitive
         term.length == 7
         match . map .length == [7, 6]

   ! Matching Grapheme Clusters
     In case-insensitive mode, a single character can match multiple characters,
     for example `ß` will match `ss` and `SS`, and the ligature `ﬃ` will match
     `ffi` or `f` etc. Thus in this mode, it is sometimes possible for a term to
     match only a part of some single grapheme cluster, for example in the text
     `ﬃa` the term `ia` will match just one-third of the first grapheme `ﬃ`.
     Since we do not have the resolution to distinguish such partial matches
     (as that would require non-integer indices), so a match which matched just
     a part of some grapheme cluster is extended and treated as if it matched
     the whole grapheme cluster.

   > Example
     Extending matches to full grapheme clusters.

         ligatures = "ﬃﬄFFIFF"
         ligatures.length == 7
         match_1 = ligatures . locate_all "IFF" case_sensitivity=Case_Sensitive.Insensitive
         match_1 . map .length == [2, 3]
         match_2 = ligatures . locate_all "ffiff" case_sensitivity=Case_Sensitive.Insensitive
         match_2 . map .length == [2, 5]
Text.locate_all : Text -> Case_Sensitivity -> Vector Span
Text.locate_all self term="" case_sensitivity=Case_Sensitivity.Sensitive = if term.is_empty then Vector.new (self.length + 1) (ix -> Span.Value (ix.up_to ix) self) else case case_sensitivity of
    Case_Sensitivity.Default -> self.locate term Case_Sensitivity.Sensitive
    Case_Sensitivity.Sensitive ->
        codepoint_spans = Vector.from_polyglot_array <| Text_Utils.span_of_all self term
        grahpeme_ixes = Vector.from_polyglot_array <| Text_Utils.utf16_indices_to_grapheme_indices self (codepoint_spans.map .codeunit_start).to_array
        ## While the codepoint_spans may have different code unit lengths
           from our term, the `length` counted in grapheme clusters is
           guaranteed to be the same.
        offset = term.length
        grahpeme_ixes . map start->
            end = start+offset
            Span.Value (start.up_to end) self
    Case_Sensitivity.Insensitive locale ->
        grapheme_spans = Vector.from_polyglot_array <| Text_Utils.span_of_all_case_insensitive self term locale.java_locale
        grapheme_spans.map grapheme_span->
            Span.Value (grapheme_span.grapheme_start.up_to grapheme_span.grapheme_end) self

## Find the first index of the `term` in the input.
   Returns `Nothing` if the term was not found in the input.

   Using `locate` is preferred as then you can also get the length of the match
   which may not necessarily be equal to the length of the searched term - not
   only in case of regex matching but also in case insensitive mode.
   See the Match Length section of `locate` for an explanation.

   Arguments:
   - term: The term to find.
   - start: The index to start searching from. If the index is negative, it
     is counted from the end of the vector.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Finding location of a substring.

         "Hello World!".index_of "J" == Nothing
         "Hello World!".index_of "o" == 4
Text.index_of : Text -> Integer -> Case_Sensitivity -> Integer | Nothing
Text.index_of self term="" start=0 case_sensitivity=Case_Sensitivity.Sensitive =
    used_start = if start < 0 then start+self.length else start
    if used_start < 0 || used_start > self.length then Error.throw (Index_Out_Of_Bounds.Error start self.length+1) else
        used = if used_start == 0 then self else self.drop used_start
        span = used.locate term Matching_Mode.First case_sensitivity
        if span.is_nothing then Nothing else span.start+used_start

## Find the last index of the `term` in the input.
   Returns `Nothing` if the term was not found in the input.

   Using `locate` is preferred as then you can also get the length of the match
   which may not necessarily be equal to the length of the searched term - not
   only in case of regex matching but also in case insensitive mode.
   See the Match Length section of `locate` for an explanation.

   Arguments:
   - term: The term to find.
   - start: The index to start searching backwards from. If the index is
     negative, it is counted from the end of the vector.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Finding location of a substring.

         "Hello World!".last_index_of "J" == Nothing
         "Hello World!".last_index_of "o" == 7
Text.last_index_of : Text -> Integer -> Case_Sensitivity -> Integer | Nothing
Text.last_index_of self term="" start=-1 case_sensitivity=Case_Sensitivity.Sensitive =
    used_start = if start < 0 then start+self.length else start
    if used_start < 0 || used_start >= self.length then Error.throw (Index_Out_Of_Bounds.Error start self.length) else
        used = if used_start == self.length-1 then self else self.take used_start+1
        span = used.locate term Matching_Mode.Last case_sensitivity
        if span.is_nothing then Nothing else span.start

## PRIVATE
   Returns a new Text constructed by slicing the input according to the provided
   ranges. The ranges are assumed to have step equal to 1 and bounds within the
   input's range.

   The input ranges are in UTF-16 code unit space.
slice_text text char_ranges =
    sb = StringBuilder.new
    char_ranges.map char_range->
       sb.append text char_range.start char_range.end
    sb.toString

## PRIVATE

   Find occurrences of delimiters in a string.
split_find_delimiters : Text -> Text | Vector Text  -> Case_Sensitivity -> Vector Text | Illegal_Argument
split_find_delimiters input delimiter case_sensitivity =
    Vector.from_polyglot_array <| case delimiter of
        _ : Text -> case case_sensitivity of
            Case_Sensitivity.Sensitive ->
                Text_Utils.span_of_all input delimiter
            Case_Sensitivity.Insensitive locale ->
                Text_Utils.span_of_all_case_insensitive input delimiter locale.java_locale
        _ : Vector -> case case_sensitivity of
            Case_Sensitivity.Sensitive ->
                Text_Utils.span_of_all_multiple input delimiter
            Case_Sensitivity.Insensitive locale ->
                Text_Utils.span_of_all_case_insensitive_multiple input delimiter locale.java_locale
