## Methods for operating on `Text` in Enso.

from Standard.Base import all
from Standard.Builtins import Text, Prim_Text_Helpers

import Standard.Base.Data.Text.Regex
import Standard.Base.Data.Text.Regex.Mode
import Standard.Base.Data.Text.Line_Ending_Style
import Standard.Base.Data.Text.Split_Kind
import Standard.Base.Data.Text.Text_Sub_Range
import Standard.Base.Data.Locale
import Standard.Base.Meta

from Standard.Builtins export Text

export Standard.Base.Data.Text.Split_Kind
export Standard.Base.Data.Text.Line_Ending_Style

polyglot java import com.ibm.icu.lang.UCharacter
polyglot java import com.ibm.icu.text.BreakIterator
polyglot java import org.enso.base.Text_Utils

## UNSTABLE

   An error for when an index is out of bounds in a text.

   Arguments:
   - index: The requested index in the text.
   - length: The length of the text.
type Index_Out_Of_Bounds_Error index length

## ALIAS Length

   Computes the number of characters in the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Getting the length of the string "건반(Korean)".

         "건반(Korean)".length
Text.length : Integer
Text.length =
    iterator = BreakIterator.getCharacterInstance
    iterator.setText this

    count accum iter = if iter == -1 then accum else
        @Tail_Call count (accum + 1) iterator.next
    count 0 iterator.next

## Applies the provided `function` to each character in `this`.

   Arguments:
   - function: The operation to apply to each character in the text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Print each character in the text "aaa".

         "aaa".each IO.println
Text.each : (Text -> Any) -> Nothing
Text.each function =
    iterator = BreakIterator.getCharacterInstance
    iterator.setText this

    iterate prev nxt = if nxt == -1 then Nothing else
        function (Text_Utils.substring this prev nxt)
        @Tail_Call iterate nxt iterator.next
    iterate iterator.first iterator.next

## ALIAS Get Character

   Returns a character from the text at the specified index (0-based).

   Arguments:
     - index: The location in the text to get the character from. The
       index is also allowed be negative, then the characters are
       counted from the end of the text, i.e. -1 will correspond to the
       last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the individual characters in the text "건반(Korean)".

         "건반(Korean)".at 1 == "반"
Text.at : Integer -> Text ! Index_Out_Of_Bounds_Error
Text.at index =
    case index < 0 of
        True ->
            length = this.length
            new_index = index + length
            if new_index < 0 then Error.throw (Index_Out_Of_Bounds_Error index length) else
                this.at new_index
        False ->
            iterator = BreakIterator.getCharacterInstance
            iterator.setText this
            first = iterator.next index
            next = if first == -1 then -1 else iterator.next
            if (next == -1) then (Error.throw (Index_Out_Of_Bounds_Error index this.length)) else
                Text_Utils.substring this first next

## ALIAS Get Characters

   Returns a vector containing all characters in the given text.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Get the individual characters in the text "건반(Korean)".

         "건반(Korean)".characters
Text.characters : Vector.Vector Text
Text.characters =
    bldr = Vector.new_builder
    this.each bldr.append
    bldr.to_vector

## ALIAS Match Text

   Matches the text in `this` against the provided regex `pattern`, returning
   the match(es) if present or `Nothing` if there are no matches.

   Arguments:
   - pattern: The pattern to match `this` against. We recommend using _raw text_
     to write your patterns.
   - mode: This argument specifies how many matches the engine will try and
     find. When mode is set to either `Mode.First` or `Mode.Full`, this method
     will return either a single `Match` or `Nothing`. If set to an `Integer` or
     `Mode.All`, this method will return either a `Vector Match` or `Nothing`.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - comments: Enables or disables the comments mode for the regular expression.
     In comments mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceeded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceeded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Find matches for a basic email regex in some text. NOTE: This regex is
     _not_ compliant with RFC 5322.

         example_match =
             regex = ".+@.+"
             "contact@enso.org".match regex
Text.match : Text | Engine.Pattern -> Mode.Mode -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Match | Vector.Vector Match | Nothing ! Regex.Compile_Error
Text.match pattern mode=Mode.All match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    compiled_pattern = Regex.compile pattern match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
    compiled_pattern.match this mode

## ALIAS Check Matches

   Matches the text in `this` against the provided regex `pattern`, returning
   `True` if the text matches at least once, and `False` otherwise.

   Arguments:
   - pattern: The pattern to match `this` against. We recommend using _raw text_
     to write your patterns.
   - mode: This argument specifies how many matches the engine will try and
     find. When mode is set to either `Mode.First` or `Mode.Full`, this method
     will return either a single `Match` or `Nothing`. If set to an `Integer` or
     `Mode.All`, this method will return either a `Vector Match` or `Nothing`.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - comments: Enables or disables the comments mode for the regular expression.
     In comments mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceeded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceeded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Checks if some text matches a basic email regex. NOTE: This regex is _not_
     compliant with RFC 5322.

         example_match =
             regex = ".+@.+"
             "contact@enso.org".matches regex
Text.matches : Text | Engine.Pattern -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Boolean ! Regex.Compile_Error
Text.matches pattern match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    compiled_pattern = Regex.compile pattern match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
    compiled_pattern.matches this

## ALIAS Find Text

   Finds all occurrences of `pattern` in the text `this`, returning the text(s)
   if present, or `Nothing` if there are no matches.

   Arguments:
   - pattern: The pattern to match `this` against. We recommend using _raw text_
     to write your patterns.
   - mode: This argument specifies how many matches the engine will try and
     find. When mode is set to either `Mode.First` or `Mode.Full`, this method
     will return either a single `Text` or `Nothing`. If set to an `Integer` or
     `Mode.All`, this method will return either a `Vector Text` or `Nothing`.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - comments: Enables or disables the comments mode for the regular expression.
     In comments mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceeded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceeded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Find words that contain three or less letters in text`"\w{1,3}"`

         example_find =
             text = "Now I know my ABCs"
             text.find "\w{1,3}"
Text.find : Text | Engine.Pattern -> Mode.Mode -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Text | Vector.Vector Text | Nothing
Text.find pattern mode=Mode.All match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    compiled_pattern = Regex.compile pattern match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
    compiled_pattern.find this mode

## ALIAS Split Text

   Takes a separator and returns the vector that results from splitting `this`
   on the configured number of occurrences of `separator`.

   Arguments:
   - separator: The pattern used to split the text.
   - mode: This argument specifies how many matches the engine will try and
     find. When mode is set to either `Mode.First` or `Mode.Full`, this method
     will return either a single `Text` or `Nothing`. If set to an `Integer` or
     `Mode.All`, this method will return either a `Vector Text` or `Nothing`.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - verbose: Enables or disables the verbose mode for the regular expression.
     In verbose mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceeded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceeded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Split the comma-separated text into a vector of items.

         "ham,eggs,cheese,tomatoes".split ","

   > Example
     Split the text on whitespace into a vector of items.

         "ham eggs cheese tomatoes".split Split_Kind.Whitespace

   > Example
     Split the text on any occurrence of the separator `"::"`.

         example_split =
             text = "Namespace::package::package::Type"
             text.split ":::"
Text.split : Split_Kind -> Mode.Mode -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Vector.Vector Text
Text.split separator=Split_Kind.Whitespace mode=Mode.All match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    case separator of
        Split_Kind.Words -> Vector.Vector this.words
        Split_Kind.Whitespace ->
            pattern = Regex.compile "\s+" match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
            pattern.split this mode=mode
        Split_Kind.Lines ->
            pattern = Regex.compile "\v+" match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
            pattern.split this mode=mode
        Text ->
            pattern = Regex.compile separator match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
            pattern.split this mode=mode

## ALIAS Replace Text

   Replaces each occurrence of `old_sequence` with `new_sequence`, returning
   `this` unchanged if no matches are found.

   Arguments:
   - old_sequence: The pattern to search for in `this`.
   - new_sequence: The text to replace every occurrence of `old_sequence` with.
   - mode: This argument specifies how many matches the engine will try to
     replace.
   - match_ascii: Enables or disables pure-ASCII matching for the regex. If you
     know your data only contains ASCII then you can enable this for a
     performance boost on some regex engines.
   - case_insensitive: Enables or disables case-insensitive matching. Case
     insensitive matching behaves as if it normalises the case of all input
     text before matching on it.
   - dot_matches_newline: Enables or disables the dot matches newline option.
     This specifies that the `.` special character should match everything
     _including_ newline characters. Without this flag, it will match all
     characters _except_ newlines.
   - multiline: Enables or disables the multiline option. Multiline specifies
     that the `^` and `$` pattern characters match the start and end of lines,
     as well as the start and end of the input respectively.
   - comments: Enables or disables the comments mode for the regular expression.
     In comments mode, the following changes apply:
     - Whitespace within the pattern is ignored, except when within a
       character class or when preceeded by an unescaped backslash, or within
       grouping constructs (e.g. `(?...)`).
     - When a line contains a `#`, that is not in a character class and is not
       preceeded by an unescaped backslash, all characters from the leftmost
       such `#` to the end of the line are ignored. That is to say, they act
       as _comments_ in the regex.
   - extra_opts: Specifies additional options in a vector. This allows options
     to be supplied and computed without having to break them out into arguments
     to the function. Where these overlap with one of the flags (`match_ascii`,
     `case_insensitive`, `dot_matches_newline`, `multiline` and `verbose`), the
     flags take precedence.

   ! Boolean Flags and Extra Options
     This function contains a number of arguments that are boolean flags that
     enable or disable common options for the regex. At the same time, it also
     provides the ability to specify options in the `extra_opts` argument.

     Where one of the flags is _set_ (has the value `True` or `False`), the
     value of the flag takes precedence over the value in `extra_opts` when
     merging the options to the engine. The flags are _unset_ (have value
     `Nothing`) by default.

   > Example
     Replace letters in the text "aaa".

         'aaa'.replace 'aa' 'b' == 'ba'

   > Example
     Replace every word of two letters or less with the string "SMOL".

         example_replace =
             text = "I am a very smol word."
             text.replace "\w\w(?!\w)"
Text.replace : Text | Engine.Pattern -> Text -> Mode.Mode -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Boolean | Nothing -> Vector.Vector Option.Option -> Text
Text.replace old_sequence new_sequence mode=Mode.All match_ascii=Nothing case_insensitive=Nothing dot_matches_newline=Nothing multiline=Nothing comments=Nothing extra_opts=[] =
    compiled_pattern = Regex.compile old_sequence match_ascii=match_ascii case_insensitive=case_insensitive dot_matches_newline=dot_matches_newline multiline=multiline comments=comments extra_opts=extra_opts
    compiled_pattern.replace this new_sequence mode

## ALIAS Get Words

   Returns a vector containing all words in the given text.

   Arguments:
   - keep_whitespace: Whether or not the whitespace around the words should be
     preserved. If set to `True`, the whitespace will be included as a "word" in
     the output.

   ! What is a Word?
     A word is defined based on the definition of Word Boundaries in the Unicode
     Standard Annex 29, supplemented by language-specific dictionaries for
     Chinese, Japanese, Thai, and Khmer.

   > Example
     Getting the words in the sentence "I have not one, but two cats."

        "I have not one, but two cats.".words
Text.words : Boolean -> Vector.Vector Text
Text.words keep_whitespace=False =
    iterator = BreakIterator.getWordInstance
    iterator.setText this
    bldr = Vector.new_builder
    fst = iterator.first
    nxt = iterator.next

    build prev nxt = if nxt == -1 then Nothing else
        word = Text_Utils.substring this prev nxt
        word_not_whitespace = (Text_Utils.is_whitespace word).not
        if word_not_whitespace then bldr.append word else
            if keep_whitespace then
                bldr.append word

        next_nxt = iterator.next
        @Tail_Call build nxt next_nxt

    build fst nxt

    bldr.to_vector

## Checks whether `this` is equal to `that`.

   Arguments:
   - that: The text to compare `this` for equality with.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

   > Example
     The string 'é' (i.e. the character U+00E9, LATIN SMALL LETTER E WITH ACUTE)
     is canonically the same as the string 'e\u0301' (i.e. the letter `e`
     followed by U+0301, COMBINING ACUTE ACCENT). Therefore:

         ('é' == 'e\u0301') == True
Text.== : Any -> Boolean
Text.== that = if Meta.is_same_object this Text then Meta.is_same_object that Text else
    Text_Utils.equals this that

## Checks whether `this` is equal to `that`, ignoring the case of the texts.

   Arguments:
   - that: The text to compare `this` for case-insensitive equality with.

   Two texts are considered equal ignoring case if they are of the same length
   and corresponding characters are equal ignoring case.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

   > Example
     The string 'É' (i.e. the character U+00C9, LATIN CAPITAL LETTER E WITH
     ACUTE) is equal ignore case to the string 'é' (i.e. the character U+00E9,
     LATIN SMALL LETTER E WITH ACUTE), which is canonically the same as the
     string 'e\u0301' (i.e. the letter `e` followed by U+0301, COMBINING ACUTE
     ACCENT). Therefore:

         (('É' . equals_ignore_case 'é') && ('é' . equals_ignore_case 'e\u0301')) == True
Text.equals_ignore_case : Text -> Locale -> Boolean
Text.equals_ignore_case that locale=Locale.default =
    (this.to_case_insensitive_key locale) == (that.to_case_insensitive_key locale)

## ADVANCED
   PRIVATE
   UNSTABLE
   Unifies the case of all letters in the text, generating a key which can be
   used to perform case-insensitive comparisons.
Text.to_case_insensitive_key : Locale -> Text
Text.to_case_insensitive_key locale=Locale.default =
    this.to_lower_case locale . to_upper_case locale

## Compare two texts to discover their ordering.

   Arguments:
   - that: The text to order `this` with respect to.

   > Example
     Checking how "a" orders in relation to "b".

         "a".compare_to "b"
Text.compare_to : Text -> Ordering
Text.compare_to that =
    comparison_result = Text_Utils.compare_normalized this that
    if comparison_result == 0 then Ordering.Equal else
        if comparison_result < 0 then Ordering.Less else
            Ordering.Greater

## ALIAS Check Emptiness

   Check if `this` is empty.

   ! What is Empty?
     Text is considered to be empty when its length is zero.

   > Example
     Check if the text "aaa" is empty.

         "aaa".is_empty
Text.is_empty : Boolean
Text.is_empty = this == ""

## ALIAS Check Non-Emptiness

   Check if `this` is not empty.

   ! What is Not Empty?
     Text is considered to be not empty when its length is greater than zero.

   > Example
     Check if the text "aaa" is not empty.

         "aaa".not_empty
Text.not_empty : Boolean
Text.not_empty = this.is_empty.not

## Returns if a character from the text at the specified index (0-based) is a
   digit (0-9).

   Arguments:
     - index: The location in the text to get the character from. The
       index is also allowed be negative, then the characters are
       counted from the end of the text, i.e. -1 will correspond to the
       last character.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Check if an individual character is a digit:

         "0".is_digit == True
         "A0".is_digit == False
         "A0".is_digit 1 == True
         "건반(Korean)".is_digit 1 == False
Text.is_digit : Integer -> Text ! Index_Out_Of_Bounds_Error
Text.is_digit (index=0) =
    grapheme = this.at index
    if grapheme.is_error then grapheme else
        char = (Text_Utils.get_chars grapheme).at 0
        char>=48 && char<=57

## Returns a vector containing bytes representing the UTF-8 encoding of the
   input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Get the UTF-8 bytes of the text "Hello".

         "Hello".utf_8
Text.utf_8 : Vector.Vector Byte
Text.utf_8 = Vector.Vector (Text_Utils.get_bytes this)

## Takes a vector of bytes and returns Text resulting from decoding it as UTF-8.

   Arguments:
   - bytes: The vector of UTF-8 bytes.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Decoding the bytes to get a text.

         Text.from_utf_8 [-32, -92, -107, -32, -91, -115, -32, -92, -73, -32, -92, -65]
Text.from_utf_8 : Vector.Vector Byte -> Text
Text.from_utf_8 bytes = Text_Utils.from_utf_8 bytes.to_array

## ADVANCED

   Returns a vector containing the UTF-16 characters that encode the input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Get the UTF-16 bytes of the text "Hello".

         "Hello".utf_16
Text.utf_16 : Vector.Vector Integer
Text.utf_16 = Vector.Vector (Text_Utils.get_chars this)

## ADVANCED

   Takes a vector of UTF-16 characters and returns the text that results from
   decoding it as UTF-16.

   Arguments:
   - chars: The vector of UTF-16 characters.

   This is useful for low-level operations, such as binary data encoding and
   decoding.
Text.from_utf_16 : Vector.Vector Integer -> Text
Text.from_utf_16 chars = Text_Utils.from_chars chars.to_array

## Returns a vector containing integers representing the Unicode codepoints of
   the input text.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Get the codepoints of the text "Hello".

         "Hello".codepoints
Text.codepoints : Vector.Vector Integer
Text.codepoints = Vector.Vector (Text_Utils.get_codepoints this)

## Takes an array of numbers and returns the text resulting from interpreting it
   as a sequence of Unicode codepoints.

   This is useful for low-level operations, such as binary data encoding and
   decoding.

   > Example
     Converting a vector of codepoints back into a text.
         Text.from_codepoints [129318, 127996, 8205, 9794, 65039]
Text.from_codepoints : Vector.Vector Integer -> Text
Text.from_codepoints codepoints = Text_Utils.from_codepoints codepoints.to_array

## ALIAS Check Prefix

   Checks whether `this` starts with `prefix`.

   Arguments:
   - prefix: The prefix to see if `this` starts with.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

   > Example
     See if the text "Hello" starts with the prefix "hi".

         "Hello".starts_with "hi"
Text.starts_with : Text -> Boolean
Text.starts_with prefix = Text_Utils.starts_with this prefix

## ALIAS Check Suffix

   Checks whether `this` ends with `suffix`.

   Arguments:
   - suffix: The suffix to see if `this` ends with.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

   > Example
     See if the text "Hello" ends with the suffix "low".
         "Hello".ends_with "low"
Text.ends_with : Text -> Boolean
Text.ends_with suffix = Text_Utils.ends_with this suffix

## ALIAS Contains

   Checks whether `this` contains `sequence` as its substring.

   Arguments:
   - term: The term to find.
   - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
     rules specified in the matcher.
     If a `Regex_Matcher`, the term is used as a regular expression and matched
     using the associated options.

   Returns: `True` if term is found within `this`. `False` otherwise.

   ! Unicode Equality
     The definition of equality includes Unicode canonicalization. I.e. two
     texts are equal if they are identical after canonical decomposition. This
     ensures that different ways of expressing the same character in the
     underlying binary representation are considered equal.

     This however is not always well handled by the regex engine. The behaviour
     is as follows:

         'ś' . contains 's' == False
         's\u{301}' . contains 's' == False
         's\u{301}' . contains 'ś' == True
         'ś' . contains 's\u{301}' == True

         'ś' . contains 's' (Regex_Matcher.new) == True
         's\u{301}' . contains 's' (Regex_Matcher.new) == True
         's\u{301}' . contains 'ś' (Regex_Matcher.new) == True
         'ś' . contains 's\u{301}' (Regex_Matcher.new) == True

   > Example
     See if the text "Hello" contains the text "ell".

         "Hello".contains "ell"

   > Example
     See if the text "Cześć" contains the text 's\u{301}' (which folds to 'ś').

         "Cześć".contains 's\u{301}'

   > Example
     See if the text "Hello!" contains the text 'LO', ignoring case.

         "Hello!".contains "LO" (Text_Matcher Case_Insensitive.new)

   > Example
     See if the text "Hello!" contains any lowercase letters, using a regex.

         "Hello!".contains "[a-z]" Regex_Matcher.new
Text.contains : Text -> (Text_Matcher | Regex_Matcher) -> Boolean
Text.contains term="" matcher=Text_Matcher.new = case matcher of
    Text_Matcher case_sensitivity -> case case_sensitivity of
        True -> Text_Utils.contains this term
        Case_Insensitive locale ->
            Text_Utils.contains (this.to_case_insensitive_key locale) (term.to_case_insensitive_key locale)
    Regex_Matcher case_sensitive multiline match_ascii dot_matches_newline comments ->
        case_insensitive = case case_sensitive of
            True -> False
            ## TODO [RW] Currently locale is not supported in case-insensitive
               Regex matching. There are plans to revisit it:
               https://www.pivotaltracker.com/story/show/181313576
            Case_Insensitive _ -> True
        compiled_pattern = Regex.compile term case_insensitive=case_insensitive match_ascii=match_ascii dot_matches_newline=dot_matches_newline multiline=multiline comments=comments
        match = compiled_pattern.match this Mode.First
        match.is_nothing.not

## Text to JSON conversion.

   > Example
     Convert the text "cześć" to JSON.

         "cześć".to_json
Text.to_json : Json.String
Text.to_json = Json.String this

## Takes a non-negative integer and returns a new text, consisting of `count`
   concatenated copies of `this`.

   Arguments:
   - count: The number of times that the text `this` should be repeated to make
     the new text.

   > Example
     Repeat the string "ABBA" five times.

         "ABBA".repeat 5
Text.repeat : Integer -> Text
Text.repeat count =
    0.up_to count . fold "" acc-> _-> acc + this

## PRIVATE
   Utility function taking a range pointing at grapheme clusters and converting to a range on the underlying code points
range_to_char_indices : Text -> Range -> Range ! Index_Out_Of_Bounds_Error
range_to_char_indices text range =
    len = text.length
    start = if range.start < 0 then range.start + len else range.start
    end = if range.end == Nothing then len else (if range.end < 0 then range.end + len else range.end)
    is_valid = (Range 0 len+1).contains

    case (Pair (is_valid start) (is_valid end)) of
        Pair False _ -> Error.throw (Index_Out_Of_Bounds_Error range.start len)
        Pair True False -> Error.throw (Index_Out_Of_Bounds_Error range.end len)
        Pair True True ->
            if start>=end then (Range 0 0) else
                iterator = BreakIterator.getCharacterInstance
                iterator.setText text

                start_index = iterator.next start
                end_index = iterator.next (end - start)
                Range start_index end_index

## ALIAS first, last, left, right, mid, substring
   Creates a new Text by selecting the specified range of the input.

   This can select a section of text from the beginning, end, or middle of the
   input using various criteria defined by the range parameter.

   Arguments:
   - range: The section of the this text to return.
     If a `Text_Sub_Range`, then the selection is interpreted following the rules of that type.
     If a `Range`, the selection is specified by two indices, from and to.

   Returns:
   The part of the input as specified by the range parameter.

   > Examples
     Various different ways to take part of "Hello World!"

         "Hello World!".take First.new == "H"
         "Hello World!".take (First 5) == "Hello"
         "Hello World!".take (First 0) == ""
         "Hello World!".take Last.new == "!"
         "Hello World!".take (Last 6) == "World!"
         "Hello World!".take (Before " ") == "Hello"
         "Hello World!".take (Before_Last "o") == "Hello W"
         "Hello World!".take (After " ") == "World!"
         "Hello World!".take (After_Last "o") == "rld!"
         "Hello World!".take (While c->c!=" ") == "Hello"
         "Hello World!".take (Range 3 5) == "lo"
         "Hello World!".take (Range -3 -1) == "ld"
         "Hello World!".take (Range -3 Nothing) == "ld!"
         "Hello World!".take (Range 5 Nothing) == " World!"
         "Hello World!".take (Range 5 12) == " World!"
         "Hello World!".take (Range 12 12) == ""
Text.take : (Text_Sub_Range | Range) -> Text ! Index_Out_Of_Bounds_Error
Text.take range =
    char_range = case range of
        Range _ _ -> here.range_to_char_indices this range
        _ -> range.to_char_range this
    if char_range.is_error then char_range else
        Text_Utils.substring this char_range.start char_range.end

## Creates a new Text by removing the specified range of the input.

   This can select a section of text from the beginning, end, or middle of the
   input using various criteria defined by the range parameter.

   Arguments:
   - range: The section of the this text to return.
     If a `Text_Sub_Range`, then the selection is interpreted following the rules of that type.
     If a `Range`, the selection is specified by two indices, from and to.

   Returns:
   The part of the input as specified by the range parameter.

   > Examples
     Various different ways to take part of "Hello World!"

         "Hello World!".drop First.new == "ello World!"
         "Hello World!".drop (First 5) == " World!"
         "Hello World!".drop (First 0) == "Hello World!"
         "Hello World!".drop Last.new == "Hello World"
         "Hello World!".drop (Last 6) == "Hello "
         "Hello World!".drop (Before " ") == " World!"
         "Hello World!".drop (Before_Last "o") == "orld!"
         "Hello World!".drop (After " ") == "Hello "
         "Hello World!".drop (After_Last "o") == "Hello Wo"
         "Hello World!".drop (While c->c!=" ") == " World!"
         "Hello World!".drop (Range 3 5) == "Hel World!"
         "Hello World!".drop (Range -3 -1) == "Hello Wor!"
         "Hello World!".drop (Range -3 Nothing) == "Hello Wor"
         "Hello World!".drop (Range 5 Nothing) == "Hello"
         "Hello World!".drop (Range 5 12) == "Hello"
         "Hello World!".drop (Range 12 12) == "Hello World!"
Text.drop : (Text_Sub_Range | Range) -> Text ! Index_Out_Of_Bounds_Error
Text.drop range =
    char_range = case range of
        Range _ _ -> here.range_to_char_indices this range
        _ -> range.to_char_range this
    if char_range.start == 0 then Text_Utils.drop_first this char_range.end else
        prefix = Text_Utils.substring this 0 char_range.start
        if char_range.end == (Text_Utils.char_length this) then prefix else
            prefix + Text_Utils.drop_first this char_range.end

## ALIAS Lower Case

   Converts each character in `this` to lower case.

   Arguments:
   - locale: specifies the locale for character case mapping. Defaults to the
     `Locale.default` locale.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Converting a text to lower case in the default locale:

         "My TeXt!".to_lower_case == "my text!"

   > Example
     Converting a text to lower case in a specified locale (here, Turkey):

         from Standard.Base import all
         import Standard.Base.Data.Locale

         example_case_with_locale = "I".to_lower_case (Locale.new "tr") == "ı"
Text.to_lower_case : Locale.Locale -> Text
Text.to_lower_case locale=Locale.default =
    UCharacter.toLowerCase locale.java_locale this

## ALIAS Upper Case

   Converts each character in `this` to upper case.

   Arguments:
   - locale: specifies the locale for character case mapping. Defaults to
     `Locale.default`.

   ! What is a Character?
     A character is defined as an Extended Grapheme Cluster, see Unicode
     Standard Annex 29. This is the smallest unit that still has semantic
     meaning in most text-processing applications.

   > Example
     Converting a text to upper case in the default locale:

         "My TeXt!".to_upper_case == "MY TEXT!"

   > Example
     Converting a text to upper case in a specified locale:

         from Standard.Base import all
         import Standard.Base.Data.Locale

         example_case_with_locale = "i".to_upper_case (Locale.new "tr") == "İ"
Text.to_upper_case : Locale.Locale -> Text
Text.to_upper_case locale=Locale.default =
    UCharacter.toUpperCase locale.java_locale this
