from Standard.Base import all
import Standard.Base.Data.Array_Proxy.Array_Proxy
import Standard.Base.Data.Vector.No_Wrap
import Standard.Base.Errors.Common.Arithmetic_Error
import Standard.Base.Errors.Common.Incomparable_Values
import Standard.Base.Errors.Common.Index_Out_Of_Bounds
import Standard.Base.Errors.Common.No_Such_Method
import Standard.Base.Errors.Deprecated.Deprecated
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Internal.Polyglot_Helpers
import Standard.Base.Internal.Rounding_Helpers
from Standard.Base.Data.Index_Sub_Range import drop_helper, normalize_ranges, take_helper
from Standard.Base.Metadata.Widget import Numeric_Input
from Standard.Base.Widget_Helpers import make_data_cleanse_vector_selector, make_format_chooser, make_regex_text_widget

import project.Constants.Previous_Value
import project.Data_Formatter.Data_Formatter
import project.Internal.Cast_Helpers
import project.Internal.Column_Naming_Helper.Column_Naming_Helper
import project.Internal.Column_Ops
import project.Internal.Date_Time_Helpers
import project.Internal.Java_Problems
import project.Internal.Parse_Values_Helper
import project.Internal.Storage
import project.Internal.Value_Type_Helpers
import project.Internal.Widget_Helpers
import project.Rows_To_Read.Rows_To_Read
import project.Table.Table
import project.Value_Type.Auto
import project.Value_Type.Value_Type
from project.Errors import Conversion_Failure, Floating_Point_Equality, Inexact_Type_Coercion, Invalid_Column_Names, Invalid_Value_Type, No_Index_Set_Error
from project.Internal.Column_Format import all
from project.Internal.Java_Exports import make_date_builder_adapter, make_string_builder
from project.Internal.Storage import enso_to_java, java_to_enso

polyglot java import org.enso.base.Time_Utils
polyglot java import org.enso.table.data.column.operation.cast.CastProblemAggregator
polyglot java import org.enso.table.data.column.operation.CountNothing
polyglot java import org.enso.table.data.column.operation.unary.DatePartOperation
polyglot java import org.enso.table.data.column.operation.unary.IsEmptyOperation
polyglot java import org.enso.table.data.column.operation.unary.IsFiniteOperation
polyglot java import org.enso.table.data.column.operation.unary.IsInfiniteOperation
polyglot java import org.enso.table.data.column.operation.unary.IsNaNOperation
polyglot java import org.enso.table.data.column.operation.unary.IsNothingOperation
polyglot java import org.enso.table.data.column.operation.unary.NotOperation
polyglot java import org.enso.table.data.column.operation.unary.TextLengthOperation
polyglot java import org.enso.table.data.column.operation.unary.TruncatedTimePartOperation
polyglot java import org.enso.table.data.column.operation.unary.UnaryRoundOperation
polyglot java import org.enso.table.data.column.operation.UnaryOperation
polyglot java import org.enso.table.data.column.storage.Storage as Java_Storage
polyglot java import org.enso.table.data.mask.OrderMask
polyglot java import org.enso.table.data.table.Column as Java_Column
polyglot java import org.enso.table.error.ValueTypeMismatchException
polyglot java import org.enso.table.operations.OrderBuilder
polyglot java import org.enso.table.parsing.problems.ParseProblemAggregator

type Column
    ## GROUP Standard.Base.Input
       ICON data_input
       Creates a new column given a name and a vector of elements.

       Arguments:
       - name: The name of the column to create.
       - items: The elements to contain in the column.
       - value_type: The type of the values in the column. If `Auto`, the type
         will be inferred from the items in the column.

       ! Error Conditions

         - If some values in `items` do not match the `value_type`, an
           `Invalid_Value_Type` error is raised.
         - With the default `value_type` of `Auto`, no errors should occur.

       > Example
         Create a new column called "My Column" from a vector of numbers.

             from Standard.Table import Column

             example_from_vector =
                 Column.from_vector "My Column" [1, 2, 3, 4, 5]
    from_vector : Text -> Vector -> Auto | Value_Type -> Column ! Invalid_Value_Type
    from_vector (name : Text) (items : Vector) (value_type : Auto | Value_Type = Auto) =
        ## If the type does not accept date-time-like values, we can skip the
           additional logic for polyglot conversions that would normally be used,
           which is quite costly - so if we can guarantee it is unnecessary,
           it is good to skip it.
        needs_polyglot_conversion = case value_type of
            Value_Type.Char _ _  -> False
            Value_Type.Float _   -> False
            Value_Type.Integer _ -> False
            Value_Type.Boolean   -> False
            Value_Type.Byte      -> False
            _                    -> True
        needs_enso_to_java_conversion = case value_type of
            Value_Type.Decimal _ _ -> True
            Auto                   -> True
            _                      -> False
        enso_to_java_maybe items = if needs_enso_to_java_conversion.not then items else
            items.map enso_to_java
        expected_storage_type = case value_type of
            Auto -> Nothing
            _ -> Storage.from_value_type value_type on_problems=Problem_Behavior.Report_Warning
        raise_invalid_value_type_error problematic_value =
            expected_type = value_type
            actual_type = Value_Type_Helpers.most_specific_value_type problematic_value use_smallest=True
            Error.throw (Invalid_Value_Type.Value expected_type actual_type problematic_value)
        handle_invalid_value_type ~action = Panic.catch ValueTypeMismatchException action caught_panic->
            java_exception = caught_panic.payload
            raise_invalid_value_type_error java_exception.getValue
        Invalid_Column_Names.handle_java_exception <| Polyglot_Helpers.handle_polyglot_dataflow_errors <| handle_invalid_value_type <|
            java_column = Java_Problems.with_problem_aggregator Problem_Behavior.Report_Warning java_problem_aggregator->
                case needs_polyglot_conversion of
                    True -> Java_Column.fromItems name (enso_to_java_maybe items) expected_storage_type java_problem_aggregator
                    False -> Java_Column.fromItemsNoDateConversion name items expected_storage_type java_problem_aggregator
            result = Column.Value java_column . throw_on_warning Conversion_Failure
            result.catch Conversion_Failure error->
                if error.example_values.is_empty then result else
                    raise_invalid_value_type_error error.example_values.first

    ## PRIVATE
       Creates a new column given a name and an internal Java storage.
    from_storage : Text -> Java_Storage -> Column
    from_storage name storage =
        Invalid_Column_Names.handle_java_exception <|
            Column.Value (Java_Column.new name storage)

    ## PRIVATE
       ADVANCED
       Creates a new column given a name and an element repeated over and over.

       Arguments:
       - name: The name of the column to create.
       - item: The element to repeat in the column.
       - repeats: The number of times to repeat the element.
    from_repeated_item : Text -> Any -> Integer -> Column
    from_repeated_item name item repeats =
        Invalid_Column_Names.handle_java_exception <| Illegal_Argument.handle_java_exception <|
            java_column = Java_Problems.with_problem_aggregator Problem_Behavior.Report_Warning java_problem_aggregator->
                Java_Column.fromRepeatedItem name item repeats java_problem_aggregator
            Column.Value java_column

    ## PRIVATE

       A representation of a column in a Table.

       Arguments:
       - java_column: The internal representation of the column.
    private Value java_column

    ## PRIVATE
       ADVANCED
       Returns a text containing an ASCII-art table displaying this data.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.
       - format_terminal: whether ANSI-terminal formatting should be used

       > Example
         Convert a column to a pretty-printed text representation.

             import Standard.Examples

             example_display = Examples.integer_column.display
    display : Integer -> Boolean -> Text
    display self show_rows=10 format_terminal=False =
        self.to_table.display show_rows format_terminal

    ## PRIVATE
       ADVANCED

       Prints an ASCII-art table with this data to the standard output.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.

       > Example
         Convert a column to a pretty-printed text representation and print it
         to the console.

             import Standard.Examples

             example_display = Examples.integer_column.print
    print : Integer -> Nothing
    print self show_rows=10 =
        IO.println (self.display show_rows format_terminal=True)
        IO.println ''

    ## ALIAS equals
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       ! Error Conditions

         - If this operation results in comparing floating-point values for
           equality which is not recommended, a `Floating_Point_Equality`
           warning is attached to the result.

       > Example
         Compare two columns for pairwise equality.

             import Standard.Examples

             example_eq = Examples.integer_column == Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_eq = Examples.integer_column == 1
    == : Column | Any -> Column
    == self other =
        new_name = naming_helper.binary_operation_name "==" self other
        fallback problem_builder a b =
            if (a.is_a Float) || (b.is_a Float) then
                problem_builder.reportFloatingPointEquality -1
            a == b
        run_vectorized_binary_op_with_fallback_problem_handling self Java_Storage.Maps.EQ other fallback_fn=fallback new_name=new_name expected_result_type=Value_Type.Boolean skip_nulls=True

    ## GROUP Standard.Base.Logical
       ICON operators
       Element-wise case-insensitive text equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.
       - locale: The locale to use for the case-insensitive comparison.

       Returns a column with results of comparing this column's elements against
       `other`.
    @locale Locale.default_widget
    equals_ignore_case : Column | Any -> Locale -> Column
    equals_ignore_case self other locale:Locale=Locale.default =
        ## TODO currently this always runs the fallback which is slow due to the
           cost of Java-to-Enso calls. We want to have a vectorized
           implementation, but we need to extend the architecture to allow
           passing the locale to it.
           See: https://github.com/enso-org/enso/issues/5250
        fallback x y =
            x.equals_ignore_case y locale=locale
        Value_Type.expect_text self <|
            Value_Type.expect_text other <|
                new_name = naming_helper.function_name "equals_ignore_case" [self, other]
                run_binary_op self fallback other new_name expected_result_type=Value_Type.Boolean

    ## ALIAS not equals
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise non-equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       ! Error Conditions

         - If this operation results in comparing floating-point values for
           equality which is not recommended, a `Floating_Point_Equality`
           warning is attached to the result.

       > Example
         Compare two columns for pairwise inequality.

             import Standard.Examples

             example_neq = Examples.integer_column != Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_neq = Examples.integer_column != 1
    != : Column | Any -> Column
    != self other =
        new_name = naming_helper.binary_operation_name "!=" self other
        (self == other).not . rename new_name

    ## ALIAS greater than or equal
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise order comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       > Example
         Compare two columns for pairwise greater-than-or-equal.

             import Standard.Examples

             example_geq = Examples.integer_column >= Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_geq = Examples.integer_column >= 1
    >= : Column | Any -> Column
    >= self other = Value_Type.expect_comparable self other <|
        Incomparable_Values.handle_errors <|
            run_vectorized_binary_op self Java_Storage.Maps.GTE fallback_fn=(>=) other expected_result_type=Value_Type.Boolean

    ## ALIAS less than or equal
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise order comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       > Example
         Compare two columns for pairwise less-than-or-equal.

             import Standard.Examples

             example_leq = Examples.integer_column <= Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_leq = Examples.integer_column <= 1
    <= : Column | Any -> Column
    <= self other = Value_Type.expect_comparable self other <|
        Incomparable_Values.handle_errors <|
            run_vectorized_binary_op self Java_Storage.Maps.LTE fallback_fn=(<=) other expected_result_type=Value_Type.Boolean

    ## ALIAS greater than
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise order comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       > Example
         Compare two columns for pairwise greater-than.

             import Standard.Examples

             example_gt = Examples.integer_column > Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_gt = Examples.integer_column > 1
    > : Column | Any -> Column
    > self other = Value_Type.expect_comparable self other <|
        Incomparable_Values.handle_errors <|
            run_vectorized_binary_op self Java_Storage.Maps.GT fallback_fn=(>) other expected_result_type=Value_Type.Boolean

    ## ALIAS less than
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise order comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       > Example
         Compare two columns for pairwise less-than.

             import Standard.Examples

             example_lt = Examples.integer_column < Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_lt = Examples.integer_column < 1
    < : Column | Any -> Column
    < self other = Value_Type.expect_comparable self other <|
        Incomparable_Values.handle_errors <|
            run_vectorized_binary_op self Java_Storage.Maps.LT fallback_fn=(<) other expected_result_type=Value_Type.Boolean

    ## GROUP Standard.Base.Logical
       ICON operators
       Element-wise inclusive bounds check.

       Arguments:
       - lower: The lower bound to compare elements of `self` against. If
         `lower` is a column, the comparison is performed pairwise between
         corresponding elements of `self` and `lower`.
       - upper: The upper bound to compare elements of `self` against. If
         `upper` is a column, the comparison is performed pairwise between
         corresponding elements of `self` and `upper`.

       Returns a column with boolean values indicating whether values of this
       column fit between the lower and upper bounds (both ends inclusive).
    between : (Column | Any) -> (Column | Any) -> Column
    between self lower upper =
        Value_Type.expect_comparable self lower <|
            Value_Type.expect_comparable self upper <|
                new_name = naming_helper.concat <|
                    [naming_helper.to_expression_text self, "between", naming_helper.to_expression_text lower, "and", naming_helper.to_expression_text upper]
                result = (self >= lower) && (self <= upper)
                result.rename new_name

    ## ALIAS add, concatenate, plus
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise addition. Works on numeric types or text.

       Arguments:
       - other: The value to add to `self`. If `other` is a column, the addition
         is performed pairwise between corresponding elements of `self` and
         `other`.

       Returns a column with results of adding `other` from each element of
       `self`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.

       > Example
         Add two columns to each other.

             import Standard.Examples

             example_plus = Examples.decimal_column + Examples.integer_column

       > Example
         Add a single value to each item in a column.

             import Standard.Examples

             example_plus = Examples.integer_column + 10
    + : Column | Any -> Column
    + self other =
        Value_Type_Helpers.resolve_addition_kind self other . if_not_error <|
            run_vectorized_binary_op self Java_Storage.Maps.ADD other

    ## ALIAS minus, subtract
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise subtraction. Allows to subtract numeric types or compute a
       difference between two date/time values.

       Arguments:
       - other: The value to subtract from `self`. If `other` is a column, the
         subtraction is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of subtracting `other` from each element of
       `self`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.

       > Example
         Subtract one column from another.

             import Standard.Examples

             example_minus = Examples.decimal_column - Examples.integer_column

       > Example
         Subtract a single value from each item in a column.

             import Standard.Examples

             example_minus = Examples.integer_column - 10
    - : Column | Any -> Column
    - self other =
        case Value_Type_Helpers.resolve_subtraction_kind self other of
            Value_Type_Helpers.Subtraction_Kind.Numeric_Subtract ->
                run_vectorized_binary_op self Java_Storage.Maps.SUB other
            Value_Type_Helpers.Subtraction_Kind.Date_Time_Difference ->
                case self.inferred_precise_value_type of
                    Value_Type.Date ->
                        ## Special handling for `Period` since it is hard to
                           vectorize as there is no polyglot handling of it - we
                           _wrap_ a Java object and the Java wrapper will always
                           be an Enso callback, at which point its better to do
                           the whole operation in pure Enso.
                        fn = x-> y-> Period.between y x
                        new_name = naming_helper.binary_operation_name "-" self other
                        run_binary_op self fn other new_name
                    _ ->
                        run_vectorized_binary_op self Java_Storage.Maps.SUB other

    ## ALIAS multiply, product, times
       GROUP Standard.Base.Operators
       ICON math
       Element-wise multiplication.

       Arguments:
       - other: The value to multiply `self` by. If `other` is a column, the
         multiplication is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column containing the result of multiplying each element of
       `self` by `other`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.

       > Example
         Multiply the elements of two columns together.

             import Standard.Examples

             example_mul = Examples.decimal_column * Examples.integer_column

       > Example
         Multiply each value in a column by a single value.

             import Standard.Examples

             example_mul = Examples.integer_column * 10
    * : Column | Any -> Column
    * self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            run_vectorized_binary_op self Java_Storage.Maps.MUL other

    ## ALIAS divide
       GROUP Standard.Base.Operators
       ICON math
       Element-wise division.

       Arguments:
       - other: The value to divide `self` by. If `other` is a column, the
         division is performed pairwise between corresponding elements of `self`
         and `other`.

       Returns a column containing the result of dividing each element of `self`
       by `other`.

       ! Error Conditions

         - If division by zero occurs, an `Arithmetic_Error` warning is attached
           to the result.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.

       > Example
         Divide the elements of one column by the elements of another.

             import Standard.Examples

             example_div = Examples.decimal_column / Examples.integer_column

       > Example
         Multiply each value in a column by a single value.

             import Standard.Examples

             example_div = Examples.integer_column / 10
    / : Column | Any -> Column
    / self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            new_name = naming_helper.binary_operation_name "/" self other
            run_vectorized_binary_op self Java_Storage.Maps.DIV other new_name

    ## ALIAS modulo, modulus
       GROUP Standard.Base.Operators
       ICON math
       Element-wise modulus.

       Arguments:
       - other: The value to modulo `self` against. If `other` is a column, the
         modulus is performed pairwise between corresponding elements of `self`
         and `other`.

       Returns a column with results of modulus this column's elements against
       `other`.

       ! Error Conditions

         - If division by zero occurs, an `Arithmetic_Error` warning is attached
           to the result.

       > Example
         Modulus of two columns against each other.

             import Standard.Examples

             example_mod = Examples.integer_column % Examples.decimal_column

       > Example
         Modulus of a column with a number.

             import Standard.Examples

             example_mod = Examples.integer_column % 3
    % : Column | Any -> Column
    % self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            new_name = naming_helper.binary_operation_name "%" self other
            run_vectorized_binary_op self Java_Storage.Maps.MOD other new_name

    ## ALIAS power
       GROUP Standard.Base.Operators
       ICON math
       Element-wise raising to the power.

       Arguments:
       - other: The exponent to raise `self` by. If `other` is a column, the
         power operation is performed pairwise between corresponding elements
         of `self` and `other`.

       Returns a column containing the result of raising each element of `self`
       by `other`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.

       > Example
         Squares the elements of one column.

             import Standard.Examples

             example_div = Examples.decimal_column ^ 2

       > Example
         Raises each value in a column by the value in another column.

             import Standard.Examples

             example_div = Examples.decimal_column ^ Examples.integer_column
    ^ : Column | Any -> Column
    ^ self other =
        Illegal_Argument.handle_java_exception <|
            Value_Type_Helpers.check_binary_numeric_op self other <|
                run_vectorized_binary_op self Java_Storage.Maps.POWER other

    ## ALIAS and
       GROUP Standard.Base.Operators
       ICON operators
       Element-wise boolean conjunction.

       Arguments:
       - other: The value to compute the conjunction of `self` with. If `other`
         is a column, the conjunction is performed pairwise between
         corresponding elements of `self` and `other`.

       Returns a column containing the result of performing boolean `and` on
       each element of `self` and `other`.

       > Example
         Compute the pairwise logical conjunction to two columns.

             import Standard.Examples

             example_and = Examples.bool_column_1 && Examples.bool_column_2

       > Example
         Compute the logical conjunction of each value in a column with a single
         value.

             import Standard.Examples

             example_and = Examples.bool_column_1 && True
    && : Column | Any -> Column
    && self other =
        Value_Type_Helpers.check_binary_boolean_op self other <|
            run_vectorized_binary_op self Java_Storage.Maps.AND other

    ## ALIAS or
       GROUP Standard.Base.Operators
       ICON operators

       Element-wise boolean disjunction.

       Arguments:
       - other: The value to compute the disjunction of `self` with. If `other`
         is a column, the disjunction is performed pairwise between
         corresponding elements of `self` and `other`.

       Returns a column containing the result of performing the boolean `or` on
       each element of `self` and `other`.

       > Example
         Compute the pairwise logical disjunction to two columns.

             import Standard.Examples

             example_or = Examples.bool_column_1 || Examples.bool_column_2

       > Example
         Compute the logical disjunction of each value in a column with a single
         value.

             import Standard.Examples

             example_or = Examples.bool_column_1 || True
    || : Column | Any -> Column
    || self other =
        Value_Type_Helpers.check_binary_boolean_op self other <|
           run_vectorized_binary_op self Java_Storage.Maps.OR other

    ## ALIAS not
       GROUP Standard.Base.Logical
       ICON operators

       Boolean negation of each element in self column.

       > Example
         Negate the elements of a column.

             import Standard.Examples

             example_not = Examples.bool_column_1.not
    not : Column
    not self =
        Value_Type.expect_boolean self <|
            new_name = naming_helper.concat ["not", naming_helper.to_expression_text self]
            apply_unary_operation self NotOperation.INSTANCE new_name

    ## ALIAS if
       GROUP Standard.Base.Logical
       ICON preparation

       Replaces `True` values with `when_true` and `False` with `when_false`.
       Only meant for use with boolean columns.

       Arguments:
       - when_true: value or column when `self` is `True`.
       - when_false: value or column when `self` is `False`.

       > Example
         If the value in a column is `True`, replace it with `1`, otherwise `0`.

             import Standard.Examples

             example_if = Examples.bool_column_1.iif 1 0
    iif : Any -> Any -> Column
    iif self when_true when_false =
        Value_Type.expect_boolean self <|
            common_type = Value_Type_Helpers.find_common_type_for_arguments [when_true, when_false] . if_nothing Value_Type.Mixed
            storage_type = Storage.from_value_type_strict common_type
            storage_type.if_not_error <|
                new_name = naming_helper.concat <|
                    ["if", naming_helper.to_expression_text self, "then", naming_helper.to_expression_text when_true, "else", naming_helper.to_expression_text when_false]
                # Even if we have a MixedStorage with inferred type Bool, we ensure that the effective storage is BoolStorage, only one that supports iif.
                s = self.java_column.getStorage.tryGettingMoreSpecializedStorage

                true_val = case when_true of
                    _ : Column -> when_true.java_column.getStorage
                    _ -> when_true

                false_val = case when_false of
                    _ : Column -> when_false.java_column.getStorage
                    _ -> when_false

                handle_no_iif caught_panic =
                    if Meta.meta caught_panic.payload.symbol . name != "iif" then Panic.throw caught_panic else
                        error = Illegal_State.Error "`iif` got a storage "+s.to_display_text+" that does not support the `iif` operation. This is a bug in the Table library."
                        Panic.throw error
                rs = Panic.catch No_Such_Method handler=handle_no_iif <|
                    Java_Problems.with_problem_aggregator Problem_Behavior.Report_Warning java_problem_aggregator->
                        s.iif true_val false_val storage_type java_problem_aggregator
                Column.Value (Java_Column.new new_name rs)

    ## PRIVATE

       Creates a column from a single constant value.

       This method is not static; it must be called on an existing column. That
       existing column is only used for its internal state; the contents of the
       column are not used.

       Arguments:
       - value: the constant value to use for the entire column.

       > Example
         Create a column of the value 42

         column.const 42
    const : Any -> Column
    const self value = self.to_table.make_constant_column value

    ## GROUP Standard.Base.Math
       ICON math
       Round the values in a numeric column to a specified number of decimal
       places.

       For integers, rounding to 0 or more decimal places simply returns the
       argument. For negative decimal places, see below.

       By default, rounding uses "asymmetric round-half-up", also known as
       "round towards positive infinity." If use_bankers=True, then it uses
       "round-half-even", also known as "banker's rounding".

       If the column is of type `Float` and `decimal_places` > 0, `round`
       returns a column of `Float`; otherwise, it returns a column of
       `Integer`.

       Arguments:
       - decimal_places: The number of decimal places to round to. Can be
         negative, which results in rounding to positive integer powers of 10.
         Must be between -15 and 15 (inclusive).
       - use_bankers: Rounds mid-point to nearest even number.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

       ! Error Conditions
         Reports `Illegal_Argument` if the number is 15 or more decimal places.
         Above 14 digits, it is possible that the underlying long, converted to
         double in the rounding process, would lose precision in the least
         significant bits.
         (See https://en.wikipedia.org/wiki/Double-precision_floating-point_format.)

         If `decimal_places` is outside the range -15..15 (inclusive), an
         `Illegal_Argument` error is thrown.

       ! Precision
         As floating-point numbers are inexact, rounding can have unexpected
         results near the precision limit (about 15 decimal places), especially
         when rounding mid-point values. For example:

         Rounding 1.2222222222222235 to 15 decimal places returns:
         - 1.222222222222224 in Postgres.
         - 1.222222222222223 in SQLite.

       ? Negative decimal place counts
         Rounding to `n` digits can be thought of as "rounding to the nearest
         multiple of 10^(-n)". For negative decimal counts, this results in
         rounding to the nearest positive integer power of 10.

       > Example
         Round a column of `Float` values`.

             Column.from_vector "foo" [1.2, 2.3, 3.6] . round == (Column.from_vector "foo" [1, 2, 4])
    round : Integer -> Boolean -> Column | Illegal_Argument | Invalid_Value_Type
    round self (decimal_places:Integer = 0) (use_bankers:Boolean = False) = Value_Type.expect_numeric self <|
        Illegal_Argument.handle_java_exception <| Rounding_Helpers.check_decimal_places decimal_places <|
            new_name = naming_helper.function_name "round" [self]
            run_vectorized_ternary_op self Java_Storage.Maps.ROUND decimal_places use_bankers new_name=new_name

    ## ALIAS int
       GROUP Standard.Base.Rounding
       ICON math

       If the column is numeric, truncate the floating-point values to an
       integer by dropping the fractional part. This is equivalent to
       "round-toward-zero". If the column is of type `Date_Time`, truncates the
       values to `Date`.

       > Example
         Truncate a column of `Float` values.

             Column.from_vector "foo" [1.25, 2.33, 3.57] . truncate == (Column.from_vector "foo" [1, 2, 3])

       > Example
         Truncate a column of `Date_Time` values.
            date_times = Column.from_vector "foo" [Date_Time.new 2020 10 24 1 2 3, Date_Time.new 2020 10 24 1 2 3]
            dates = Column.from_vector "foo" [Date.new 2020 10 24, Date.new 2020 10 24]
            col.truncate == dates
    truncate : Column ! Invalid_Value_Type
    truncate self =
        new_name = naming_helper.function_name "truncate" [self]
        precise_value_type = self.inferred_precise_value_type
        case precise_value_type.is_numeric of
            True ->
                case precise_value_type.is_integer of
                    True ->
                        self.rename new_name
                    False ->
                        apply_unary_operation self UnaryRoundOperation.TRUNCATE_INSTANCE
            False -> case precise_value_type == Value_Type.Date_Time of
                True ->
                    fun = _.date
                    Column_Ops.map_over_storage self fun make_date_builder_adapter skip_nothing=True . rename new_name
                False -> Error.throw <| Invalid_Value_Type.Column "Numeric or Date_Time" self.value_type self.name

    ## GROUP Standard.Base.Rounding
       ICON math
       Computes the nearest integer above this number for values in a numeric
       column.

       Returns a column of `Integer`.

       > Example
         Take the ceiling of a column of `Float` values.

             Column.from_vector "foo" [1.25, 2.33, 3.57] . ceil == (Column.from_vector "foo" [2, 3, 4])
    ceil : Column ! Invalid_Value_Type
    ceil self = Value_Type.expect_numeric self <|
        case self.inferred_precise_value_type.is_integer of
            True ->
                new_name = naming_helper.function_name "ceil" [self]
                self.rename new_name
            False ->
                apply_unary_operation self UnaryRoundOperation.CEIL_INSTANCE

    ## GROUP Standard.Base.Rounding
       ICON math
       Computes the nearest integer below this number for values in a numeric
       column.

       Returns a column of `Integer`.

       > Example
         Take the floor of a column of `Float` values.

             Column.from_vector "foo" [1.25, 2.33, 3.57] . floor == (Column.from_vector "foo" [1, 2, 3])
    floor : Column ! Invalid_Value_Type
    floor self = Value_Type.expect_numeric self <|
        case self.inferred_precise_value_type.is_integer of
            True ->
                new_name = naming_helper.function_name "floor" [self]
                self.rename new_name
            False ->
                apply_unary_operation self UnaryRoundOperation.FLOOR_INSTANCE

    ## GROUP Standard.Base.Logical
       ICON operators
       Returns a column of first non-`Nothing` value on each row of `self` and
       `values` list.

       Arguments:
       - values: list of columns or values to coalesce with `self`.

       > Example
         Get the first non-`Nothing` value in two columns.

             import Standard.Examples

             example_coalesce = Examples.decimal_column.coalesce Examples.integer_column
    coalesce : (Any | Vector Any) -> Column
    coalesce self values =
        vec = Vector.unify_vector_or_element values
        new_name = self.naming_helper.function_name "coalesce" [self]+vec
        result = if vec.is_empty then self else
            vec.fold self acc-> v-> acc.fill_nothing v
        result.rename new_name

    ## GROUP Standard.Base.Math
       ICON transform4
       Returns a column of minimum on each row of `self` and `values`.

       Arguments:
       - values: list of columns or values to minimum with `self`, or a single
         column or value.

       > Example
         Get the minimum value in two columns.

             import Standard.Examples

             example_min = Examples.decimal_column.min Examples.integer_column
    min : (Any | Vector Any) -> Column
    min self values =
        fallback a b = if a.is_nothing then b else
            if b.is_nothing then a else
                if b < a then b else a
        Value_Type_Helpers.check_multi_argument_comparable_op self values <|
            run_vectorized_many_op self "min" fallback values

    ## GROUP Standard.Base.Math
       ICON transform4
       Returns a column of maximum on each row of `self` and `values`.

       Arguments:
       - values: list of columns or values to maximum with `self`, or a single
         column or value.

       > Example
         Get the maximum value in two columns.

             import Standard.Examples

             example_max = Examples.decimal_column.max Examples.integer_column
    max : (Any | Vector Any) -> Column
    max self values =
        fallback a b = if a.is_nothing then b else
            if b.is_nothing then a else
                if b > a then b else a
        Value_Type_Helpers.check_multi_argument_comparable_op self values <|
            run_vectorized_many_op self "max" fallback values

    ## GROUP Standard.Base.Logical
       ICON preparation
       Returns a column of booleans, with `True` items at the positions where
       this column contains a `Nothing`.

       > Example
         Check a column for missing values.

             import Standard.Examples

             example_is_nothing = Examples.decimal_column.is_nothing
    is_nothing : Column
    is_nothing self =
        new_name = naming_helper.concat [naming_helper.to_expression_text self, "is Nothing"]
        apply_unary_operation self IsNothingOperation.INSTANCE new_name

    ## GROUP Standard.Base.Math
       ICON math
       Returns a column of booleans, with `True` items at the positions where
       this column contains a NaN. This is only applicable to double columns.
    is_nan : Column
    is_nan self = Value_Type.expect_numeric self <|
        self.internal_is_nan

    ## PRIVATE
    internal_is_nan : Column
    internal_is_nan self =
        new_name = naming_helper.function_name "is_nan" [self]
        fallback x = case x of
            _ : Float   -> x.is_nan
            _           -> False
        apply_unary_operation self IsNaNOperation.INSTANCE new_name if_unsupported=(apply_unary_map self new_name fallback Value_Type.Boolean)

    ## GROUP Standard.Base.Math
       ICON math
       Returns a column of booleans, with `True` items at the positions where
       this column contains a +Inf/-Inf. This is only applicable to double
       columns.
    is_infinite : Column
    is_infinite self = Value_Type.expect_numeric self <|
        new_name = naming_helper.function_name "is_infinite" [self]
        fallback x = case x of
            _ : Float   -> x.is_infinite
            _           -> False
        apply_unary_operation self IsInfiniteOperation.INSTANCE new_name if_unsupported=(apply_unary_map self new_name fallback Value_Type.Boolean)

    ## GROUP Standard.Base.Math
       ICON math
       Returns a column of booleans, with `True` items at the positions where
       this column contains a non-infinite, non-NaN floating point value. This
       is only applicable to double columns.
    is_finite : Column
    is_finite self = Value_Type.expect_numeric self <|
        new_name = naming_helper.function_name "is_finite" [self]
        fallback x = case x of
            _ : Float   -> x.is_finite
            _           -> True
        apply_unary_operation self IsFiniteOperation.INSTANCE new_name if_unsupported=(apply_unary_map self new_name fallback Value_Type.Boolean)

    ## PRIVATE
       Returns a column of booleans, with `True` items at the positions where
       this column contains an empty string or `Nothing`.
    is_empty : Column
    is_empty self = Value_Type.expect_text self <|
        self.internal_is_empty

    ## PRIVATE
    internal_is_empty : Column
    internal_is_empty self =
        new_name = naming_helper.concat [naming_helper.to_expression_text self, "is empty"]
        fallback x = case x of
            _ : Text -> x == ""
            Nothing  -> True
            _        -> False
        apply_unary_operation self IsEmptyOperation.INSTANCE new_name if_unsupported=(apply_unary_map self new_name fallback Value_Type.Boolean nothing_unchanged=False)

    ## GROUP Standard.Base.Logical
       ICON preparation
       Returns a column of booleans, with `True` items at the positions where
       this column does not contain a `Nothing`.

       > Example
         Check a column for present values.

             import Standard.Examples

             example_is_present = Examples.decimal_column.is_present
    is_present : Column
    is_present self =
        new_name = naming_helper.function_name "is_present" [self]
        self.is_nothing.not.rename new_name

    ## PRIVATE
       Returns a column of booleans with `True` at the positions where this
       column contains a blank value.

       Arguments:
       - treat_nans_as_blank: If `True`, then `Number.nan` is considered as
         blank.

       ? Blank values
         Blank values are `Nothing`, `""` and depending on setting `Number.nan`.
    is_blank : Boolean -> Column
    is_blank self treat_nans_as_blank=False =
        new_name = naming_helper.function_name "is_blank" [self]
        result = case self.value_type of
            Value_Type.Char _ _ -> self.is_empty
            Value_Type.Float _ ->
                if treat_nans_as_blank then self.is_nothing.iif True self.internal_is_nan else self.is_nothing
            Value_Type.Mixed ->
                self.internal_is_empty || (if treat_nans_as_blank then self.is_nothing.iif True self.internal_is_nan else self.is_nothing)
            _ -> self.is_nothing
        result.rename new_name

    ## ALIAS fill missing, if_nothing
       GROUP Standard.Base.Values
       ICON column_add

       Returns a new column where missing values have been replaced with the
       provided default.

       Arguments:
       - default: The value to replace missing values with. If this argument
         is a column, the value from `default` at the corresponding position
         will be used. If this argument is `Previous_Value`, the missing values
         will be replaced with the previous value in the column. Note that the
         first rows may stay `Nothing` if they do not have a previous value to
         use.

       > Example
         Fill missing values in a column with the value 20.5.

             import Standard.Examples

             example_fill_nothing = Examples.decimal_column.fill_nothing 20.5
    @default (self-> Widget_Helpers.make_fill_default_value_selector value_types=self.value_type)
    fill_nothing : Column | Previous_Value | Any -> Column
    fill_nothing self default =
        if Previous_Value == default then fill_previous self Nothing else
            common_type = Value_Type_Helpers.find_common_type_for_arguments [self, default]
            common_type.if_not_error <|
                storage = self.java_column.getStorage
                storage_type = Storage.from_value_type_strict common_type
                new_storage = Java_Problems.with_problem_aggregator Problem_Behavior.Report_Warning java_problem_aggregator->
                    case default of
                        Column.Value java_col ->
                            other_storage = java_col.getStorage
                            storage.fillMissingFrom other_storage storage_type java_problem_aggregator
                        _ ->
                            storage.fillMissing default storage_type java_problem_aggregator
                Column.Value (Java_Column.new self.name new_storage)

    ## ALIAS fill empty, if_empty
       GROUP Standard.Base.Values
       ICON column_add

       Returns a new column where empty Text values have been replaced with the
       provided default.

       Arguments:
       - default: The value to replace empty values with. If this argument
         is a column, the value from `default` at the corresponding position
         will be used. If this argument is `Previous_Value`, the empty values
         will be replaced with the previous value in the column. Note that the
         first rows may stay empty if they do not have a previous value to use.

       > Example
         Fill empty values in a column with the value "hello".

             import Standard.Examples

             example_fill_empty = Examples.text_column_1.fill_empty "hello"
    @default (self-> Widget_Helpers.make_fill_default_value_selector value_types=Value_Type.Char add_nothing=True)
    fill_empty : Column | Previous_Value | Any -> Column
    fill_empty self default =
        Value_Type.expect_text self <|
            if Previous_Value == default then fill_previous self self.is_empty else
                Value_Type.expect_text default <|
                    result = self.is_empty.iif default self
                    result.rename self.name

    ## GROUP Standard.Base.Text
       ICON preparation
       Checks for each element of the column if it starts with `other`.

       Arguments:
       - other: The value to compare `self` with. If `other` is a column, the
         operation is performed pairwise between corresponding elements of
         `self` and `other`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       > Example
         Check the elements of a column for starting with the elements of
         another column.

             import Standard.Examples

             example_starts_with =
                Examples.text_column_1.starts_with Examples.text_column_2

       > Example
         Check the elements of a column for starting with a value.

             import Standard.Examples

             example_starts_with = Examples.text_column_1.starts_with "hell"

       > Example
         Check the elements of a column for starting with a value comparing case insensitively.

             import Standard.Examples

             example_starts_with = Examples.text_column_1.starts_with "hell" Case_Sensitivity.Insensitive
    starts_with : Column | Text -> Case_Sensitivity -> Column
    starts_with self other case_sensitivity:Case_Sensitivity=..Default =
        new_name = naming_helper.function_name "starts_with" [self, other]
        run_vectorized_binary_case_text_op self Java_Storage.Maps.STARTS_WITH other case_sensitivity (a -> b -> a.starts_with b case_sensitivity) new_name

    ## GROUP Standard.Base.Text
       ICON preparation
       Checks for each element of the column if it ends with `other`.

       Arguments:
       - other: The value to compare `self` with. If `other` is a column, the
         operation is performed pairwise between corresponding elements of
         `self` and `other`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       > Example
         Check the elements of a column for ending with the elements of another
         column.

             import Standard.Examples

             example_ends_with =
                Examples.text_column_1.ends_with Examples.text_column_2

       > Example
         Check the elements of a column for ending with a value.

             import Standard.Examples

             example_ends_with = Examples.text_column_1.ends_with "hell"
    ends_with : Column | Text -> Case_Sensitivity -> Column
    ends_with self other case_sensitivity:Case_Sensitivity=..Default =
        new_name = naming_helper.function_name "ends_with" [self, other]
        run_vectorized_binary_case_text_op self Java_Storage.Maps.ENDS_WITH other case_sensitivity (a -> b -> a.ends_with b case_sensitivity) new_name

    ## GROUP Standard.Base.Text
       ICON preparation
       Calculates the text length for each element of the column.

       In the Database backends, the default text length method of the
       particular database is used.

       In the in-memory backend, this will give you the grapheme length of the string.

       > Example
             import Standard.Examples

             example_text_length =
                Examples.text_column_1.text_length
    text_length : Column
    text_length self =
        Value_Type.expect_text self <|
            apply_unary_operation self TextLengthOperation.INSTANCE

    ## GROUP Standard.Base.Text
       ICON preparation
       Gets the left n characters for each element of the column.

       In the Database backends, the default text left method of the
       particular database is used.

       In the in-memory backend, this will give you the left n graphemes of the string.

       > Example
             import Standard.Examples

             example_text_length =
                Examples.text_column_1.text_left 5
    text_left : Column|Integer -> Column
    text_left self n =
        Value_Type.expect_text self <|
            Value_Type.expect_integer n <|
                new_name = naming_helper.function_name "text_left" [self, n]
                run_vectorized_binary_op self Java_Storage.Maps.TEXT_LEFT n new_name

    ## GROUP Standard.Base.Text
       ICON preparation
       Gets the right n characters for each element of the column.

       In the Database backends, the default text right method of the
       particular database is used.

       In the in-memory backend, this will give you the right n graphemes of the string.

       > Example
             import Standard.Examples

             example_text_length =
                Examples.text_column_1.text_right 5
    text_right : Column|Integer -> Column
    text_right self n =
        Value_Type.expect_text self <|
            Value_Type.expect_integer n <|
                new_name = naming_helper.function_name "text_right" [self, n]
                run_vectorized_binary_op self Java_Storage.Maps.TEXT_RIGHT n new_name

    ## GROUP Standard.Base.Logical
       ICON preparation
       Checks for each element of the column if it contains `other`.

       Arguments:
       - other: The value to compare `self` with. If `other` is a column, the
         operation is performed pairwise between corresponding elements of
         `self` and `other`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       > Example
         Check the elements of a column for containing the elements of another
         column.

             import Standard.Examples

             example_contains =
                 Examples.text_column_1.contains Examples.text_column_2

       > Example
         Check the elements of a column for containing a value.

             import Standard.Examples

             example_contains = Examples.text_column_1.contains "hell"
    contains : Column | Text -> Case_Sensitivity -> Column
    contains self other case_sensitivity:Case_Sensitivity=..Default =
        new_name = naming_helper.function_name "contains" [self, other]
        run_vectorized_binary_case_text_op self Java_Storage.Maps.CONTAINS other case_sensitivity (a -> b -> a.contains b case_sensitivity) new_name

    ## GROUP Standard.Base.Logical
       ICON preparation
       Checks for each element of the column if it matches an SQL-like pattern.

       Arguments:
       - pattern: The pattern to match `self` against. If it is a column, the
         operation is performed pairwise between corresponding elements of
         `self` and that column. The pattern is an SQL-like pattern, where
         `%` matches any sequence of characters and `_` matches any single
         character.

       > Example
         Check if elements of a column start with 'F' and end with a dot.

             import Standard.Examples

             example_contains = Examples.text_column_1.like "F%."
    like : Column | Text -> Column
    like self pattern =
        Value_Type.expect_text self <|
            Value_Type.expect_text pattern <|
                run_vectorized_binary_op self Java_Storage.Maps.LIKE pattern expected_result_type=Value_Type.Boolean

    ## GROUP Standard.Base.Text
       ICON text
       This function removes the specified characters, by default any
       whitespace, from the start, the end, or both ends of the input.

       Arguments:
       - where: The location of where to trim the input. By default, this
         function trims both ends of the input.
       - what: A `Text` (or text `Column`) containing characters that should be
         removed. By default, all whitespace is removed.
    trim : Location -> Column | Text -> Column
    trim self where:Location=..Both what='' = Value_Type.expect_text self <|
        new_name = naming_helper.function_name "trim" [self]

        trim_get = wrap_text_argument_as_value_provider what

        trim_get.if_not_error <|
            trim_fn t w = if w.is_empty then t.trim where else
                t.trim where w

            self_vec = self.to_vector
            mapped = self_vec.map_with_index i->t-> trim_fn t (trim_get i)
            Column.from_vector new_name mapped

    ## GROUP Standard.Base.Text
       ICON column_add
       Replaces the first, or all occurrences of `term` with `new_text` in each
       row. If `term` is empty, the function returns the column unchanged.

       This method follows the exact replacement semantics of the
       `Text.replace` method.

       If regex is used the replacement string can contain references to groups
       matched. The following syntaxes are supported:
           $0: the entire match string
           $&: the entire match string
           $n: the nth group
           $&lt;foo&gt;: Named group `foo`

       For details on Enso's Regex syntax, see the [Help Documentation](https://help.enso.org/docs/using-enso/regular-expressions).

       Arguments:
       - term: The term to find. Can be `Text`, `Regex`, or a `Column` of
         strings.
       - replacement: The text to replace matches with.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.
       - only_first: If True, only replace the first match.

       > Example
         Replace dashes with underscores.

             column.text_replace "-" "_"

       > Example
         Remove leading and trailing spaces from cells.

             column.text_replace "^\s*(.*?)\s*$".to_regex "$1"

       > Example
         Replace texts in quotes with parentheses.

             column.text_replace '"(.*?)"'.to_regex '($1)'
    @term make_regex_text_widget
    text_replace : Text | Regex | Column -> Text | Column -> Case_Sensitivity -> Boolean -> Column
    text_replace self (term : Text | Regex | Column = "") new_text="" case_sensitivity:Case_Sensitivity=..Sensitive only_first=False =
        Value_Type.expect_text self <|
            term_fn = wrap_text_or_regex_argument_as_value_provider term
            new_text_fn = wrap_text_argument_as_value_provider new_text

            term_fn.if_not_error <| new_text_fn.if_not_error <|
                new_name = naming_helper.function_name "replace" [self, term.to_text, new_text]

                do_replace index input =
                    term = term_fn index
                    if term.is_nothing || (term.is_a Text && term.is_empty) || input.is_nothing then input else
                        replace = new_text_fn index
                        input.replace term replace case_sensitivity only_first

                length = self.length
                storage = self.java_column.getStorage

                builder = make_string_builder length
                0.up_to length . each i->
                    replaced = do_replace i (storage.getItemBoxed i)
                    builder.append replaced

                Column.from_storage new_name builder.seal

    ## GROUP Standard.Base.Text
       ICON column_add
       Applies the specified cleansings to the text in each row.

       Arguments:
       - remove: A vector of the text cleanings to remove from the text. The text cleansings are
          applied in the order they are provided. The same text cleansing can be used multiple
          times. The text cleansings are:
            - ..Leading_Whitespace: Removes all whitspace from the start of the string.
            - ..Trailing_Whitespace: Removes all whitspace from the end of the string.
            - ..Duplicate_Whitespace: Removes all duplicate whitspace from the string replacing it with the first whitespace character of the duplicated block.
            - ..All_Whitespace: Removes all whitspace from the string.
            - ..Newlines: Removes all newline characters from the string. Line Feed and Carriage Return characters are considered newlines.
            - ..Leading_Numbers: Removes all numbers from the start of the string.
            - ..Trailing_Numbers: Removes all numbers from the end of the string.
            - ..Non_ASCII: Removes all non-ascii characters from the string.
            - ..Tabs: Removes all tab characters from the string.
            - ..Letters: Removes all letters from the string.
            - ..Numbers: Removes all numbers characters from the string.
            - ..Punctuation: Removes all characters in the set ,.!?():;'" from the string.
            - ..Symbols: Removes anything that isn't letters, numbers or whitespace from the string.

       > Example
         Remove leading and trailing spaces from cells.

             column.text_cleanse [..Leading_Whitespace, ..Trailing_Whitespace]
    @remove make_data_cleanse_vector_selector
    text_cleanse : Vector Named_Pattern -> Column
    text_cleanse self remove =
      remove.map (Text_Cleanse.Value _) . fold self (current-> tc-> tc.apply current)

    ## GROUP Standard.Base.DateTime
       ICON time
       Gets the year as a number from the date stored in the column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    year : Column ! Invalid_Value_Type
    year self = Value_Type.expect_has_date self <|
        apply_unary_operation self DatePartOperation.YEAR_INSTANCE

    ## GROUP Standard.Base.DateTime
       ICON time
       Gets the month as a number (1-12) from the date stored in the column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    month : Column ! Invalid_Value_Type
    month self = Value_Type.expect_has_date self <|
        apply_unary_operation self DatePartOperation.MONTH_INSTANCE

    ## GROUP Standard.Base.DateTime
       ICON time
       Gets the day of the month as a number (1-31) from the date stored in the
       column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    day : Column ! Invalid_Value_Type
    day self = Value_Type.expect_has_date self <|
        apply_unary_operation self DatePartOperation.DAY_INSTANCE

    ## GROUP Standard.Base.DateTime
       ICON date_and_time
       Gets the day of the year as a number (1 - 366) from the date stored in
       the column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    day_of_year : Column ! Invalid_Value_Type
    day_of_year self = Value_Type.expect_has_date self <|
        apply_unary_operation self DatePartOperation.DAY_OF_YEAR_INSTANCE

    ## ALIAS weekday
       GROUP Standard.Base.DateTime
       ICON date_and_time
       Gets the weekday as a number (1 - 7) from the date stored in the column.
       Monday is 1, Tuesday is 2, ..., Sunday is 7.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    day_of_week : Column ! Invalid_Value_Type
    day_of_week self = Value_Type.expect_has_date self <|
        apply_unary_operation self DatePartOperation.DAY_OF_WEEK_INSTANCE

    ## GROUP Standard.Base.DateTime
       ICON time
       Gets the hour as a number (0-23) from the time stored in the column.

       Applies only to columns that hold the `Time_Of_Day` or `Date_Time` types.
       Returns a column of `Integer` type.
    hour : Column ! Invalid_Value_Type
    hour self = Value_Type.expect_has_time self <|
        apply_unary_operation self DatePartOperation.HOUR_INSTANCE

    ## GROUP Standard.Base.DateTime
       ICON time
       Gets the minute as a number (0-59) from the time stored in the column.

       Applies only to columns that hold the `Time_Of_Day` or `Date_Time` types.
       Returns a column of `Integer` type.
    minute : Column ! Invalid_Value_Type
    minute self = Value_Type.expect_has_time self <|
        apply_unary_operation self DatePartOperation.MINUTE_INSTANCE

    ## GROUP Standard.Base.DateTime
       ICON time
       Gets the second as an integer (0-60) from the time stored in the column.

       Applies only to columns that hold the `Time_Of_Day` or `Date_Time` types.
       Returns a column of `Integer` type.
    second : Column ! Invalid_Value_Type
    second self = Value_Type.expect_has_time self <|
        apply_unary_operation self DatePartOperation.SECOND_INSTANCE

    ## GROUP Standard.Base.DateTime
       ICON time
       Gets the date part of the date/time value.

       Returns a column of `Integer` type.
    @period Date_Time_Helpers.make_period_selector_for_column
    date_part : Date_Period | Time_Period -> Column ! Invalid_Value_Type | Illegal_Argument
    date_part self period:(Date_Period | Time_Period)=..Day =
        date_part_operation col name =
            operation = case name of
                DatePartOperation.YEAR -> DatePartOperation.YEAR_INSTANCE
                DatePartOperation.QUARTER -> DatePartOperation.QUARTER_INSTANCE
                DatePartOperation.MONTH -> DatePartOperation.MONTH_INSTANCE
                DatePartOperation.WEEK -> DatePartOperation.WEEK_INSTANCE
                DatePartOperation.DAY -> DatePartOperation.DAY_INSTANCE
                DatePartOperation.HOUR -> DatePartOperation.HOUR_INSTANCE
                DatePartOperation.MINUTE -> DatePartOperation.MINUTE_INSTANCE
                DatePartOperation.SECOND -> DatePartOperation.SECOND_INSTANCE
                DatePartOperation.MILLISECOND -> DatePartOperation.MILLISECOND_INSTANCE
                TruncatedTimePartOperation.MICROSECOND -> TruncatedTimePartOperation.MICROSECOND_INSTANCE
                TruncatedTimePartOperation.NANOSECOND -> TruncatedTimePartOperation.NANOSECOND_INSTANCE
            apply_unary_operation col operation
        Date_Time_Helpers.make_date_part_function self period date_part_operation naming_helper

    ## GROUP Standard.Base.DateTime
       ICON time
       Computes a time difference between the two dates.

       It returns a column of integers expressing how many periods fit between
       the two dates/times.

       The difference will be positive if `end` is greater than `self`.

       Arguments:
       - end: A date/time column or a date/time value to compute the difference
         from. It should have the same type as the current column, i.e. a
         `Date_Time` column cannot be compared to a `Date` - to do so you first
         need to `cast`.
       - period: The period to compute the difference in. For `Date` columns it
         should be a `Date_Period` and for `Time` columns it should be a
         `Time_Period`. For `Date_Time` columns it can be either.

       ? Time Zone handling

         Some backends may not preserve the timezone data in a `Date_Time`
         (preserving the represented time instant). This may lead to slight
         differences in time calculations between backends, especially around
         unusual events like DST.
    @period Date_Time_Helpers.make_period_selector_for_column
    date_diff : (Column | Date | Date_Time | Time_Of_Day) -> Date_Period | Time_Period -> Column ! Invalid_Value_Type | Illegal_Argument
    date_diff self end (period : Date_Period | Time_Period = ..Day) =
        Value_Type.expect_type self .is_date_or_time "date/time" <|
            my_type = self.inferred_precise_value_type
            Value_Type.expect_type end (== my_type) my_type.to_display_text <|
                aligned_period = Date_Time_Helpers.align_period_with_value_type my_type period
                aligned_period.if_not_error <|
                    new_name = naming_helper.function_name "date_diff" [self, end, period.to_display_text]
                    java_unit = aligned_period.to_java_unit
                    fn = case my_type of
                        Value_Type.Date_Time _ ->
                            start-> end-> Time_Utils.unit_datetime_difference java_unit start end
                        Value_Type.Date ->
                            start-> end-> Time_Utils.unit_date_difference java_unit start end
                        Value_Type.Time ->
                            start-> end-> Time_Utils.unit_time_difference java_unit start end
                    run_binary_op self fn end new_name


    ## GROUP Standard.Base.DateTime
       ICON time
       Shifts the date/time by a specified period, returning a new date/time
       column of the same type.

       Arguments:
       - amount: An integer or integer column specifying by how many periods to
         shift each date.
       - period: The period by which to shift. For `Date` columns it should be a
         `Date_Period` and for `Time` columns it should be a `Time_Period`. For
         `Date_Time` columns it can be either. It defaults to `Day` where
         possible and `Hour` for `Time` columns.

       ? Time Zone handling

         Some backends may not preserve the timezone data in a `Date_Time`
         (preserving the represented time instant). This may lead to slight
         differences in time calculations between backends, especially around
         unusual events like DST.
    @period Date_Time_Helpers.make_period_selector_for_column
    date_add : (Column | Integer) -> Date_Period | Time_Period -> Column ! Invalid_Value_Type | Illegal_Argument
    date_add self amount (period : Date_Period | Time_Period = default_date_period self) =
        Value_Type.expect_type self .is_date_or_time "date/time" <|
            my_type = self.inferred_precise_value_type
            Value_Type.expect_integer amount <|
                aligned_period = Date_Time_Helpers.align_period_with_value_type my_type period
                aligned_period.if_not_error <|
                    new_name = naming_helper.function_name "date_add" [self, amount, period.to_display_text]
                    java_unit = aligned_period.to_java_unit
                    ## Here we do not need a Time_Utils helper like in scalar
                       implementations of `date_add`, because the date coming
                       from the column will always be already converted into a
                       Java instance.
                    fn date amount =
                        java_unit.addTo date amount
                    run_binary_op self fn amount new_name

    ## GROUP Standard.Base.Logical
       ICON preparation
       Checks for each element of the column if it is contained within the
       provided vector or column.

       Arguments:
       - vector: A vector of elements or another column. The resulting column
         will contain true at the positions where the corresponding element of
         `self` is contained in `vector`.

       > Example
         Check if elements of a column are contained in a provided vector.

             import Standard.Examples

             example_contains = Examples.text_column_1.is_in [1, 2, 5]
    is_in : Column | Vector -> Column
    is_in self vector =
        result_name = naming_helper.concat [naming_helper.to_expression_text self, "in", naming_helper.to_expression_text vector]
        as_vector = case vector of
            _ : Vector -> vector
            _ : Array -> Vector.from_polyglot_array vector
            column : Column -> column.to_vector
        op_name = Java_Storage.Maps.IS_IN
        case self.java_column.getStorage.isBinaryOpVectorized op_name of
            True ->
                run_vectorized_binary_op self op_name as_vector expected_result_type=Value_Type.Boolean skip_nulls=False new_name=result_name
            False ->
                set = Hashset.from_vector as_vector error_on_duplicates=False
                apply_unary_map self result_name set.contains_relational Value_Type.Boolean nothing_unchanged=False

    ## GROUP Standard.Base.Conversions
       ICON convert
       Parses a text column into values.

       In the Database backends, the default formatting settings of the
       particular database are used.

       In the in-memory backend, the default parser options only parse values
       where the process is reversible (e.g., 0123 would not be converted to an
       integer as there is a leading 0). However, settings in the
       `Data_Formatter` can control this.

       Arguments:
       - type: The type to parse the column to. Defaults to `Auto` meaning that
         the type will be inferred from the data. In the Database backends,
         `Auto` is not supported, so a specific type must be selected.
       - format: The formatting settings to use when parsing the column.
         For `Date`, `Time_Of_Day` and `Date_Time`, a Java date time style
         can be used. For `Boolean`, it should be two values that represent true
         and false, separated by a `|`. Alternatively, a `Data_Formatter` can be
         passed to provide complete customisation of the formatting. If
         `""` is provided, the default formatting settings of the backend
         will be used. `""` is currently the only setting accepted by the
         Database backends.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

       ! Error Conditions

         - If the column is not a text column, an `Invalid_Value_Type` error is
           raised.
         - If some values in the column did not match the expected datatype
           format, an `Invalid_Format` problem is reported. The problematic
           cells are replaced with `Nothing`.

       ? Number Formats

         If parsing a column to a number, by default, the parser will attempt
         to find the most appropriate format for the column. This is done by
         finding the format that parses the longest set without an issue from
         the first record.

         It will try the following separators in British, German, French and
         Swiss order.

         - Thousand separators must be followed by groups of 3 numbers.
         - Scientific notation is only allowed on decimals and must be on a
           value between -10 and 10. The notation is an `E` followed by an
           integer and must be enabled on the `Data_Formatter`,

         The following formats are supported:
         - Sign (+/-) followed by Number (e.g. +1,234.56)
         - Using brackets to indicate a negative number (e.g. (1,234.56))
         - Currency symbols (if not in Auto mode) can be placed before or after
           the sign and number.
         - If using brackets, the currency symbol must be placed after the
           opening bracket.

       > Example
         Parse dates in a column in the format `yyyy-MM-dd` (the default format).

             import Standard.Examples

             example_contains = Examples.text_column_1.parse Date

       > Example
         Parse dates in a column in the format `dd/MM/yyyy`

             import Standard.Examples

             example_contains = Examples.text_column_1.parse Date 'dd/MM/yyyy'

       > Example
         Parse a Yes/No column into a boolean column.

             import Standard.Examples

             example_contains = Examples.text_column_1.parse Boolean 'Yes|No'
    @type Widget_Helpers.parse_type_selector
    @format (make_format_chooser include_number=False)
    parse : Value_Type | Auto -> Text | Data_Formatter -> Problem_Behavior -> Column
    parse self type:(Value_Type | Auto)=Auto format:(Text | Data_Formatter)="" on_problems:Problem_Behavior=..Report_Warning =
        Value_Type.expect_text self <|
            formatter = case format of
                _ : Text -> if format == "" then Data_Formatter.Value else Data_Formatter.Value.with_format type format
                _ : Data_Formatter -> format
            parser = formatter.make_value_type_parser type
            storage = self.java_column.getStorage

            new_storage = Java_Problems.with_problem_aggregator on_problems java_problem_aggregator->
                parse_problem_aggregator = ParseProblemAggregator.make java_problem_aggregator self.name type
                parser.parseColumn storage parse_problem_aggregator
            Column.Value (Java_Column.new self.name new_storage)

    ## GROUP Standard.Base.Conversions
       ICON convert
       Format a `Column` using a format string (or `Column` of format strings).

       Arguments:
       - format: The type-dependent format string to use to format the values.
         If `format` is `""`, .to_text is used to format the value.
         In case of date/time columns, a `Date_Time_Formatter` can be used.
       - locale: The locale in which the format should be interpreted.
         If a `Date_Time_Formatter` is provided for `format` and the `locale` is
         set to anything else than `Locale.default`, then that locale will
         override the formatters locale.

       ! Error Conditions

         - If the format is incorrectly formed, or if some values in the column
           did not match the expected datatype format, an `Illegal_Argument`
           error is thrown.

       ? Supported Types
         - `Value_Type.Date`
         - `Value_Type.Date_Time`
         - `Value_Type.Time`
         - `Value_Type.Integer`
         - `Value_Type.Float`
         - `Value_Type.Boolean`

       ? `Value_Type.Date`, `Value_Type.Date_Time`, `Value_Type.Time` format strings

          See `Date_Time_Formatter` for more details.

       ? `Value_Type.Integer`, `Value_Type.Float` format strings

         Numeric format strings are specified by the Java DecimalFormat class.
         See https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html
         for a complete format specification.

       ? `Value_Type.Boolean` format strings

         Format strings for `Boolean` consist of two values that represent true
         and false, separated by a `|`.

       > Example
         Format a `Column` of `Dates` in the format `"yyyyMMdd"`.

             input = Column.from_vector "values" [Date.new 2020 12 21, Date.new 2023 4 25]
             input.format "yyyyMMdd"
             # ==> ["20201221", "20230425"]

       > Example
         Format `Column` of `Dates`, using format strings in a second column.

             input = Column.from_vector "values" [Date.new 2020 12 21, Date.new 2023 4 25]
             formats = Column.from_vector "formats" ["yyyyMMdd", "dd-MM-yyyy"]
             input.format formats
             # ==> ["20201221", "25-04-2023"]

       > Example
         Format a `Column` of `Integers` in the format `"#,##0.00"`.

             input = Column.from_vector "values" [100000000, 2222, 3]
             input.format "#,##0.00"
             # ==> ["100,000,000.00", "2,222.00", "3.00"]

       > Example
         Format a `Column` of `Booleans` in the format `"t|f"`.

             input = Column.from_vector "values" [True, False]
             input.format "t|f"
             # ==> ["t", "f"]

       > Example
         Format a `Column` of numbers, using both decimal point / digit
         separators and a Locale.

             input = Column.from_vector "values" ["100000000", "2222", "3"] . parse numeric_type
             input.format "#,##0.00" locale=(Locale.new "fr")
             # ==> ["100 000 000,00", "2 222,00", "3,00"]
    @locale Locale.default_widget
    @format (self-> Widget_Helpers.make_format_chooser_for_type self.value_type)
    format : Text | Date_Time_Formatter | Column -> Locale -> Column ! Illegal_Argument
    format self format:(Text | Date_Time_Formatter | Column)="" locale:Locale=Locale.default = case format of
        format_column : Column -> Value_Type.expect_text format_column <|
            formatter = make_value_formatter_for_value_type self.value_type locale
            formatter.if_not_error <|
                formatter_flipped value format = formatter format value
                Column_Ops.map_2_over_storage self format_column formatter_flipped make_string_builder
        _ ->
            formatter = make_value_formatter_for_value_type self.value_type locale format
            Column_Ops.map_over_storage self formatter make_string_builder on_problems=Problem_Behavior.Report_Error

    ## GROUP Standard.Base.Conversions
       ICON convert
       Cast the column to a specific type.

       Arguments:
       - value_type: The `Value_Type` to cast the column to.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

       In the Database backend, this will boil down to a CAST operation.
       In the in-memory backend, a conversion will be performed according to
       the following rules:
       - Anything can be cast into the `Mixed` type.
       - Converting to a `Char` type, the elements of the column will be
         converted to text. If it is fixed length, the texts will be trimmed or
         padded on the right with the space character to match the desired
         length.
       - Conversion between numeric types will replace values exceeding the
         range of the target type with `Nothing`.
       - Converting decimal numbers into integers will truncate or round them,
         depending on the backend. If more control is needed, use the various
         rounding functions (such as `round` or `floor`).
       - Booleans may also be converted to numbers, with `True` being converted
         to `1` and `False` to `0`. The reverse is not supported - use `iif`
         instead.
       - A `Date_Time` may be converted into a `Date` or `Time` type - the
         resulting value will be truncated to the desired type.
       - If a `Date` is to be converted to `Date_Time`, it will be set at
         midnight of the default system timezone.
       - For a `Mixed` column being converted into a specific type, each row is
         converted individually.

        If the target type cannot fit some of the values (for example due to too
        small range), a `Conversion_Failure` may be reported according to the
        `on_problems` rules. The Database backends may fail with `SQL_Error`
        instead.

       ? Inexact Target Type

         If the backend does not support the requested target type, the closest
         supported type is chosen and a `Inexact_Type_Coercion` problem is
         reported.

       ! Casting Text values

         The `parse` method should be used to convert text values into other
         types. Due to this, a Mixed column containing values `[2, "3"]` will
         actually be converted into `[2, Nothing]` when casting to Integer type.
    cast : Value_Type -> Problem_Behavior -> Column ! Illegal_Argument | Inexact_Type_Coercion | Conversion_Failure
    cast self value_type:Value_Type on_problems:Problem_Behavior=..Report_Warning =
        Cast_Helpers.check_cast_compatibility self.value_type value_type <|
            target_storage_type = Storage.from_value_type value_type on_problems
            Java_Problems.with_problem_aggregator on_problems java_problem_aggregator->
                cast_problem_builder = CastProblemAggregator.new java_problem_aggregator self.name target_storage_type
                new_storage = self.java_column.getStorage.cast target_storage_type cast_problem_builder
                Column.from_storage self.name new_storage

    ## ALIAS auto_value_type
       GROUP Standard.Base.Conversions
       ICON convert
       Change the value type of the column to a more specific one, based on its
       contents.

       Arguments:
       - shrink_types: If set `True`, smaller types will be chosen if possible,
         according to the rules below. Defaults to `False`.

       ? Auto Type Selection Rules

         - If a `Mixed` column can be assigned a single type, like `Char` or
           `Integer`, that will be used.
         - Text columns are not parsed. To do that, use the `parse` method.
         - If a `Float` column contains only integers, it will be converted to
           an Integer column.
         - If a `Decimal` column contains only integers that could fit in a
           64-bit integer storage, it will be converted to an Integer column.
         - If `shrink_types` is `False` (default), no other transformations are
           applied.
         - However, if `shrink_types` is set to `True`, then:
           - Integer columns will be assigned the smallest size that can fit all
             values (down to 16-bit integers; converting to the `Byte` type has
             to be done manually through `cast`).
           - If all elements in a text column have the same length, the type
             will become fixed length.
           - Otherwise, if a text column is variable length, but all text
             elements are no longer than 255 characters, the column will get a
             max length of 255. Otherwise, the column size limit will stay
             unchanged.
    auto_cast : Boolean -> Column
    auto_cast self shrink_types=False =
        new_value_type = case shrink_types of
            False -> self.inferred_precise_value_type
            True ->
                Storage.to_value_type self.java_column.getStorage.inferPreciseTypeShrunk
        # We run with Report_Error because we do not expect any problems.
        self.cast new_value_type on_problems=Problem_Behavior.Report_Error

    ## PRIVATE
       GROUP Standard.Base.Conversions
       ICON convert

       Deprecated: Use `auto_cast` instead.

       Change the value type of the column to a more specific one, based on its
       contents.

       Arguments:
       - shrink_types: If set `True`, smaller types will be chosen if possible,
         according to the rules below. Defaults to `False`.

       ? Auto Type Selection Rules

         - If a `Mixed` column can be assigned a single type, like `Char` or
           `Integer`, that will be used.
         - Text columns are not parsed. To do that, use the `parse` method.
         - If a `Float` column contains only integers, it will be converted to
           an Integer column.
         - If a `Decimal` column contains only integers that could fit in a
           64-bit integer storage, it will be converted to an Integer column.
         - If `shrink_types` is `False` (default), no other transformations are
           applied.
         - However, if `shrink_types` is set to `True`, then:
           - Integer columns will be assigned the smallest size that can fit all
             values (down to 16-bit integers; converting to the `Byte` type has
             to be done manually through `cast`).
           - If all elements in a text column have the same length, the type
             will become fixed length.
           - Otherwise, if a text column is variable length, but all text
             elements are no longer than 255 characters, the column will get a
             max length of 255. Otherwise, the column size limit will stay
             unchanged.
    auto_value_type : Boolean -> Column
    auto_value_type self shrink_types=False =
        Warning.attach (Deprecated.Warning "Standard.Table.Column.Column" "auto_value_type" "Deprecated: `auto_value_type` has been replaced by `auto_cast`.") <|
            self.auto_cast shrink_types

    ## ALIAS transform column
       ICON column_add

       Applies `function` to each item in this column and returns the column
       of results.

       Arguments:
       - function: The function to apply to each element of `self` column.
       - skip_nothing: If `True`, `Nothing` values will be skipped. Otherwise,
         `Nothing` values will be passed to the `function`.
       - expected_value_type: The expected value type of the resulting column.
         If `Auto`, the value type will be inferred from the values returned by
         `function`.

       ! Error Conditions

         - If any of the values returned by `function` do not fit the expected
           value type, an `Invalid_Value_Type` error is raised.
         - If the `function` raises a dataflow error on any row, the first such
           error is propagated.
         - If an invocation of the `function` returns a value with warnings,
           these warnings are attached to the overall result.

       > Example
         Multiply each element of the column by itself.

             import Standard.Examples

             example_map = Examples.integer_column.map (x -> x * x)
    map : (Any -> Any) -> Boolean -> Value_Type | Auto -> Column ! Invalid_Value_Type
    map self function skip_nothing=True expected_value_type=Auto =
        new_fn = if skip_nothing then (x-> if x.is_nothing then Nothing else function x) else function
        new_st = self.to_vector.map on_problems=No_Wrap new_fn
        Column.from_vector self.name new_st value_type=expected_value_type

    ## ALIAS combine, join by row position, merge
       ICON join2-1

       Applies `function` to consecutive pairs of elements of `self` and `that`
       and returns a column of results.

       Arguments:
       - that: The column to zip with `self`.
       - function: A binary function that is applied to corresponding pairs of
         elements of `self` and `that` to produce a value.
       - skip_nothing: controls whether missing values should be passed to the
         `function`. The default value of `True` will skip the rows for which
         the value in either column is missing and automatically append
         `Nothing` to the result table. If set to `False`, every pair of values
         is passed to `function`.
       - expected_value_type: The expected value type of the resulting column.
         If `Auto`, the value type will be inferred from the values returned by
         `function`.

       ! Error Conditions

         - If any of the values returned by `function` do not fit the expected
           value type, an `Invalid_Value_Type` error is raised.
         - If the `function` raises a dataflow error on any row, the first such
           error is propagated.
         - If an invocation of the `function` returns a value with warnings,
           these warnings are attached to the overall result.

       > Example
         Zip two columns together as pairs.

             import Standard.Examples

             example_zip =
                Examples.integer_column.zip Examples.text_column_1 [_, _]
    zip : Column -> (Any -> Any -> Any) -> Boolean -> Value_Type | Auto -> Column ! Invalid_Value_Type
    zip self that:Column function skip_nothing=True expected_value_type=Auto =
        new_fn = case skip_nothing of
            True ->
                x -> y ->
                    if x.is_nothing then Nothing else
                        if y.is_nothing then Nothing else
                            function x y
            False -> function
        new_name = naming_helper.binary_operation_name "x" self that
        vec = self.to_vector.zip on_problems=No_Wrap that.to_vector new_fn
        Column.from_vector new_name vec value_type=expected_value_type

    ## GROUP Standard.Base.Metadata
       ICON text_input
       Returns a new column, containing the same elements as `self`, but with
       the given name.

       Arguments:
       - name: The new name for the column.

       > Example
         Rename a column.

             import Standard.Examples

             example_rename = Examples.integer_column.rename "My Numbers"
    rename : Text -> Column ! Illegal_Argument
    rename self name = naming_helper.ensure_name_is_valid name <|
        Illegal_Argument.handle_java_exception <|
            Column.Value (self.java_column.rename name)

    ## GROUP Standard.Base.Metadata
       ICON metadata
       Returns the name of this column.

       > Example
         Get the name of a column.

             import Standard.Examples

             example_name = Examples.text_column_2.name
    name : Text
    name self = self.java_column.getName

    ## GROUP Standard.Base.Metadata
       ICON metadata
       Returns the length of this column.

       > Example
         Get the length of a column.

             import Standard.Examples

             example_length = Examples.text_column_2.length
    length : Integer
    length self = self.java_column . getSize

    ## GROUP Standard.Base.Metadata
       ICON metadata
       Returns the number of missing items in this column.

       > Example
         Count the number of missing values in a column.

             import Standard.Examples

             example_count_nothing = Examples.text_column_2.count_nothing
    count_nothing : Integer
    count_nothing self = CountNothing.apply self.java_column

    ## GROUP Standard.Base.Metadata
       ICON metadata
       Returns the number of non-null items in this column.

       > Example
         Count the number of not missing values in a column.

             import Standard.Examples

             example_count = Examples.text_column_2.count
    count : Integer
    count self = self.length - self.count_nothing

    ## GROUP Standard.Base.Selections
       ICON parse3
       Returns the value contained in this column at the given index.

       Arguments:
       - index: The index in the column from which to get the value.

       If the value is an NA then this method returns nothing. If the index is
       not an index in the column it returns an `Index_Out_Of_Bounds`.

       > Example
         Get the first element from a column.

             import Standard.Examples

             example_at = Examples.integer_column.at 0
    @index (self-> Numeric_Input minimum=0 maximum=self.length-1)
    at : Integer -> (Any | Nothing) ! Index_Out_Of_Bounds
    at self index:Integer=0 =
        self.get index (Error.throw (Index_Out_Of_Bounds.Error index self.length))

    ## GROUP Standard.Base.Selections
       ICON parse3
       Returns the value contained in this column at the given index.

       Arguments:
       - index: The index in the column from which to get the value.
       - default: The value if the index is out of range.

       > Example
         Get the first element from a column.

             import Standard.Examples

             example_at = Examples.integer_column.get 0 -1
    @index (self-> Numeric_Input minimum=0 maximum=self.length-1)
    get : Integer -> Any -> Any | Nothing
    get self index:Integer=0 (~default=Nothing) =
        if index < 0 && index >= -self.length then self.get (self.length + index) default else
            valid_index = (index >= 0) && (index < self.length)
            if valid_index.not then default else
                storage = self.java_column.getStorage
                if storage.isNothing index then Nothing else
                    java_to_enso <| storage.getItemBoxed index

    ## PRIVATE
       ICON data_input
       Returns a column containing rows of this column.

       Arguments:
       - max_rows: specifies the maximum number of rows to read.
    @max_rows Rows_To_Read.default_widget
    read : Rows_To_Read -> Column
    read self (max_rows : Rows_To_Read = ..All_Rows) =
        if max_rows.is_nothing then self else
            self.to_table.read max_rows . at 0

    ## GROUP Standard.Base.Conversions
       ICON convert
       Returns a vector containing all the elements in this column.

       > Example
         Get the elements of a column as a vector.

             import Standard.Examples

             example_to_vector = Examples.integer_column.to_vector
    to_vector : Vector
    to_vector self = Vector.from_polyglot_array self.java_column.getStorage.toList . map java_to_enso

    ## GROUP Standard.Base.Metadata
       ICON metadata
       Returns the `Value_Type` associated with that column.

       The value type determines what type of values the column is storing and
       what operations are permitted.
    value_type : Value_Type
    value_type self =
        storage_type = self.java_column.getStorage.getType
        Storage.to_value_type storage_type

    ## PRIVATE
       Returns a possibly more precise `Value_Type` based on the data in the
       column.

       Most columns will return their type without changes. A mixed column may
       return a more precise type if a common type can be found for all of its
       values.
    inferred_precise_value_type : Value_Type
    inferred_precise_value_type self =
        storage_type = self.java_column.getStorage.inferPreciseType
        Storage.to_value_type storage_type

    ## PRIVATE
       Internal hook that says if a given column should be selected by a
       specific type in a `By_Type` selection.
    should_be_selected_by_type self (value_type : Value_Type) -> Boolean =
        self.value_type.is_same_type value_type

    ## PRIVATE
       Converts this column to JS_Object representation.

       > Example
         Get a JavaScript representation of the column.

             import Standard.Examples

             example_to_json = Examples.integer_column.to_js_object
    to_js_object : JS_Object
    to_js_object self =
        name = self.java_column.getName
        storage = self.java_column.getStorage
        storage_proxy = Array_Proxy.new storage.size i-> storage.getItemBoxed i
        storage_json = Vector.from_polyglot_array storage_proxy
        JS_Object.from_pairs [["name", name], ["data", storage_json]]

    ## ICON data_input
       Converts this column into a single-column table.

       > Example
         Convert a column to a table.

             import Standard.Examples

             example_to_table = Examples.integer_column.to_table
    to_table : Table
    to_table self = Table.Value self.java_column.toTable

    ## ALIAS column type, field info, metadata
       GROUP Standard.Base.Metadata
       ICON metadata
       Returns a Table describing this column's contents and type.

       The table behaves like `Table.column_info.
    info : Table
    info self = self.to_table.column_info

    ## ALIAS order_by
       GROUP Standard.Base.Selections
       ICON order
       Sorts the column according to the specified rules.

       Arguments:
       - order: specifies the default sort order for this operation.
       - missing_last: specifies the default placement of missing values when
         compared to non-missing ones. Note that this argument is independent
         from `order`, i.e. missing values will always be sorted according to
         this rule, ignoring the ascending / descending setting.
       - by: function taking two items in this column and returning an
         ordering. If specified, it is used instead of the natural
         ordering of the values.

       > Example
         Sorting a column in ascending order.

             import Standard.Examples

             example_sort = Examples.integer_column.sort

       > Example
         Sorting a column in descending order, placing missing values at the
         top of the resulting column.

             import Standard.Examples

             example_sort =
                 Examples.integer_column.sort Sort_Direction.Descending missing_last=False

       > Example
         Sorting `column` in ascending order, using a custom comparison
         function.

             import Standard.Examples

             example_sort =
                 my_compare a b = Ordering.compare a.abs b.abs
                 Examples.decimal_column.sort by=my_compare
    sort : Sort_Direction -> Boolean -> (Any -> Any -> Ordering) | Nothing -> Column
    sort self order:Sort_Direction=..Ascending missing_last:Boolean=True by=Nothing = case by of
        Nothing ->
            order_bool = case order of
                Sort_Direction.Ascending -> True
                Sort_Direction.Descending -> False
            rule = OrderBuilder.OrderRule.new self.java_column order_bool missing_last
            mask = OrderBuilder.buildOrderMask [rule]
            new_col = self.java_column.applyMask mask
            Column.Value new_col
        _ ->
            wrapped a b = case a of
                Nothing -> if b.is_nothing then Ordering.Equal else if missing_last then Ordering.Greater else Ordering.Less
                _ -> case b of
                    Nothing -> if missing_last then Ordering.Less else Ordering.Greater
                    _ -> by a b
            sorted = self.to_vector.sort order by=wrapped
            Column.from_vector self.name sorted

    ## ALIAS first, head, keep, last, limit, sample, slice, tail, top
       GROUP Standard.Base.Selections
       ICON parse3
       Creates a new Column with the specified range of rows from the input
       Column.

       Arguments:
       - range: The selection of rows from the table to return.

       Returns:
       A new Column containing the selected rows.

       ! Error Conditions
       - If the range is out of bounds, an `Index_Out_Of_Bounds` error is raised.

       > Example
         Select the first row from the "Name" Column.

             table = Table.new [["Name", ["Alice", "Bob", "Charlie"]]]
             column = table.get "Name"
             ## The take returns "Alice"
             first_row = column.take (..First 1)

       > Example
         Select the last row from the "Name" Column.

             table = Table.new [["Name", ["Alice", "Bob", "Charlie"]]]
             column = table.get "Name"
             ## The take returns "Charlie"
             last_row = column.take (..Last 1)
    @range (self-> Index_Sub_Range.default_widget self.length)
    take : (Index_Sub_Range | Range | Integer) -> Column
    take self range:(Index_Sub_Range | Range | Integer)=..First =
        take_helper self.length (self.at _) self.slice (slice_ranges self) range

    ## ALIAS remove, skip
       GROUP Standard.Base.Selections
       ICON parse3
       Creates a new Column from the input with the specified range of rows
       removed.

       Arguments:
       - range: The selection of rows from the table to remove.
    @range (self-> Index_Sub_Range.default_widget self.length)
    drop : (Index_Sub_Range | Range | Integer) -> Column
    drop self range:(Index_Sub_Range | Range | Integer)=..First =
        drop_helper self.length (self.at _) self.slice (slice_ranges self) range

    ## PRIVATE
       Returns a column with a continuous sub-range of rows taken.
    slice : Integer -> Integer -> Column
    slice self start end =
        length = self.length
        offset = (start.min length).max 0
        limit = ((end - offset).min (length - offset)).max 0
        Column.Value (self.java_column.slice offset limit)

    ## GROUP Standard.Base.Selections
       ICON parse3
       Returns the first element in the column, if it exists.

       If the column is empty, this method will return a dataflow error
       containing an `Index_Out_Of_Bounds`.

       > Example
         Get the first element of a column.

             import Standard.Examples

             example_first = Examples.integer_column.first
    first : Any ! Index_Out_Of_Bounds
    first self = self.at 0

    ## GROUP Standard.Base.Selections
       ICON select_row
       Returns the last element in the column, if it exists.

       If the column is empty, this method will return a dataflow error
       containing an `Index_Out_Of_Bounds`.

       > Example
         Get the last element of a column.

             import Standard.Examples

             example_last = Examples.integer_column.last
    last : Any ! Index_Out_Of_Bounds
    last self = self.at (self.length - 1)

    ## GROUP Standard.Base.Selections
       ICON order
       Returns a column containing the values of `self` column with their order
       reversed.

       > Example
         Reverse the values of a column to produce a new column.

             import Standard.Examples

             example_reverse = Examples.integer_column.reverse
    reverse : Column
    reverse self =
        mask = OrderMask.reverse self.length
        Column.Value (self.java_column.applyMask mask)

    ## GROUP Standard.Base.Metadata
       ICON metadata
       Returns a column of numbers, in which every entry denotes how many times
       the value at the given position occured before.

       > Example
         Count duplicate occurences of values in a column.

             import Standard.Examples

             example_duplicate_count = Examples.integer_column.duplicate_count
    duplicate_count : Column
    duplicate_count self = Column.Value self.java_column.duplicateCount

    ## PRIVATE
       Provides a simplified text representation for display in the REPL and errors.
    to_text : Text
    to_text self = "(In-Memory Column "+self.name.to_text+")"

    ## PRIVATE
       Helper for the expression to tell it which functions needs a Vector.
    var_args_functions : Vector
    var_args_functions = ['is_in', 'coalesce', 'min', 'max']

    ## PRIVATE
       This is a shortcut for API compatibility.
    naming_helper : Column_Naming_Helper
    naming_helper self = naming_helper

    ## ALIAS count, kurtosis, maximum, mean, median, minimum, mode, skew, standard_deviation, statistic, sum, variance
       GROUP Standard.Base.Statistics
       ICON transform4
       Compute a single statistic on the column.

       Arguments:
       - statistic: Statistic to calculate.
    compute : Statistic -> Any
    compute self statistic:Statistic=..Count =
        Statistic.compute_bulk self.to_vector [statistic] . first

    ## ALIAS count, kurtosis, maximum, mean, median, minimum, mode, skew, standard_deviation, statistic, sum, variance
       ICON transform4
       Compute statistics on the column.

       Arguments:
       - statistics: Set of statistics to calculate.
    compute_bulk : Vector Statistic -> Table
    compute_bulk self statistics=[Statistic.Count, Statistic.Sum] =
        values = Statistic.compute_bulk self.to_vector statistics
        names = statistics.map _.to_text
        Table.from_rows names [values]

    ## ALIAS cumulative, count, sum, total, minimum, maximum, sum, mean, product, variance, standard deviation
       GROUP Standard.Base.Statistics
       ICON transform4
       Compute a single running statistic on the column.

       Arguments:
       - statistic: Statistic to calculate.
       - name: Name of the new column.
    running : Statistic -> Text -> Column
    running self statistic:Statistic=..Count name=statistic.to_text+" "+self.name =
        data = Statistic.running self.to_vector statistic
        Column.from_vector name data

## PRIVATE

   Folds the vectorized operation over the provided column and values. When more
   than one value to is provided, the result is folded with subsequent values.

   Arguments:
   - column: The column to execute the operation over.
   - name: The name of the vectorized operation.
   - fallback_fn: A function used if the vectorized operation isn't available.
     It should never raise dataflow errors.
   - operands: The vector of operands to apply to the function after `column`.
   - new_name: The name of the column created as the result of this operation.
   - skip_nulls: Specifies if nulls should be skipped. If set to `True`, a null
     value results in null without passing it to the function. If set to
     `False`, the null values are passed as any other value and can have custom
     handling logic.
run_vectorized_many_op : Column -> Text -> (Any -> Any -> Any) -> Vector -> Text|Nothing -> Boolean -> Column
run_vectorized_many_op column name fallback_fn operands new_name=Nothing skip_nulls=False =
    effective_operands = Vector.unify_vector_or_element operands
    all_operands = [column]+effective_operands
    effective_new_name = new_name.if_nothing <|
        naming_helper.function_name name all_operands
    common_type = Value_Type_Helpers.find_common_type_for_arguments all_operands
    common_type.if_not_error <|
        Java_Problems.with_map_operation_problem_aggregator effective_new_name Problem_Behavior.Report_Warning problem_builder->
            storage_type = resolve_storage_type common_type
            folded = effective_operands.fold column.java_column.getStorage current-> operand->
                case operand of
                    _ : Column -> Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                        current.vectorizedOrFallbackZip name problem_builder fallback_fn operand.java_column.getStorage skip_nulls storage_type
                    _ -> Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                        current.vectorizedOrFallbackBinaryMap name problem_builder fallback_fn operand skip_nulls storage_type
            Column.Value (Java_Column.new effective_new_name folded)

## PRIVATE

   Executes a vectorized binary operation over the provided column.

   Arguments:
   - column: The column to execute the operation over.
   - name: The name of the vectorized operation.
   - operand: The operand to apply to the function after `column`.
   - new_name: The name of the column created as the result of this operation.
   - fallback_fn: A function used if the vectorized operation isn't available.
     It should never raise dataflow errors.
   - expected_result_type: The expected result type of the operation.
   - skip_nulls: Specifies if nulls should be skipped. If set to `True`, a null
     value results in null without passing it to the function. If set to
     `False`, the null values are passed as any other value and can have custom
     handling logic.
run_vectorized_binary_op : Column -> Text -> Any -> Text|Nothing -> (Any -> Any -> Any) -> Value_Type -> Boolean -> Column
run_vectorized_binary_op column name operand new_name=Nothing fallback_fn=Nothing expected_result_type=Nothing skip_nulls=True =
    effective_new_name = new_name.if_nothing <|
        naming_helper.binary_operation_name name column operand
    Java_Problems.with_map_operation_problem_aggregator column.name Problem_Behavior.Report_Warning problem_builder->
        storage_type = resolve_storage_type expected_result_type
        case operand of
            Column.Value col2 ->
                s1 = column.java_column.getStorage
                s2 = col2.getStorage
                rs = Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                    s1.vectorizedOrFallbackZip name problem_builder fallback_fn s2 skip_nulls storage_type
                Column.Value (Java_Column.new effective_new_name rs)
            _ ->
                s1 = column.java_column.getStorage
                rs = Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                    s1.vectorizedOrFallbackBinaryMap name problem_builder fallback_fn (enso_to_java operand) skip_nulls storage_type
                Column.Value (Java_Column.new effective_new_name rs)

## PRIVATE

   Executes a vectorized ternary operation over the provided column.

   Arguments:
   - column: The column to execute the operation over.
   - name: The name of the vectorized operation.
   - operand0: The first operand to apply to the function after `column`.
   - operand1: The second operand to apply to the function after `column`.
   - new_name: The name of the column created as the result of this operation.
   - expected_result_type: The expected result type of the operation.
   - skip_nulls: Specifies if nulls should be skipped. If set to `True`, a null
     value results in null without passing it to the function. If set to
     `False`, the null values are passed as any other value and can have custom
     handling logic.
run_vectorized_ternary_op : Column -> Text -> Any -> Any -> Text|Nothing -> Value_Type -> Boolean -> Column
run_vectorized_ternary_op column name operand0 operand1 new_name=Nothing expected_result_type=Nothing skip_nulls=True =
    effective_new_name = new_name.if_nothing <|
        naming_helper.function_name name [column, operand0, operand1]
    Java_Problems.with_map_operation_problem_aggregator column.name Problem_Behavior.Report_Warning problem_builder->
        storage_type = resolve_storage_type expected_result_type
        s1 = column.java_column.getStorage
        rs = Polyglot_Helpers.handle_polyglot_dataflow_errors <|
            s1.vectorizedTernaryMap name problem_builder operand0 operand1 skip_nulls storage_type
        Column.Value (Java_Column.new effective_new_name rs)

## PRIVATE
   Runs a binary operation over the provided column and operand which may be
   another column or a scalar value.

   Arguments:
   - column: The column to execute the operation over.
   - function: The function to apply to each element of `column`.
   - operand: The operand to apply to the function after `column`.
   - new_name: The name of the column created as the result of this operation.
   - skip_nulls: Specifies if nulls should be skipped. If set to `True`, a null
     value results in null without passing it to the function. If set to
     `False`, the null values are passed as any other value and can have custom
     handling logic.
   - expected_result_type: The expected result type of the operation. If set to
     `Nothing`, the result type is inferred from the values.
run_binary_op column function operand new_name skip_nulls=True expected_result_type=Nothing =
    s = column.java_column.getStorage
    storage_type = resolve_storage_type expected_result_type
    Java_Problems.with_map_operation_problem_aggregator column.name Problem_Behavior.Report_Warning problem_builder->
        new_storage = case operand of
            other_column : Column ->
                Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                    s.zip function other_column.java_column.getStorage skip_nulls storage_type problem_builder
            _ ->
                Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                    s.binaryMap function operand skip_nulls storage_type problem_builder
        Column.Value (Java_Column.new new_name new_storage)

## PRIVATE

   Executes a vectorized binary operation over the provided column.

   Arguments:
   - column: The column to execute the operation over.
   - name: The name of the vectorized operation.
   - operand: The operand to apply to the function after `column`.
   - fallback_fn: A function used if the vectorized operation isn't available.
     It takes a `MapOperationProblemAggregator` as its first argument.
     It should never raise dataflow errors and use the aggregator builder to
     report problems. If fatal problems are expected, the fallback should be
     raising a panic and the user-facing code should ensure such panic is caught
     and converted to a dataflow error.
   - expected_result_type: The expected result type of the operation.
   - new_name: The name of the column created as the result of this operation.
   - skip_nulls: Specifies if nulls should be skipped. If set to `True`, a null
     value results in null without passing it to the function. If set to
     `False`, the null values are passed as any other value and can have custom
     handling logic.
run_vectorized_binary_op_with_fallback_problem_handling column name operand fallback_fn new_name expected_result_type=Nothing skip_nulls=True =
    Java_Problems.with_map_operation_problem_aggregator new_name Problem_Behavior.Report_Warning problem_builder->
        applied_fn = case fallback_fn of
            Nothing -> Nothing
            _ -> fallback_fn problem_builder
        storage_type = resolve_storage_type expected_result_type
        case operand of
            Column.Value col2 ->
                s1 = column.java_column.getStorage
                s2 = col2.getStorage
                rs = Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                    s1.vectorizedOrFallbackZip name problem_builder applied_fn s2 skip_nulls storage_type
                Column.Value (Java_Column.new new_name rs)
            _ ->
                s1 = column.java_column.getStorage
                rs = Polyglot_Helpers.handle_polyglot_dataflow_errors <|
                    s1.vectorizedOrFallbackBinaryMap name problem_builder applied_fn (enso_to_java operand) skip_nulls storage_type
                Column.Value (Java_Column.new new_name rs)

## PRIVATE

   Gets a textual representation of the item at position `ix` in `column`.

   Arguments:
   - column: The column to get the item from.
   - ix: The index in the column from which to get the item.
get_item_as_text : Column -> Integer -> Text
get_item_as_text column ix =
    item = column.getItemBoxed ix
    ## TODO This special handling of `Text` is because `"a".to_text` evaluates
       to "'a'" and not just "a". The code can be simplified once the following
       task is implemented:
       https://www.pivotaltracker.com/story/show/181499256
    case item of
        _ : Text -> normalize_text_for_display item
        _ -> item.pretty

## PRIVATE
   Ensures that the text can be safely displayed in a terminal.

   If the string contains special characters, it will be wrapped in quotes and
   the characters escaped. Otherwise, the string is returned as-is.
normalize_text_for_display text =
    prettified = text.pretty
    just_quoted = "'" + text + "'"
    if prettified == just_quoted then text else prettified

## PRIVATE
   A helper to create a new table consisting of slices of the original table.
slice_ranges column ranges =
    normalized = normalize_ranges ranges
    Column.Value (column.java_column.slice normalized)

## PRIVATE
   Creates a storage builder suitable for building a column for the provided
   column type.

   If a value type is not supported, its closest match is selected and
   an `Inexact_Type_Coercion` problem is reported.
make_storage_builder_for_type value_type on_problems initial_size java_problem_aggregator =
    closest_storage_type = Storage.from_value_type value_type on_problems
    Storage.make_builder closest_storage_type initial_size java_problem_aggregator

## PRIVATE
   Helper for case case_sensitivity based text operations.
   The fallback is needed to handle custom case sensitivity options,
   until the vectorized operation can take that parameter.
run_vectorized_binary_case_text_op : Column -> Text -> (Text | Column) -> Case_Sensitivity -> (Text -> Text -> Any) -> Text -> Column
run_vectorized_binary_case_text_op left op other case_sensitivity fallback new_name =
    with_checks ~action =
        Value_Type.expect_text left <|
            Value_Type.expect_text other <|
                action
    result_type = Value_Type.Boolean
    with_checks <| case case_sensitivity of
        Case_Sensitivity.Default ->
            run_vectorized_binary_op left op other new_name result_type
        Case_Sensitivity.Sensitive ->
            run_vectorized_binary_op left op other new_name result_type
        Case_Sensitivity.Insensitive _ ->
            ## TODO currently this always runs the fallback which is slow due to the
               cost of Java-to-Enso calls. We want to have a vectorized
               implementation, but we need to extend the architecture to allow
               passing the locale to it.
               See: https://www.pivotaltracker.com/n/projects/2539304/stories/184093260
            run_binary_op left fallback other new_name=new_name skip_nulls=True expected_result_type=result_type

## PRIVATE
   Converts the value type to a storage type, passing `Nothing` through.

   Sometimes we do not specify the storage type as it should be inferred by the
   vectorized operation, in which case it can be `Nothing`.
resolve_storage_type value_type = case value_type of
    Nothing -> Nothing
    _ -> Storage.from_value_type_strict value_type

## PRIVATE
wrap_text_argument_as_value_provider val =
    Value_Type.expect_text val <| case val of
        text : Text -> (_-> text)
        col : Column ->
            storage = col.java_column.getStorage
            i-> storage.getItemBoxed i

## PRIVATE
wrap_text_or_regex_argument_as_value_provider val =
    if val.is_a Regex then (_-> val) else wrap_text_argument_as_value_provider val

## PRIVATE
   Cast a column to a `Value_Type`, unless it already has that type.
cast_if_needed : Column -> Value_Type -> Column
cast_if_needed column value_type = if column.value_type == value_type then column else column.cast value_type

## PRIVATE
naming_helper : Column_Naming_Helper
naming_helper = Column_Naming_Helper.in_memory

## PRIVATE
   Resolves the default date period for `date_add` depending on the source column value type.
default_date_period column = if column.value_type.has_date then Date_Period.Day else Time_Period.Hour

## PRIVATE
   Fills the missing values in a provided column with the previous non-missing value.

   Arguments:
   - column: The column to fill.
   - is_missing: A boolean column specifying which elements are deemed missing.
     If set to `Nothing`, this will rely on the default missing value semantics
     (`is_nothing`).
fill_previous column is_missing =
    missing_storage = if Nothing == is_missing then Nothing else is_missing.java_column.getStorage
    new_storage = column.java_column.getStorage.fillMissingFromPrevious missing_storage
    Column.from_storage column.name new_storage

## PRIVATE
   Conversion method to a Column from a Vector.
Column.from (that:Vector) (name:Text="Vector") = Column.from_vector name that

## PRIVATE
   Conversion method to a Column to a Vector.
Vector.from (that:Column) = that.to_vector

## PRIVATE
   Conversion method to a Table to a Vector.
Vector.from (that:Table) = if that.column_count == 1 then that.at 0 . to_vector else
    Error.throw (Illegal_Argument.Error "Cannot convert a table with more than one column to a vector, use `at` to choose a column.")

## PRIVATE
   Conversion method to a Column from a Vector.
Column.from (that:Range) (name:Text="Range") = Column.from_vector name that.to_vector

## PRIVATE
   Conversion method to a Column from a Vector.
Column.from (that:Date_Range) (name:Text=that.default_column_name) = Column.from_vector name that.to_vector

## PRIVATE
Cleansable_Text.from (that:Column) = Cleansable_Text.Value (pattern->replace_with-> (that.text_replace (regex pattern) replace_with).rename that.name)

## PRIVATE
   Applies a UnaryOperation to a column.

   Arguments:
   - column: The column to apply the operation to.
   - operation: The UnaryOperation to apply.
   - new_name: The name of the column created as the result of this operation.
   - if_unsupported: The result if the operation is not supported for the column.
apply_unary_operation column:Column operation:UnaryOperation new_name:Text|Nothing=Nothing ~if_unsupported=(Panic.throw (Illegal_State.Error "Unsupported unary operation for column called "+column.name+". This is a bug in the Table library.")) =
    used_name = new_name.if_nothing (naming_helper.function_name operation.getName [column])
    Java_Problems.with_map_operation_problem_aggregator column.name Problem_Behavior.Report_Warning java_problem_aggregator->
        java_column = UnaryOperation.apply column.java_column operation used_name java_problem_aggregator
        if java_column.is_nothing then if_unsupported else Column.Value java_column

## PRIVATE
   Applies a function to every row in the column.

   Arguments:
   - column: The column to apply the operation to.
   - new_name: The name of the column created as the result of this operation.
   - function: A function applied to every element. It should not raise errors.
   - expected_result_type: The expected result type of the operation.
   - nothing_unchanged: If set to `True`, `Nothing` values will be passed through
     the operation without being changed. If set to `False`, `Nothing` values will
     be passed to the function.
apply_unary_map column:Column new_name:Text function expected_result_type:Value_Type|Nothing=Nothing nothing_unchanged:Boolean=True =
    storage_type = resolve_storage_type expected_result_type
    Java_Problems.with_map_operation_problem_aggregator column.name Problem_Behavior.Report_Warning java_problem_aggregator->
        map_column = UnaryOperation.mapFunction column.java_column function nothing_unchanged storage_type new_name java_problem_aggregator
        Column.Value map_column
