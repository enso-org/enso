from Standard.Base import all
from Standard.Base.Error.Problem_Behavior as Problem_Behavior_Module import Problem_Behavior
import Standard.Base.System.File.Existing_File_Behavior
import Standard.Base.System.File.Option
from Standard.Table.Io.File_Format import Infer

import Standard.Table.Data.Table
from Standard.Table.Error as Error_Module import Invalid_Location, Duplicate_Output_Column_Names, Invalid_Output_Column_Names, Range_Exceeded, Existing_Data
import Standard.Base.Error.Common as Errors

polyglot java import org.enso.table.excel.ExcelRange as Java_Range
polyglot java import org.enso.table.excel.ExcelHeaders
polyglot java import org.enso.table.read.ExcelReader
polyglot java import org.enso.table.write.ExcelWriter
polyglot java import org.enso.table.error.ExistingDataException
polyglot java import org.enso.table.error.RangeExceededException
polyglot java import org.enso.table.error.InvalidLocationException

polyglot java import java.lang.IllegalArgumentException
polyglot java import java.lang.IllegalStateException
polyglot java import java.io.IOException
polyglot java import org.apache.poi.UnsupportedFileFormatException
polyglot java import org.enso.table.util.problems.DuplicateNames
polyglot java import org.enso.table.util.problems.InvalidNames

type Excel_Section
    ## Gets a list of sheets within a workbook.
    type Sheet_Names

    ## Gets a list of named ranges within a workbook.
    type Range_Names

    ## Gets the data from a specific sheet. Column names are the Excel column
       names.
    type Sheet (sheet:(Integer|Text)=1) (skip_rows:Integer=0) (row_limit:(Integer|Nothing)=Nothing)

    ## Gets a specific range (taking either a defined name or external style
       address) from the workbook.
       If it is a single cell, it will be treated as the top left cell and will
       expand right and down to cover the connected cells.
    type Cell_Range (address:(Text|Excel_Range)) (skip_rows:Integer=0) (row_limit:(Integer|Nothing)=Nothing)

type Excel_Range
    ## Specifies a range within an Excel Workbook.
    type Excel_Range java_range:Java_Range

    ## Gets the name of the sheet.
    sheet_name : Text
    sheet_name = self.java_range.getSheetName

    ## Gets the index (1-based) of the top row of the range.
       Returns `Nothing` if referring to a complete column.
    top_row : Integer | Nothing
    top_row = if self.java_range.isWholeColumn then Nothing else
        self.java_range.getTopRow

    ## Gets the index (1-based) of the bottom row of the range.
       Returns `Nothing` if referring to a complete column.
    bottom_row : Integer | Nothing
    bottom_row = if self.java_range.isWholeColumn then Nothing else
        self.java_range.getBottomRow

    ## Gets the index (1-based) of the left column of the range.
       Returns `Nothing` if referring to a complete row.
    left_column : Integer | Nothing
    left_column = if self.java_range.isWholeRow then Nothing else
        self.java_range.getLeftColumn

    ## Gets the index (1-based) of the right column of the range.
       Returns `Nothing` if referring to a complete row.
    right_column : Integer | Nothing
    right_column = if self.java_range.isWholeRow then Nothing else
        self.java_range.getRightColumn

    ## Is the Excel_Range referring to a single cell
    is_single_cell : Boolean
    is_single_cell = self.java_range.isSingleCell

    ## Gets the address to this in A1 format.
    address : Text
    address = self.java_range.getAddress

    ## Displays the Excel_Range.
    to_text : Text
    to_text = "Excel_Range " + self.address

    ## Validates if a column index (1-based) is within the valid range for
       Excel.

       Arguments:
       - column: 1-based index to check.
    is_valid_column : Integer -> Boolean
    is_valid_column column =
        excel_2007_column_limit = 16384
        (column > 0) && (column <= excel_2007_column_limit)

    ## Validates if a row index (1-based) is within the valid range for Excel.

       Arguments:
       - row: 1-based index to check.
    is_valid_row : Integer -> Boolean
    is_valid_row row =
        excel_2007_row_limit = 1048576
        (row > 0) && (row <= excel_2007_row_limit)

    ## Given a column name, parses to the index (1-based) or return index
       unchanged.
    column_index : (Text|Integer) -> Integer
    column_index column =
        if column.is_an Integer then column else Java_Range.parseA1Column column

    ## Creates a Range from an address.
    from_address : Text -> Excel_Range
    from_address address =
        illegal_argument caught_panic = Error.throw (Illegal_Argument_Error caught_panic.payload.cause.getMessage  caught_panic.payload.cause)
        Panic.catch IllegalArgumentException handler=illegal_argument <|
            Excel_Range (Java_Range.new address)

    ## Create a Range for a single cell.
    for_cell : Text -> (Text|Integer) -> Integer -> Excel_Range
    for_cell sheet column row =
        col_index = Excel_Range.column_index column

        col_valid = here.validate (Excel_Range.is_valid_column col_index) ("Invalid column for Excel: " + column.to_text + ".")
        row_valid = here.validate (Excel_Range.is_valid_row row) ("Invalid row for Excel: " + row.to_text + ".")

        col_valid <| row_valid <|
            Excel_Range (Java_Range.new sheet col_index row)

    ## Create an Excel_Range for a range of cells.
    for_range : Text -> (Text|Integer) -> Integer -> (Text|Integer) -> Integer -> Excel_Range
    for_range sheet left top right bottom =
        left_index = Excel_Range.column_index left
        right_index = Excel_Range.column_index right

        left_valid = here.validate (Excel_Range.is_valid_column left_index) ("Invalid left column for Excel: " + left.to_text + ".")
        right_valid = here.validate (Excel_Range.is_valid_column right_index) ("Invalid right column for Excel: " + right.to_text + ".")
        top_valid = here.validate (Excel_Range.is_valid_row top) ("Invalid top row for Excel: " + top.to_text + ".")
        bottom_valid = here.validate (Excel_Range.is_valid_row bottom) ("Invalid bottom row for Excel: " + bottom.to_text + ".")

        left_valid <| right_valid <| top_valid <| bottom_valid <|
            Excel_Range (Java_Range.new sheet left_index top right_index bottom)

    ## Create an Excel_Range for a set of columns.
    for_columns : Text -> (Text|Integer) -> (Text|Integer) -> Excel_Range
    for_columns sheet left (right=left) =
        left_index = Excel_Range.column_index left
        right_index = Excel_Range.column_index right

        left_valid = here.validate (Excel_Range.is_valid_column left_index) ("Invalid left column for Excel: " + left.to_text + ".")
        right_valid = here.validate (Excel_Range.is_valid_column right_index) ("Invalid right column for Excel: " + right.to_text + ".")

        left_valid <| right_valid <|
            Excel_Range (Java_Range.forColumns sheet left_index right_index)

    ## Create an Excel_Range for a set of rows.
    for_rows : Text -> Integer -> Integer -> Excel_Range
    for_rows sheet top (bottom=top) =
        top_valid = here.validate (Excel_Range.is_valid_row top) ("Invalid top row for Excel: " + top.to_text + ".")
        bottom_valid = here.validate (Excel_Range.is_valid_row bottom) ("Invalid bottom row for Excel: " + bottom.to_text + ".")

        top_valid <| bottom_valid <|
            Excel_Range (Java_Range.forRows sheet top bottom)


## PRIVATE
   Wrapper for validation of a value prior to execution.
validate : Boolean -> Text -> Any
validate validation ~error_message ~wrapped =
    if validation then wrapped else Error.throw (Illegal_Argument_Error error_message)

## PRIVATE
   Reads an input Excel file according to the provided section.

   Arguments:
   - file: The File object to read.
   - section: The part of the Excel document to read.
   - on_problems: Specifies the behavior when a problem occurs during the
     operation. By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.
   - xls_format: If `True` then the file is read in using Excel 95-2003 format
     otherwise reads in Excel 2007+ format.
read_excel : File -> Excel_Section -> (Boolean|Infer) -> Problem_Behavior -> Boolean -> (Table | Vector)
read_excel file section headers on_problems xls_format=False =
    reader stream = case section of
        Sheet_Names -> Vector.Vector (ExcelReader.readSheetNames stream xls_format)
        Range_Names -> Vector.Vector (ExcelReader.readRangeNames stream xls_format)
        Sheet sheet skip_rows row_limit ->
            here.prepare_reader_table on_problems <| case sheet of
                Integer -> ExcelReader.readSheetByIndex stream sheet (here.make_java_headers headers) skip_rows row_limit xls_format
                Text -> ExcelReader.readSheetByName stream sheet (here.make_java_headers headers) skip_rows row_limit xls_format
        Cell_Range address skip_rows row_limit ->
            here.prepare_reader_table on_problems <| case address of
                Excel_Range _ -> ExcelReader.readRange stream address.java_range (here.make_java_headers headers) skip_rows row_limit xls_format
                Text -> ExcelReader.readRangeByName stream address (here.make_java_headers headers) skip_rows row_limit xls_format

    here.read_excel_file file reader

write_excel : File -> Table -> Existing_File_Behavior -> (Sheet | Cell_Range) -> (Boolean|Infer) -> Problem_Behavior -> Boolean
write_excel file table on_existing_file section headers _ xls_format=False =
    if on_existing_file == Existing_File_Behavior.Append then Errors.unimplemented "Appending to an existing File_Format.Delimited file is not implemented yet." else
        workbook = if file.exists.not then ExcelWriter.createWorkbook xls_format else
            here.read_excel_file file stream->(ExcelReader.getWorkbook stream xls_format)

        replace = (on_existing_file == Existing_File_Behavior.Overwrite) || (on_existing_file == Existing_File_Behavior.Backup)
        java_headers = here.make_java_headers headers
        if ExcelWriter.getEnsoToTextCallback == Nothing then ExcelWriter.getEnsoToTextCallback (.to_text)
        result = here.handle_writer <| case section of
            Sheet sheet skip_rows row_limit ->
                ExcelWriter.writeTableToSheet workbook sheet replace skip_rows table.java_table row_limit java_headers
            Cell_Range address skip_rows row_limit -> case address of
                Excel_Range _ -> ExcelWriter.writeTableToRange workbook address.java_range replace skip_rows table.java_table row_limit java_headers
                Text -> ExcelWriter.writeTableToRange workbook address replace skip_rows table.java_table row_limit java_headers

        if result.is_error then result else
            write_stream stream = stream.with_java_stream java_stream->
                workbook.write java_stream
            on_existing_file.write file write_stream

## PRIVATE
prepare_reader_table : Problem_Behavior -> Any -> Table
prepare_reader_table on_problems result_with_problems =
    map_problem java_problem =
        if Java.is_instance java_problem DuplicateNames then Duplicate_Output_Column_Names (Vector.Vector java_problem.duplicatedNames) else
              if Java.is_instance java_problem InvalidNames then Invalid_Output_Column_Names (Vector.Vector java_problem.invalidNames) else
                java_problem
    parsing_problems = Vector.Vector (result_with_problems.problems) . map map_problem
    on_problems.attach_problems_after (Table.Table result_with_problems.value) parsing_problems

## PRIVATE
   Convert Boolean|Infer to the correct HeaderBehavior
make_java_headers : (Boolean|Infer) -> ExcelHeaders.HeaderBehavior
make_java_headers headers = case headers of
        True -> ExcelHeaders.HeaderBehavior.USE_FIRST_ROW_AS_HEADERS
        Infer -> ExcelHeaders.HeaderBehavior.INFER
        False -> ExcelHeaders.HeaderBehavior.EXCEL_COLUMN_NAMES

## PRIVATE
read_excel_file file reader =
    bad_format caught_panic = Error.throw (File.Io_Error file caught_panic.payload.cause.getMessage)
    handle_bad_format = Panic.catch UnsupportedFileFormatException handler=bad_format

    bad_argument caught_panic = Error.throw (Invalid_Location caught_panic.payload.cause.getCause)
    handle_bad_argument = Panic.catch InvalidLocationException handler=bad_argument

    File.handle_java_exceptions file <| handle_bad_argument <| handle_bad_format <|
        file.with_input_stream [File.Option.Read] stream->
            stream.with_java_stream reader

## PRIVATE
handle_writer ~writer =
    bad_location caught_panic = Error.throw (Invalid_Location caught_panic.payload.cause.getCause)
    handle_bad_location = Panic.catch InvalidLocationException handler=bad_location

    throw_range_exceeded caught_panic = Error.throw (Range_Exceeded caught_panic.payload.cause.getMessage)
    handle_range_exceeded = Panic.catch RangeExceededException handler=throw_range_exceeded

    throw_existing_data caught_panic = Error.throw (Existing_Data caught_panic.payload.cause.getMessage)
    handle_existing_data = Panic.catch ExistingDataException handler=throw_existing_data

    throw_illegal_state caught_panic = Panic.throw (Illegal_State_Error caught_panic.payload.cause.getMessage)
    handle_illegal_state = Panic.catch IllegalStateException handler=throw_illegal_state

    handle_illegal_state <| handle_bad_location <| handle_range_exceeded <| handle_existing_data <| writer
