from Standard.Base import all
import Standard.Table

import Standard.Base.Error.Common as Errors
import Standard.Table.Data.Match_Columns
from Standard.Base.Error.Problem_Behavior as Problem_Behavior_Module import Problem_Behavior
from Standard.Base.Data.Text.Encoding as Encoding_Module import Encoding
import Standard.Base.Runtime.Ref
import Standard.Table.Internal.Delimited_Reader
import Standard.Table.Internal.Delimited_Writer
from Standard.Table.Errors as Table_Errors import Unsupported_File_Type

from Standard.Table.Data.Data_Formatter as Data_Formatter_Module import Data_Formatter
import Standard.Table.Io.Excel as Excel_Module
import Standard.Table.Io.Quote_Style

## This type needs to be here to allow for the usage of Standard.Table
   functions. Ideally, it would be an interface within Standard.Base and
   expanded by additional implementations in Standard.Table.

## Determines the format of file to use based on the file extension.
type Auto
    type Auto

    ## ADVANCED
       Gets the underlying File_Format for the specified file
    materialise : File->File_Format
    materialise file =
        extension = file.extension

        output = Ref.new Nothing
        if ".txt".equals_ignore_case extension then output.put File_Format.Plain_Text
        if ".log".equals_ignore_case extension then output.put File_Format.Plain_Text
        if ".csv".equals_ignore_case extension then output.put (File_Format.Delimited ',')
        if ".tsv".equals_ignore_case extension then output.put (File_Format.Delimited '\t')
        if ".xlsx".equals_ignore_case extension then output.put File_Format.Excel
        if ".xlsm".equals_ignore_case extension then output.put File_Format.Excel
        if ".xls".equals_ignore_case extension then output.put File_Format.Excel
        if ".xlt".equals_ignore_case extension then output.put File_Format.Excel

        output.get.if_nothing <|
            Error.throw (Unsupported_File_Type file.name)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        materialised = self.materialise file
        materialised.read file on_problems

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table file table on_existing_file match_columns on_problems =
        materialised = self.materialise file
        materialised.write_table file table on_existing_file match_columns on_problems

## Reads the file to a `Vector` of bytes.
type Bytes
    type Bytes

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file _ =
        file.read_bytes

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table _ _ _ _ _ =
        Error.throw (Illegal_Argument_Error "Saving a Table as Bytes is not supported.")

## Reads the file to a `Text` with specified encoding.
type Plain_Text
    type Plain_Text (encoding:Encoding=Encoding.utf_8)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        file.read_text self.encoding on_problems

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table _ _ _ _ _ =
        Error.throw (Illegal_Argument_Error "Saving a Table as Plain_Text is not directly supported. You may convert the Table to a Text using `Text.from` and then use `Text.write` to write it.")

## Read delimited files such as CSVs into a Table.
type Delimited
    ## Read delimited files such as CSVs into a Table.

       If a row does not match the first row's column count, the function raises
       an `Invalid_Row`. If a quote is opened and never closed, a
       `Mismatched_Quote` warning occurs.

       Arguments:
       - delimiter: The delimiter character to split the file into columns. An
         `Illegal_Argument_Error` error is returned if this is an empty string.
       - encoding: The encoding to use when reading the file.
       - skip_rows: The number of rows to skip from the top of the file.
       - row_limit: The maximum number of rows to read from the file. This count
         does not include the header row (if applicable).
       - quote_style: Specifies the style of quotes used for reading and
         writing.
       - headers: If set to `True`, the first row is used as column names. If
         set to `False`, the column names are generated by adding increasing
         numeric suffixes to the base name `Column` (i.e. `Column_1`,
         `Column_2` etc.). If set to `Infer`, the process tries to infer if
         headers are present on the first row. If the column names are not
         unique, numeric suffixes will be appended to disambiguate them.
       - value_formatter: Formatter to parse text values into numbers, dates,
         times, etc. If `Nothing` values are left as Text.
       - keep_invalid_rows: Specifies whether rows that contain less or more
         columns than expected should be kept (setting the missing columns to
         `Nothing` or dropping the excess columns) or dropped.
    type Delimited (delimiter:Text) (encoding:Encoding=Encoding.utf_8) (skip_rows:Integer=0) (row_limit:Integer|Nothing=Nothing) (quote_style:Quote_Style=Quote_Style.With_Quotes) (headers:Boolean|Infer=Infer) (value_formatter:Data_Formatter|Nothing=Data_Formatter) (keep_invalid_rows:Boolean=True)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        Delimited_Reader.read_file self file on_problems

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table file table on_existing_file match_columns on_problems =
        Delimited_Writer.write_file table self file on_existing_file match_columns on_problems

    ## PRIVATE
     Clone the instance with some properties overridden.
     Note: This function is internal until such time as Atom cloning with modification is built into Enso.
    clone : Text->Text->(Boolean|Infer)->Data_Formatter->Boolean->Delimited
    clone (quote_style=self.quote_style) (headers=self.headers) (value_formatter=self.value_formatter) (keep_invalid_rows=self.keep_invalid_rows) =
        Delimited self.delimiter self.encoding self.skip_rows self.row_limit quote_style headers value_formatter keep_invalid_rows

    ## Create a clone of this with specified quoting settings.
    with_quotes : Text->Text->Boolean->Delimited
    with_quotes quote='"' quote_escape=quote always_quote=False =
        self.clone quote_style=(Quote_Style.With_Quotes always_quote=always_quote quote=quote quote_escape=quote_escape)

    ## Create a clone of this with specified quoting settings.
    without_quotes : Delimited
    without_quotes =
        self.clone quote_style=Quote_Style.No_Quotes

    ## Create a clone of this with first row treated as header.
    with_headers : Delimited
    with_headers = self.clone headers=True

    ## Create a clone of this where the first row is treated as data, not a
       header.
    without_headers : Delimited
    without_headers = self.clone headers=False

    ## Create a clone of this with value parsing.

       A custom `Data_Formatter` can be provided to customize parser options.
    with_parsing : Data_Formatter -> Delimited
    with_parsing (value_formatter=Data_Formatter) =
        self.clone value_formatter=value_formatter

    ## Create a clone of this without value parsing.
    without_parsing : Delimited
    without_parsing =
        self.clone value_formatter=Nothing

## A setting to infer the default behaviour of some option.
type Infer

## Read the file to a `Table` from an Excel file
type Excel
    ## Read Excels files into a Table or Vector.

       Arguments:
       - section: The `Excel_Section` to read from the workbook.
         This can be one of:
         - `Sheet_Names` - outputs a `Vector` of sheet names.
         - `Range_Names` - outputs a `Vector` of range names.
         - `Sheet` - outputs a `Table` containing the specified sheet.
         - `Cell_Range` - outputs a `Table` containing the specified range.
       - headers: If set to `True`, the first row is used as column names. If
         set to `False`, the column names are Excel column names. If set to
         `Infer`, the process tries to infer if headers are present on the first
          row. If the column names are not unique, numeric suffixes will be
          appended to disambiguate them.
       - xls_format:
         If set to `True`, the file is read as an Excel 95-2003 format.
         If set to `False`, the file is read as an Excel 2007+ format.
         `Infer` will attempt to deduce this from the extension of the filename.
    type Excel (section:Excel_Section=Excel_Module.Sheet) (headers:(True|False|Infer)=Infer) (xls_format:(True|False|Infer)=Infer)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        format = Excel.is_xls_format self.xls_format file
        Excel_Module.read_excel file self.section self.headers on_problems format

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table file table on_existing_file match_columns on_problems =
        format = Excel.is_xls_format self.xls_format file

        case self.section of
            Excel_Module.Sheet_Names -> Error.throw (Illegal_Argument_Error "Sheet_Names cannot be used for `write`.")
            Excel_Module.Range_Names -> Error.throw (Illegal_Argument_Error "Range_Names cannot be used for `write`.")
            _ -> Excel_Module.write_excel file table on_existing_file self.section self.headers match_columns on_problems format

    ## PRIVATE
       Resolve the xls_format setting to a boolean.
    is_xls_format : (Boolean|Infer) -> File -> Boolean
    is_xls_format xls_format file =
        if xls_format != Infer then xls_format else
            extension = file.extension
            (extension.equals_ignore_case ".xls") || (extension.equals_ignore_case ".xlt")
