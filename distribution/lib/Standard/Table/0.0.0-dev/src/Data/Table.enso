from Standard.Base import all
import Standard.Base.Error.Common as Errors
from Standard.Base.Error.Problem_Behavior import Report_Warning
import Standard.Base.Data.Index_Sub_Range
import Standard.Base.Data.Ordering.Comparator
import Standard.Base.Data.Text.Case
import Standard.Base.System.Platform

import Standard.Table.Data.Column
import Standard.Table.Internal.Table_Helpers
import Standard.Table.Internal.Aggregate_Column_Helper
import Standard.Table.Internal.Parse_Values_Helper
import Standard.Table.Internal.Problem_Builder

from Standard.Table.IO.Auto_Detect import Auto_Detect

from Standard.Table.Delimited.Delimited_Format import Delimited_Format, Delimited
import Standard.Table.Delimited.Delimited_Reader
import Standard.Table.Delimited.Delimited_Writer

from Standard.Table.Data.Column_Selector import Column_Selector, By_Index, By_Name
from Standard.Table.Data.Column_Type_Selection import Column_Type_Selection, Auto
from Standard.Table.Data.Data_Formatter import Data_Formatter, Data_Formatter_Data
from Standard.Table.Errors import Missing_Input_Columns, Column_Indexes_Out_Of_Range, Duplicate_Type_Selector, No_Index_Set_Error, No_Such_Column_Error, No_Such_Column_Error_Data, No_Input_Columns_Selected, No_Output_Columns
import Standard.Table.Data.Match_Columns

import Standard.Table.Data.Column_Name_Mapping
import Standard.Table.Data.Position
import Standard.Table.Data.Sort_Column_Selector
import Standard.Table.Data.Sort_Column

import Standard.Table.Data.Aggregate_Column
import Standard.Visualization

polyglot java import org.enso.table.data.table.Table as Java_Table
polyglot java import org.enso.table.data.table.Column as Java_Column
polyglot java import org.enso.table.operations.OrderBuilder
polyglot java import org.enso.table.data.mask.OrderMask

## Creates a new table from a vector of `[name, items]` pairs.

   Arguments:
   - columns: The `[name, items]` pairs to construct a new table from.

   > Example
     Create a new table with the given columns.

         import Standard.Table

         example_new =
             first_column = ["count", [1, 2, 3]]
             second_column = ["is_valid", [True, False, True]]
             Table.new [first_column, second_column]
new : Vector (Vector | Column) -> Table
new columns =
    cols = columns.map c->
        case c of
            Vector.Vector -> Column.from_vector (c.at 0) (c.at 1) . java_column
            Column.Column_Data java_col -> java_col
    from_columns cols

## Creates a new table from a vector of column names and a vector of vectors
   specifying row contents.

   Arguments:
   - header: A list of texts specifying the column names
   - rows: A vector of vectors, specifying the contents of each table row. The
     length of each element of `rows` must be equal in length to `header`.

   > Example
     Create a table with 3 columns, named `foo`, `bar`, and `baz`, containing
     `[1, 2, 3]`, `[True, False, True]`, and `['a', 'b', 'c']`, respectively.

         import Standard.Table

         example_from_rows =
             header = [ 'foo' , 'bar' , 'baz' ]
             row_1 =  [ 1     , True  , 'a'   ]
             row_2 =  [ 2     , False , 'b'   ]
             row_3 =  [ 3     , True  , 'c'   ]
             Table.from_rows header [row_1, row_2, row_3]
from_rows : Vector.Vector -> Vector.Vector -> Table
from_rows header rows =
    columns = header.map_with_index i-> name-> [name, rows.map (_.at i)]
    new columns

## ALIAS Join Tables

   Joins a vector of tables (or columns) into a single table, using each table's
   index as the join key.

   Arguments:
   - tables: A vector of tables to join into a single table.

   Particularly useful for joining multiple columns derived from one original
   table into a new table.

   > Example
     Join multiple tables together. It joins tables on their indices, so we need
     to make sure the indices are correct.

         import Standard.Examples
         import Standard.Table

         example_join =
             table_1 = Examples.inventory_table
             table_2 = Examples.popularity_table
             Table.join [table_1, table_2]
join : Vector -> Table
join tables =
    tables.reduce .join

## UNSTABLE

   Concatenates multiple tables, resulting in a table with the number of rows
   being the sum of numbers of rows of `tables`. Any column that is present in
   some tables, but missing in others, will be `Nothing`-padded in the positions
   corresponding to the missing values.

   Arguments:
   - tables: the tables to concatenate.

   > Example
     Concatenate multiple tables together.

         import Standard.Examples
         import Standard.Table

         example_concat =
             table_1 = Examples.inventory_table
             table_2 = Examples.popularity_table
             Table.concat [table_1, table_2]
concat : Vector -> Table
concat tables =
    Table_Data (Java_Table.concat (tables.map .java_table).to_array)

# TODO Dubious constructor export
from project.Data.Table.Table import all
from project.Data.Table.Table export all

## Represents a column-oriented table data structure.
type Table

    ## PRIVATE

       A table.

       Arguments:
       - java_table: The internal java representation of the table.
    Table_Data java_table

    ## Returns a text containing an ASCII-art table displaying this data.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.
       - format_terminal: whether ANSI-terminal formatting should be used

       > Example
         Convert the table to a pretty-printed representation.

             import Standard.Examples

             example_display = Examples.inventory_table.display
    display : Integer -> Boolean -> Text
    display self show_rows=10 format_terminal=False =
        cols = Vector.from_polyglot_array self.java_table.getColumns
        index =  self.java_table.getIndex
        col_names = [index.getName] + cols.map .getName
        col_vals = cols.map .getStorage
        num_rows = self.row_count
        display_rows = Math.min num_rows show_rows
        rows = Vector.new display_rows row_num->
            cols = col_vals.map col->
                if col.isNa row_num then "Nothing" else Column.get_item_string col row_num
            [index.ilocString row_num] + cols
        table = print_table col_names rows 1 format_terminal
        if num_rows - display_rows <= 0 then table else
            missing = '\n\u2026 and ' + (num_rows - display_rows).to_text + ' hidden rows.'
            table + missing

    ## Prints an ASCII-art table with this data to the standard output.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.

       > Example
         Convert the table to a pretty-printed representation and print it to
         the console.

             import Standard.Examples

             example_print = Examples.inventory_table.print
    print self show_rows=10 =
        IO.println (self.display show_rows format_terminal=True)
        IO.println ''

    ## Converts this table to a JSON structure.

       > Example
         Convert a table to a corresponding JSON representation.

             import Standard.Examples

             example_to_json = Examples.inventory_table.to_json
    to_json : Json
    to_json self =
        index_prep = case self.index.catch No_Index_Set_Error (_->Nothing) of
            Nothing -> []
            index -> [index]
        cols = index_prep + self.columns
        rows = 0.up_to self.row_count . map row->
            vals_kv = cols.map col-> [col.name, col.at row]
            Json.from_pairs vals_kv
        rows.to_json

    ## UNSTABLE
       ADVANCED

       Returns a Text used to display this table in the IDE by default.

       Returns a JSON object containing useful metadata and previews of column
       values.
    to_default_visualization_data : Text
    to_default_visualization_data self =
        max_size = 10
        row_count = ['number_of_rows', self.row_count]
        cols = self.columns.map c->
            name = c.name
            items = c.to_vector.take (First max_size)
            Json.from_pairs [['name', name], ['data', items]]
        Json.from_pairs [row_count, ['columns', cols]] . to_text

    ## UNSTABLE
       ADVANCED

       Guides the visualization system to display the most suitable graphical
       representation for this table.
    default_visualization : Visualization.Id.Id
    default_visualization self =
        cols = self.columns.map .name . map name-> name.to_case Case.Lower
        if cols.contains "latitude" && cols.contains "longitude" then Visualization.Id.geo_map else
            if cols.contains "x" && cols.contains "y" then Visualization.Id.scatter_plot else
                Visualization.Id.table

    ## Returns the column with the given name.

       Arguments:
       - selector: The name or index of the column being looked up.

       > Example
         Get the names of all of the items from the shop inventory.

             import Standard.Examples

             example_at = Examples.inventory_table.at "item_name"

       > Example
         Get the last column.

             import Standard.Examples

             example_at = Examples.inventory_table.at -1
    at : Text | Integer -> Column ! No_Such_Column_Error | Index_Out_Of_Bounds_Error
    at self selector=0 = case selector of
        Integer ->
            java_columns = Vector.from_polyglot_array self.java_table.getColumns
            Column.Column_Data (java_columns.at selector)
        Text ->
            case self.java_table.getColumnOrIndexByName selector of
                Nothing -> Error.throw (No_Such_Column_Error_Data selector)
                c -> Column.Column_Data c

    ## Returns the number of columns in the table.
    column_count : Integer
    column_count self = self.java_table.getColumns.length

    ## Returns a new table with a chosen subset of columns, as specified by the
       `columns`, from the input table. Any unmatched input columns will be
       dropped from the output.

       Arguments:
       - columns: Column selection criteria.
       - reorder: By default, or if set to `False`, columns in the output will
         be in the same order as in the input table. If `True`, the order in the
         output table will match the order in the columns list.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Select columns by name.

             table.select_columns (By_Name ["bar", "foo"])

       ## TODO [RW] default arguments do not work on atoms, once this is fixed,
          the above should be replaced with just `By_Name`.
          See: https://github.com/enso-org/enso/issues/1600

       > Example
         Select columns matching a regular expression.

             table.select_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Select the first two columns and the last column, moving the last one to front.

             table.select_columns (By_Index [-1, 0, 1]) reorder=True

       > Example
         Select columns with the same names as the ones provided.

             table.select_columns (By_Column [column1, column2])

       Icon: select_column
    select_columns : Column_Selector -> Boolean -> Problem_Behavior -> Table
    select_columns self (columns = By_Index [0]) (reorder = False) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.select_columns internal_columns=self.columns selector=columns reorder=reorder on_problems=on_problems
        new new_columns

    ## Returns a new table with the chosen set of columns, as specified by the
       `columns`, removed from the input table. Any unmatched input columns will
       be kept in the output. Columns are returned in the same order as in the
       input.

       Arguments:
       - columns: Criteria specifying which columns should be removed.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Remove columns with given names.

             table.remove_columns (By_Name ["bar", "foo"])

       ## TODO [RW] default arguments do not work on atoms, once this is fixed,
          the above should be replaced with just `By_Name`.
          See: https://github.com/enso-org/enso/issues/1600

       > Example
         Remove columns matching a regular expression.

             table.remove_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Remove the first two columns and the last column.

             table.remove_columns (By_Index [-1, 0, 1])

       > Example
         Remove columns with the same names as the ones provided.

             table.remove_columns (By_Column [column1, column2])
    remove_columns : Column_Selector -> Problem_Behavior -> Table
    remove_columns self (columns = By_Index [0]) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.remove_columns internal_columns=self.columns selector=columns on_problems=on_problems
        new new_columns

    ## Returns a new table with the specified selection of columns moved to
       either the start or the end in the specified order.

       Arguments:
       - columns: Criteria specifying which columns should be reordered and
         specifying their order.
       - position: Specifies how to place the selected columns in relation to
         the remaining columns which were not matched by `columns` (if any).
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.

       > Example
         Move a column with a specified name to back.

             table.reorder_columns (By_Name ["foo"]) position=After_Other_Columns

       ## TODO [RW] default arguments do not work on atoms, once this is fixed,
          the above should be replaced with just `By_Name`.
          See: https://github.com/enso-org/enso/issues/1600

       > Example
         Move columns matching a regular expression to front, keeping columns matching "foo.+" before columns matching "b.*".

             table.reorder_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Swap the first two columns.

             table.reorder_columns (By_Index [1, 0]) position=Before_Other_Columns

       > Example
         Move the first column to back.

             table.reorder_columns (By_Index [0]) position=After_Other_Columns

       > Example
         Move the columns with names matching the provided columns to the front.

             table.reorder_columns (By_Column [column1, column2])
    reorder_columns : Column_Selector -> Position.Position -> Problem_Behavior -> Table
    reorder_columns self (columns = By_Index [0]) (position = Position.Before_Other_Columns) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.reorder_columns internal_columns=self.columns selector=columns position=position on_problems=on_problems
        new new_columns

    ## Returns a new table with the columns sorted by name according to the
       specified sort method. By default, sorting will be according to
       case-sensitive ascending order based on the `compare_to` operator for
       `Text`.

       Arguments:
       - direction: Whether sorting should be in ascending or descending order.
       - text_ordering: The sort methodology to use.

       > Example
         Sort columns according to the default ordering.

             table.sort_columns

       > Example
         Sort columns according to the natural case-insensitive ordering.

             table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)

       > Example
         Sort columns in descending order.

             table.reorder_columns Sort_Direction.Descending
    sort_columns : Sort_Direction -> Text_Ordering -> Table
    sort_columns self direction=Sort_Direction.Ascending text_ordering=Text_Ordering.Default =
        new_columns = Table_Helpers.sort_columns internal_columns=self.columns direction text_ordering
        new new_columns

    ## Returns a new table with the columns renamed based on either a mapping
       from the old name to the new or a positional list of new names.

       Arguments:
       - column_map: Mapping from old column names to new.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If in `By_Position` mode and more names than columns are provided,
           a `Too_Many_Column_Names_Provided`.
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the first column to "FirstColumn"

              table.rename_columns (Column_Name_Mapping.By_Position ["FirstColumn"])
    rename_columns : Column_Name_Mapping -> Problem_Behavior -> Table
    rename_columns self (column_map=(Column_Name_Mapping.By_Position ["Column"])) (on_problems=Report_Warning) =
        new_names = Table_Helpers.rename_columns internal_columns=self.columns mapping=column_map on_problems=on_problems
        if new_names.is_error then new_names else
            new_columns = self.columns.map_with_index i->c->(c.rename (new_names.at i))
            new new_columns

    ## Returns a new table with the columns renamed based on entries in the
       first row.

       Arguments:
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the column based on the first row

              table.use_first_row_as_names
    use_first_row_as_names : Problem_Behavior -> Table
    use_first_row_as_names self (on_problems=Report_Warning) =
        mapper = col->
            val = col.at 0
            case val of
                Text -> val
                Nothing -> Nothing
                _ -> val.to_text
        new_names = self.columns.map mapper
        self.drop (First 1) . rename_columns (Column_Name_Mapping.By_Position new_names) on_problems=on_problems

    ## ALIAS group, summarize

       Aggregates the rows in a table using any `Group_By` entries in columns.
       The columns argument specifies which additional aggregations to perform and to return.

       Arguments:
       - columns: Vector of `Aggregate_Column` specifying the aggregated table.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column name is not in the input table, a `Missing_Input_Columns`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If there are no valid columns in the output table, a `No_Output_Columns`.
         - If there are invalid column names in the output table, a `Invalid_Output_Column_Names`.
         - If there are duplicate column names in the output table, a `Duplicate_Output_Column_Names`.
         - If grouping on or computing the `Mode` on a floating point number, a `Floating_Point_Grouping`.
         - If an aggregation fails, an `Invalid_Aggregation_Method`.
         - If when concatenating values there is an quoted delimited, an `Unquoted_Delimiter`
         - If there are more than 10 issues with a single column, an `Additional_Warnings`.

       > Example
         Group by the Key column, count the rows

              table.aggregate [Group_By "Key", Count Nothing]
    aggregate : [Aggregate_Column] -> Problem_Behavior -> Table
    aggregate self columns (on_problems=Report_Warning) =
        validated = Aggregate_Column_Helper.prepare_aggregate_columns columns self

        on_problems.attach_problems_before validated.problems <| Illegal_Argument_Error.handle_java_exception <|
            java_key_columns = validated.key_columns.map .java_column
            index = self.java_table.indexFromColumns java_key_columns.to_array Comparator.new

            new_columns = validated.valid_columns.map c->(Aggregate_Column_Helper.java_aggregator c.first c.second)

            java_table = index.makeTable new_columns.to_array
            new_table = Table_Data java_table

            on_problems.attach_problems_after new_table <|
                problems = java_table.getProblems
                Aggregate_Column_Helper.parse_aggregated_problems problems

    ## Sorts the rows of the table according to the specified columns and order.

       Arguments:
       - columns: The columns and order to sort the table.
       - text_ordering: The ordering method to use on text values.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The following problems can occur:
         - If a column in `columns` is not present in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If two name matchers match the same column, a
           `Column_Matched_By_Multiple_Selectors`.
         - If no valid columns are selected, a `No_Input_Columns_Selected`.
         - If values do not implement an ordering, an
           `Incomparable_Values_Error`.

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`.

             table.order_by (Sort_Column_Selector.By_Name ['Quantity'])

       > Example
         Sorting `table` in descending order by the value in column `'Quantity'`.

             table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Quantity' Sort_Direction.Descending])

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`,
         using the value in column `'Rating'` for breaking ties.

             table.order_by (Sort_Column_Selector.By_Name ['Quantity', 'Rating'])

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`,
         using the value in column `'Rating'` in descending order for breaking
         ties.

             table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Quantity', Sort_Column.Name 'Rating' Sort_Direction.Descending])

       > Example
         Order the table by the second column in ascending order. In case of any
         ties, break them based on the 7th column from the end of the table in
         descending order.

             table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index -7 Sort_Direction.Descending])

       > Example
         Sorting the shop inventory based on the per-item price in ascending
         order.

             import Standard.Examples

             example_sort = Examples.inventory_table.order_by (Sort_Column_Selector.By_Name ["price"])

       > Example
         Sort the shop inventory based on the per-item price in descending order

             import Standard.Examples

             example_sort =
                table = Examples.inventory_table
                table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "price" Sort_Direction.Descending])

       > Example
         Sort the shop inventory based on the total stock, using the number sold
         to break ties in descending order.

             import Standard.Examples

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "total_stock" Sort_Direction.Descending, Sort_Column.Name "sold_stock" Sort_Direction.Descending])

       > Example
         Sort the shop inventory in ascending order by the total stock, using
         the number of items sold in descending order to break ties.

             import Standard.Examples
             import Standard.Table

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name ["total_stock", Sort_Column.Name "sold_stock" Sort_Direction.Descending])

    order_by : Sort_Column_Selector -> Text_Ordering -> Problem_Behavior -> Table ! Incomparable_Values_Error
    order_by self (columns = (Sort_Column_Selector.By_Name [(Sort_Column.Name (self.columns.at 0 . name))])) text_ordering=Text_Ordering.Default on_problems=Report_Warning =
        problem_builder = Problem_Builder.new
        columns_for_ordering = Table_Helpers.prepare_order_by self.columns columns problem_builder
        problem_builder.attach_problems_before on_problems <|
            selected_columns = columns_for_ordering.map c->c.column.java_column
            ordering = columns_for_ordering.map c->c.associated_selector.direction.to_sign
            comparator = Comparator.for_text_ordering text_ordering
            java_table = Illegal_Argument_Error.handle_java_exception <| Vector.handle_incomparable_value <|
                self.java_table.orderBy selected_columns.to_array ordering.to_array comparator
            Table_Data java_table

    ## Returns the distinct set of rows within the specified columns from the
       input table.

       When multiple rows have the same values within the specified columns, the
       first row of each such set is returned.

       For the in-memory table, the unique rows will be in the order they
       occurred in the input (this is not guaranteed for database operations).

       Arguments:
       - columns: The columns of the table to use for distinguishing the rows.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If no valid columns are selected, a `No_Input_Columns_Selected`.
         - If floating points values are present in the distinct columns, a
           `Floating_Point_Grouping` warning.
    distinct : Column_Selector -> Case_Sensitivity -> Problem_Behavior -> Table
    distinct self (columns = By_Name (self.columns.map .name)) case_sensitivity=Case_Sensitivity.Sensitive on_problems=Report_Warning =
        warning_mapper error = case error of
            No_Output_Columns -> Maybe.Some No_Input_Columns_Selected
            _ -> Nothing
        key_columns = Warning.map_warnings_and_errors warning_mapper <|
            Table_Helpers.select_columns internal_columns=self.columns selector=columns reorder=True on_problems=on_problems
        java_columns = key_columns.map .java_column
        text_folding_strategy = Case.folding_strategy case_sensitivity
        java_table = Illegal_Argument_Error.handle_java_exception <|
            self.java_table.distinct java_columns.to_array text_folding_strategy
        on_problems.attach_problems_after (Table_Data java_table) <|
            problems = java_table.getProblems
            Aggregate_Column_Helper.parse_aggregated_problems problems


    ## Parses columns within a Table to a specific value type.
       By default, it looks at all `Text` columns and attempts to deduce the
       type (columns with other types are not affected). If `column_types` are
       provided, only selected columns are parsed, according to the specified
       type.

       The default parser options only parse values where the process is
       reversible (e.g., 0123 would not be converted to an integer as there is
       a leading 0). However, settings in the `Data_Formatter` can
       control this.
    parse_values : Data_Formatter -> (Nothing | [Column_Type_Selection]) -> Problem_Behavior -> Table
    parse_values self value_formatter=Data_Formatter_Data column_types=Nothing on_problems=Report_Warning =
        columns = self.columns
        problem_builder = Vector.new_builder

        find_datatype index column =
            matching_input = column_types.filter selection->
                selector = selection.column
                case selector of
                    Text -> column.name == selector
                    Integer -> if selector >= 0 then index == selector else
                        index == columns.length + selector
            if matching_input.length == 0 then Nothing else
                if matching_input.length == 1 then matching_input.first.datatype else
                    first_type = matching_input.first.datatype
                    ambiguous = matching_input.exists s-> s.datatype != first_type
                    problem_builder.append (Duplicate_Type_Selector column.name ambiguous)
                    if ambiguous then Nothing else first_type

        expected_types = case column_types of
            Nothing -> columns.map _->Auto
            _ ->
                missing_columns = Vector.new_builder
                invalid_indices = Vector.new_builder
                column_types.each selection->
                    selector = selection.column
                    case selector of
                        Integer ->
                            valid = Table_Helpers.is_index_valid columns.length selector
                            if valid.not then
                                invalid_indices.append selector
                        Text ->
                            found = columns.exists col-> col.name == selector
                            if found.not then
                                missing_columns.append selector
                if missing_columns.is_empty.not then
                    problem_builder.append (Missing_Input_Columns missing_columns.to_vector)
                if invalid_indices.is_empty.not then
                    problem_builder.append (Column_Indexes_Out_Of_Range invalid_indices.to_vector)
                columns.map_with_index find_datatype

        new_columns = columns.zip expected_types column-> expected_type-> case expected_type of
            Nothing -> column
            _ ->
                parser = if expected_type == Auto then value_formatter.make_auto_parser else
                    value_formatter.make_datatype_parser expected_type
                storage = column.java_column.getStorage
                new_storage_and_problems = parser.parseColumn column.name storage
                new_storage = new_storage_and_problems.value
                problems = Vector.from_polyglot_array new_storage_and_problems.problems . map (Parse_Values_Helper.translate_parsing_problem expected_type)
                problems.each problem_builder.append
                Column.Column_Data (Java_Column.new column.name column.java_column.getIndex new_storage)

        ## TODO [RW] this case of is a workaround for wrong dataflow handling on arrays, it can be removed once the PR fixing it is merged, the relevant PR is:
           https://github.com/enso-org/enso/pull/3400
        result = new new_columns
        on_problems.attach_problems_after result problem_builder.to_vector

    ## ALIAS Filter Rows
       ALIAS Mask Columns

       Selects only the rows of this table that correspond to `True` values in
       `indexes`.

       Arguments:
       - indexes: The column to mask the table by. This column should contain
         boolean values (`True` or `False`) that determine whether or not the
         corresponding row is kept.

       This is useful for filtering the rows by given predicate.

       > Example
         Select only the items where more than half the stock has been sold.

             import Standard.Examples

             example_where =
                 table = Examples.inventory_table
                 mask = (table.at "sold_stock" > (table.at "total_stock" / 2))
                 table.where mask
    where : Column -> Table
    where self indexes =
        Table_Data (self.java_table.mask indexes.java_column)

    ## UNSTABLE
       Creates a new Table with the specified range of rows from the input
       Table.

       Arguments:
       - range: The selection of rows from the table to return.
    take : (Index_Sub_Range | Range) -> Table
    take self range=(First 1) =
        at _ = unimplemented "Table.take While cannot be implemented before the Row type is."
        Index_Sub_Range.take_helper self.row_count at self.slice (slice_ranges self) range

    ## UNSTABLE
       Creates a new Table from the input with the specified range of rows
       removed.

       Arguments:
       - range: The selection of rows from the table to remove.
    drop : (Index_Sub_Range | Range) -> Table
    drop self range=(First 1) =
        at _ = unimplemented "Table.take While cannot be implemented before the Row type is."
        Index_Sub_Range.drop_helper self.row_count at self.slice (slice_ranges self) range

    ## ALIAS Add Column

       Sets the column value at the given name.

       Arguments:
       - name: The name of the column to set the value of.
       - column: The new value for the column called `name`.

       If a column with the given name already exists, it will be replaced.
       Otherwise a new column is added.

       > Example
         Create a table where the values of the total stock in the inventory is
         doubled.

             import Standard.Examples

             example_set =
                 table = Examples.inventory_table
                 double_inventory = table.at "total_stock" * 2
                 table.set "total_stock" double_inventory
    set : Text -> Column.Column | Vector.Vector -> Table
    set self name column = case column of
        Vector.Vector ->
            self.set name (Column.from_vector name column)
        Column.Column_Data _ ->
            Table_Data (self.java_table.addOrReplaceColumn (column.rename name . java_column))

    ## Returns the vector of columns contained in this table.

       > Examples
         Get a vector containing the columns in the table.

             import Standard.Examples

             example_columns = Examples.inventory_table.columns
    columns : Vector
    columns self = Vector.from_polyglot_array self.java_table.getColumns . map Column.Column_Data

    ## Sets the index of this table, using the column with the provided name.

       Arguments:
       - index: The name of the column to use as the index in this table, or the
         column itself to use.

       > Example
         Set the index of the inventory table to be the item name.

             import Standard.Examples

             example_set_index = Examples.inventory_table.set_index "item_name"
    set_index : Text | Column -> Table
    set_index self index = case index of
        Text -> Table_Data (self.java_table.indexFromColumn index)
        Column.Column_Data c -> Table_Data (self.java_table.indexFromColumn c)

    ## Returns the index of this table, as a column that is indexed by itself.

       Throws `No_Index_Set_Error` if there is no index set in the table it is
       being called on.

       > Example
         Get the column that is used as the index for a table.

             import Standard.Examples

             example_index = Examples.inventory_table.index
    index : Column.Column ! No_Index_Set_Error
    index self = case self.java_table.getIndex.toColumn of
        Nothing -> Error.throw No_Index_Set_Error
        i -> Column.Column_Data i

    ## ALIAS Join Table

       Efficiently joins two tables based on either the index or the specified
       key column.

       Arguments:
       - other: The table being the right operand of this join operation.
       - on: The column of `self` that should be used as the join key. If this
         argument is not provided, the index of `self` will be used.
       - drop_unmatched: Whether the rows of `self` without corresponding
         matches in `other` should be dropped from the result.
       - left_suffix: A suffix that should be added to the columns of `self`
         when there's a name conflict with a column of `other`.
       - right_suffix: A suffix that should be added to the columns of `other`
         when there's a name conflict with a column of `self`.

       The resulting table contains rows of `self` extended with rows of
       `other` with matching indexes. If the index values in `other` are not
       unique, the corresponding rows of `self` will be duplicated in the
       result.

       > Example
         Join the popularity table and the inventory table to see the relative
         popularities of the items in the shop inventory.

             import Standard.Examples

             example_join =
                 Examples.inventory_table.join Examples.popularity_table

       Icon: join
    join : Table | Column.Column -> Text | Nothing -> Boolean -> Text -> Text -> Table
    join self other on=Nothing drop_unmatched=False left_suffix='_left' right_suffix='_right' =
        case other of
            Column.Column_Data _ -> self.join other.to_table on drop_unmatched left_suffix right_suffix
            Table_Data t ->
                Table_Data (self.java_table.join t drop_unmatched on left_suffix right_suffix)

    ## ALIAS Clean Rows

       Returns a new Table without rows that contained missing values in any of
       the columns.

       > Example
         Remove any rows that contain missing values from the table.

             import Standard.Examples

             example_drop_missing_rows =
                 Examples.inventory_table.drop_missing_rows
    drop_missing_rows : Table
    drop_missing_rows self =
        cols = self.columns
        case cols.not_empty of
            True ->
                any_missing_mask = cols.map .is_missing . reduce (||)
                non_missing_mask = any_missing_mask.not
                self.where non_missing_mask
            False -> self

    ## ALIAS Clean Columns

       Returns a new Table without columns that contained any missing values.

       > Example
         Remove any columns that contain missing values from the table.

             import Standard.Examples

             example_drop_missing_cols =
                 Examples.inventory_table.drop_missing_columns
    drop_missing_columns : Table
    drop_missing_columns self =
        non_missing = self.columns . filter (col -> col.count_missing == 0)
        index = self.java_table.getIndex
        Table_Data (Java_Table.new (non_missing.map .java_column . to_array) index)

    ## Returns the number of rows in this table.

       > Example
         Count the number of rows in the table.

             import Standard.Examples

             example_row_count = Examples.inventory_table.row_count
    row_count : Integer
    row_count self = self.java_table.rowCount

    ## Returns a Table describing this table's contents.

       The table lists all columns, counts of non-null items and storage types
       of each column.

       > Example
         Get information about a table.

             import Standard.Examples

             example_info = Examples.inventory_table.info
    info : Table
    info self =
        cols = self.columns
        new [["Column", cols.map .name], ["Items Count", cols.map .count], ["Storage Type", cols.map .storage_type]] . set_index "Column"

    ## UNSTABLE

       Concatenates `other` to `self`.

       Arguments:
       - other: The table to concatenate to `self`.

       Any column that is present in one table, but missing in another, will be
       `Nothing`-padded in the positions corresponding to the missing column.

       > Example
         Concatenate two tables together.

             import Standard.Examples

             example_concat =
                 Examples.inventory_table.concat Examples.popularity_table
    concat : Table -> Table
    concat self other = Table_Data (Java_Table.concat [self.java_table, other.java_table].to_array)

    ## PRIVATE
       Returns a table with a continuous sub-range of rows taken.
    slice : Integer -> Integer -> Table
    slice self start end =
        length = self.row_count
        offset = Math.max (Math.min start length) 0
        limit = Math.max (Math.min (end - offset) (length - offset)) 0
        Table_Data (self.java_table.slice offset limit)

    ## UNSTABLE

       Returns a table containing the rows of `self` table with their order
       reversed.

       > Example
         Reverse the rows in a table.

             import Standard.Examples

             example_reverse = Examples.inventory_table.reverse
    reverse : Table
    reverse self =
        mask = OrderBuilder.buildReversedMask self.row_count
        Table_Data <| self.java_table.applyMask mask

    ## ALIAS Write JSON
       UNSTABLE

       Writes this table to a specified file, serialized into JSON. The JSON
       serialization is such that the result is an array, in which every entry
       is an object representing a single row, with column names as keys.

       Arguments:
       - file: the file to write data to. If the file exists, it will be
         overwritten.

       > Example
         Write a table to a JSON file.

             import Standard.Examples

             example_to_json = Examples.inventory_table.write_json (enso_project.data / 'example.json')
    write_json : File.File -> Nothing
    write_json self file = self.to_json.to_text.write file

    ## This function writes a table from memory into a file.

       The specific behavior of the various `File_Format`s is specified below.

       Arguments:
       - path: The path to the output file.
       - format: The format of the file.
         If `Auto_Detect` is specified; the provided file determines the
         specific type and configures it appropriately. Details of this type are
         below.
       - on_existing_file: Specified how to handle if the file already exists.
       - match_columns: Specifies how to match columns against an existing file.
         If `Match_Columns.By_Name` - the columns are mapped by name against an
         existing file. If there is a mismatch, then a `Column_Name_Mismatch`
         error is raised.
         If `Match_Columns.By_Position` - the columns are mapped by position
         against an existing file. If there is a mismatch, then a
         `Column_Count_Mismatch` error is raised.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The specific issues depend on the `File_Format`
         argument.

       Returns:
       - If an unsupported `File_Format` is specified, an
         `Illegal_Argument_Error` is raised.
       - If the path to the parent location cannot be found or the filename is
         invalid, a `File_Not_Found` is raised.
       - If another IO error occurs, such as access denied, an `IO_Error` is
         raised.
       - If appending and the columns do not match, a `Column_Mismatch` is
         raised.
       - Other specific errors or warnings that can be raised depend on the
         format argument.
       - Otherwise, the file is loaded following the rules of the format
         parameter.

       ? `File_Format` write behaviors

         - `Auto_Detect`: The file format is determined by the provided file.
         - `Bytes` and `Plain_Text`: The Table does not support these types in
           the `write` function. If passed as format, an
           `Illegal_Argument_Error` is raised. To write out the table as plain
           text, the user needs to call the `Text.from Table` method and then
           use the `Text.write` function.

       > Example
         Write a table to a CSV file, without writing the header.

             import Standard.Examples
             import Standard.Table
             from Standard.Table import Delimited

             example_to_csv = Examples.inventory_table.write (Enso_Project.data / "example_csv_output.csv") (Delimited delimiter="," headers=False)

       > Example
         Write a table to an XLSX file.

             import Standard.Examples
             import Standard.Table
             from Standard.Table import Excel

             example_to_xlsx = Examples.inventory_table.write (enso_project.data / "example_xlsx_output.xlsx") Excel
    write : File|Text -> File_Format -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing ! Column_Mismatch | Illegal_Argument_Error | File_Not_Found | IO_Error
    write self path format=Auto_Detect on_existing_file=Existing_File_Behavior.Backup match_columns=Match_Columns.By_Name on_problems=Report_Warning =
        format.write_table (File.new path) self on_existing_file match_columns on_problems

    ## Creates a text representation of the table using the CSV format.
    to_csv : Text
    to_csv self = Text.from self (Delimited delimiter=",")

## UNSTABLE

   An error returned when the table contains no rows.
type Empty_Error
    ## PRIVATE

       Pretty prints the empty table error.
    to_display_text : Text
    to_display_text self = "The table is empty."

## PRIVATE
from_columns cols = Table_Data (Java_Table.new cols.to_array)

## PRIVATE

   Ensures that the `txt` has at least `len` characters by appending spaces at
   the end.

   Arguments:
   - txt: The text to pad.
   - len: The minimum length of the text.
pad : Text -> Integer -> Text
pad txt len =
    true_len = txt.characters.length
    txt + (" ".repeat (len - true_len))

## PRIVATE

   Adds ANSI bold escape sequences to text if the feature is enabled.

   Arguments:
   - enabled: will insert ANSI sequences only if this flag is true and we are not on Windows.
   - txt: The text to possibly bold.
ansi_bold : Boolean -> Text -> Text
ansi_bold enabled txt =
    case Platform.os of
        ## Output formatting for Windows is not currently supported.
        Platform.Windows -> txt
        _ -> if enabled then '\e[1m' + txt + '\e[m' else txt

## PRIVATE

   A helper function for creating an ASCII-art representation of tabular data.

   Arguments:
   - header: vector of names of columns in the table.
   - rows: a vector of rows, where each row is a vector that contains a text
     representation of each cell
   - indices_count: the number specifying how many columns should be treated as
     indices; this will make them in bold font if `format_term` is enabled.
   - format_term: a boolean flag, specifying whether to use ANSI escape codes
     for rich formatting in the terminal.
print_table : Vector Text -> (Vector (Vector Text)) -> Integer -> Boolean -> Text
print_table header rows indices_count format_term =
    content_lengths = Vector.new header.length i->
        max_row = 0.up_to rows.length . fold 0 a-> j-> Math.max a (rows.at j . at i . characters . length)
        Math.max max_row (header.at i . characters . length)
    header_line = header.zip content_lengths pad . map (ansi_bold format_term) . join ' | '
    divider = content_lengths . map (l -> "-".repeat l+2) . join '+'
    row_lines = rows.map r->
        x = r.zip content_lengths pad
        ixes = x.take (First indices_count) . map (ansi_bold format_term)
        with_bold_ix = ixes + x.drop (First indices_count)
        y = with_bold_ix . join ' | '
        " " + y
    ([" " + header_line, divider] + row_lines).join '\n'

Table.from (that : Text) (format:Delimited_Format = Delimited '\t') (on_problems:Problem_Behavior=Report_Warning) =
    if format.is_a Delimited then Delimited_Reader.read_text that format on_problems else
        Errors.unimplemented "Table.from for fixed-width files is not yet implemented."

Text.from (that : Table) (format:Delimited_Format = Delimited '\t') =
    if format.is_a Delimited then Delimited_Writer.write_text that format else
        Errors.unimplemented "Text.from for fixed-width files is not yet implemented."

## PRIVATE
   A helper to create a new table consisting of slices of the original table.
slice_ranges table ranges =
    normalized = Index_Sub_Range.normalize_ranges ranges
    Table_Data (table.java_table.slice normalized.to_array)
