//! Code for module-level double representation processing.

use crate::prelude::*;
use enso_text::index::*;

use crate::alias_analysis;
use crate::definition;
use crate::definition::DefinitionProvider;
use crate::definition::EmptyDefinitionId;
use crate::identifier;
use crate::identifier::Identifier;
use crate::import;
use crate::name::NamePath;
use crate::name::QualifiedName;

use ast::crumbs::ChildAst;
use ast::crumbs::Located;
use ast::crumbs::ModuleCrumb;
use ast::known;
use ast::BlockLine;
use engine_protocol::language_server;
use std::fmt::Formatter;



// ==============
// === Errors ===
// ==============

#[derive(Copy, Clone, Debug, Fail)]
#[fail(display = "Id segment list is empty.")]
#[allow(missing_docs)]
pub struct EmptySegments;

#[derive(Clone, Debug, Fail)]
#[fail(display = "Import `{}` was not found in the module.", _0)]
#[allow(missing_docs)]
pub struct ImportNotFound(pub String);

#[derive(Clone, Copy, Debug, Fail)]
#[fail(display = "Import with ID `{}` was not found in the module.", _0)]
#[allow(missing_docs)]
pub struct ImportIdNotFound(pub import::Id);

#[derive(Clone, Copy, Debug, Fail)]
#[fail(display = "Line index is out of bounds.")]
#[allow(missing_docs)]
pub struct LineIndexOutOfBounds;

#[allow(missing_docs)]
#[derive(Fail, Clone, Debug)]
#[fail(display = "Cannot find method with pointer {:?}.", _0)]
pub struct CannotFindMethod(language_server::MethodPointer);

#[allow(missing_docs)]
#[derive(Fail, Clone, Debug)]
#[fail(display = "The definition with crumbs {:?} is not a direct child of the module.", _0)]
pub struct NotDirectChild(ast::Crumbs);



// ==========
// === Id ===
// ==========

/// The segments of module name. Allow finding module in the project.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Id {
    /// The last segment being a module name. For project's main module it should be equal
    /// to [`PROJECTS_MAIN_MODULE`].
    pub name:           ImString,
    /// The segments of all parent modules, from the top module to the direct parent. Does **not**
    /// include project name.
    pub parent_modules: Vec<ImString>,
}

impl Id {
    /// Create module id from list of segments. The list shall not contain the project name nor
    /// namespace. Fails if the list is empty (the module name is required).
    pub fn try_from_segments(
        segments: impl IntoIterator<Item: Into<ImString>>,
    ) -> FallibleResult<Self> {
        let mut segments = segments.into_iter().map(Into::into).collect_vec();
        let name = segments.pop().ok_or(EmptySegments)?;
        Ok(Self { name, parent_modules: segments })
    }

    /// Return the iterator over id's segments.
    pub fn segments(&self) -> impl Iterator<Item = &ImString> {
        self.parent_modules.iter().chain(iter::once(&self.name))
    }
}

impl IntoIterator for Id {
    type Item = ImString;
    type IntoIter = impl Iterator<Item = Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.parent_modules.into_iter().chain(iter::once(self.name))
    }
}

impl From<Id> for NamePath {
    fn from(id: Id) -> Self {
        id.into_iter().collect()
    }
}

impl Display for Id {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.segments().format("."))
    }
}


// ============
// === Info ===
// ============

/// Wrapper allowing getting information about the module and updating it.
#[derive(Clone, Debug)]
pub struct Info {
    #[allow(missing_docs)]
    pub ast: known::Module,
}

impl Info {
    /// Generate a name for a definition that can be introduced without side-effects.
    ///
    /// The name shall be generated by appending number to the given base string.
    pub fn generate_name(&self, base: &str) -> FallibleResult<Identifier> {
        let used_names = self.used_names();
        let used_names = used_names.into_iter().map(|name| name.item);
        identifier::generate_name(base, used_names)
    }

    /// Identifiers introduced or referred to in the module's scope.
    ///
    /// Introducing identifier not included on this list should have no side-effects on the name
    /// resolution in the code in this graph.
    pub fn used_names(&self) -> Vec<Located<String>> {
        let usage = alias_analysis::analyze_crumbable(self.ast.shape());
        usage.all_identifiers()
    }

    /// Iterate over all lines in module that contain an import declaration.
    pub fn enumerate_imports(&self) -> impl Iterator<Item = (ModuleCrumb, import::Info)> + '_ {
        let children = self.ast.shape().enumerate();
        children.filter_map(|(crumb, ast)| Some((crumb, import::Info::from_ast(ast)?)))
    }

    /// Iterate over all import declarations in the module.
    ///
    /// If the caller wants to know *where* the declarations are, use `enumerate_imports`.
    pub fn iter_imports(&self) -> impl Iterator<Item = import::Info> + '_ {
        self.enumerate_imports().map(|(_, import)| import)
    }

    /// Check if module contains import with given id.
    pub fn contains_import(&self, id: import::Id) -> bool {
        self.iter_imports().any(|import| import.id() == id)
    }

    /// Add a new line to the module's block.
    ///
    /// Note that indices are the "module line" indices, which usually are quite different from text
    /// API line indices (because nested blocks doesn't count as separate "module lines").
    pub fn add_line(&mut self, index: usize, ast: Option<Ast>) {
        let line = BlockLine::new(ast);
        self.ast.update_shape(|shape| shape.lines.insert(index, line))
    }

    /// Remove line with given index.
    ///
    /// Returns removed line. Fails if the index is out of bounds.
    pub fn remove_line(&mut self, index: usize) -> FallibleResult<BlockLine<Option<Ast>>> {
        self.ast.update_shape(|shape| {
            shape.lines.try_remove(index).ok_or_else(|| LineIndexOutOfBounds.into())
        })
    }

    /// Remove a line that matches given import description.
    ///
    /// If there is more than one line matching, only the first one will be removed.
    /// Fails if there is no import matching given argument.
    pub fn remove_import(&mut self, to_remove: &import::Info) -> FallibleResult {
        let lookup_result = self.enumerate_imports().find(|(_, import)| import == to_remove);
        let (crumb, _) = lookup_result.ok_or_else(|| ImportNotFound(to_remove.to_string()))?;
        self.remove_line(crumb.line_index)?;
        Ok(())
    }

    /// Remove a line that matches given import ID.
    ///
    /// If there is more than one line matching, only the first one will be removed.
    /// Fails if there is no import matching given argument.
    pub fn remove_import_by_id(&mut self, to_remove: import::Id) -> FallibleResult {
        let lookup_result = self.enumerate_imports().find(|(_, import)| import.id() == to_remove);
        let (crumb, _) = lookup_result.ok_or(ImportIdNotFound(to_remove))?;
        self.remove_line(crumb.line_index)?;
        Ok(())
    }

    /// Add a new import declaration to a module.
    ///
    /// This function will try to keep imports in lexicographic order. It returns the index where
    /// import was added (index of import - an element on the list returned by `enumerate_imports`).
    // TODO [mwu]
    //   Ideally we should not require parser but should use some sane way of generating AST from
    //   the `ImportInfo` value.
    pub fn add_import(&mut self, parser: &parser_scala::Parser, to_add: import::Info) -> usize {
        // Find last import that is not "after" the added one lexicographically.
        let previous_import =
            self.enumerate_imports().take_while(|(_, import)| &to_add > import).last();

        let index_to_place_at = previous_import.map_or(0, |(crumb, _)| crumb.line_index + 1);
        let import_ast = parser.parse_line_ast(to_add.to_string()).unwrap();
        self.add_line(index_to_place_at, Some(import_ast));
        index_to_place_at
    }

    /// Add a new import declaration to a module.
    ///
    /// For more details the mechanics see [`add_import`] documentation.
    pub fn add_import_if_missing(
        &mut self,
        parser: &parser_scala::Parser,
        to_add: import::Info,
    ) -> Option<usize> {
        (!self.contains_import(to_add.id())).then(|| self.add_import(parser, to_add))
    }

    /// Place the line with given AST in the module's body.
    ///
    /// Unlike `add_line` (which is more low-level) will introduce empty lines around introduced
    /// line and describes the added line location in relation to other definitions.
    ///
    /// Typically used to place lines with definitions in the module.
    pub fn add_ast(&mut self, ast: Ast, location: Placement) -> FallibleResult {
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        enum BlankLinePlacement {
            Before,
            After,
            None,
        }
        let blank_line = match location {
            _ if self.ast.lines.is_empty() => BlankLinePlacement::None,
            Placement::Begin => BlankLinePlacement::After,
            Placement::End => BlankLinePlacement::Before,
            Placement::After(_) => BlankLinePlacement::Before,
            Placement::Before(_) => BlankLinePlacement::After,
        };

        let mut index = match location {
            Placement::Begin => 0,
            Placement::End => self.ast.lines.len(),
            Placement::Before(next_def) => locate_line_with(&self.ast, &next_def)?.line_index,
            Placement::After(next_def) => locate_line_with(&self.ast, &next_def)?.line_index + 1,
        };

        let mut add_line = |ast_opt: Option<Ast>| {
            self.add_line(index, ast_opt);
            index += 1;
        };

        if blank_line == BlankLinePlacement::Before {
            add_line(None);
        }
        add_line(Some(ast));
        if blank_line == BlankLinePlacement::After {
            add_line(None);
        }

        Ok(())
    }

    /// Add a new method definition to the module.
    pub fn add_method(
        &mut self,
        method: definition::ToAdd,
        location: Placement,
        parser: &parser_scala::Parser,
    ) -> FallibleResult {
        let no_indent = 0;
        let definition_ast = method.ast(no_indent, parser)?;
        self.add_ast(definition_ast, location)
    }

    /// Updates the given definition using the passed invokable.
    pub fn update_definition(
        &mut self,
        id: &definition::Id,
        f: impl FnOnce(definition::DefinitionInfo) -> FallibleResult<definition::DefinitionInfo>,
    ) -> FallibleResult {
        let definition = locate(&self.ast, id)?;
        let new_definition = f(definition.item)?;
        let new_ast = new_definition.ast.into();
        self.ast = self.ast.set_traversing(&definition.crumbs, new_ast)?;
        Ok(())
    }

    #[cfg(test)]
    pub fn expect_code(&self, expected_code: impl AsRef<str>) {
        assert_eq!(self.ast.repr(), expected_code.as_ref());
    }
}

impl From<known::Module> for Info {
    fn from(ast: known::Module) -> Self {
        Info { ast }
    }
}



// =================
// === Placement ===
// =================

/// Structure describing where to place something being added to the module.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Placement {
    /// Place at the beginning of the module.
    Begin,
    /// Place at the end of the module.
    End,
    /// Place after given definition;
    Before(definition::Crumb),
    /// Place before given definition;
    After(definition::Crumb),
}



// =======================
// === ChildDefinition ===
// =======================

/// Represents information about a definition being a direct child of this module, including its
/// location.
///
/// Internally it is `definition::ChildDefinition` with only a single `ModuleCrumb` as location.
#[derive(Clone, Debug, Shrinkwrap)]
pub struct ChildDefinition(definition::ChildDefinition);

impl ChildDefinition {
    fn try_retrieving_crumb(child: &definition::ChildDefinition) -> Option<ModuleCrumb> {
        match child.crumbs.as_slice() {
            [ast::crumbs::Crumb::Module(crumb)] => Some(*crumb),
            _ => None,
        }
    }

    /// Try constructing value from `definition::ChildDefinition`. Fails if it is not a direct child
    /// of a module.
    pub fn new(child: definition::ChildDefinition) -> Result<Self, NotDirectChild> {
        if Self::try_retrieving_crumb(&child).is_some() {
            Ok(Self(child))
        } else {
            Err(NotDirectChild(child.crumbs))
        }
    }

    /// The location of this definition child in the module.
    pub fn crumb(&self) -> ModuleCrumb {
        // Safe, because our only constructor checks that this works. This is the type's invariant.
        Self::try_retrieving_crumb(&self.0).unwrap()
    }
}

impl TryFrom<definition::ChildDefinition> for ChildDefinition {
    type Error = NotDirectChild;
    fn try_from(value: definition::ChildDefinition) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}



// ========================
// === Module Utilities ===
// ========================

/// Looks up graph in the module.
pub fn get_definition(
    ast: &known::Module,
    id: &definition::Id,
) -> FallibleResult<definition::DefinitionInfo> {
    Ok(locate(ast, id)?.item)
}

/// Locate the line with given definition and return crumb that denotes it.
///
/// Fails if there is no matching definition being a direct child of the module.
pub fn locate_line_with(
    ast: &known::Module,
    crumb: &definition::Crumb,
) -> FallibleResult<ModuleCrumb> {
    locate_child(ast, crumb).map(|child| child.crumb())
}

/// Locate the definition being the module's direct child.
pub fn locate_child(
    ast: &known::Module,
    crumb: &definition::Crumb,
) -> FallibleResult<ChildDefinition> {
    let child = ast.def_iter().find_by_name(crumb)?;
    Ok(ChildDefinition::try_from(child)?)
}

/// Traverses the module's definition tree following the given Id crumbs, looking up the definition.
pub fn locate(
    ast: &known::Module,
    id: &definition::Id,
) -> FallibleResult<definition::ChildDefinition> {
    let mut crumbs_iter = id.crumbs.iter();
    // Not exactly regular - we need special case for the first crumb as it is not a definition nor
    // a children. After this we can go just from one definition to another.
    let first_crumb = crumbs_iter.next().ok_or(EmptyDefinitionId)?;
    let mut child = ast.def_iter().find_by_name(first_crumb)?;
    for crumb in crumbs_iter {
        child = definition::resolve_single_name(child, crumb)?;
    }
    Ok(child)
}

/// Get a definition ID that points to a method matching given pointer.
///
/// The module is assumed to be in the file identified by the `method.file` (for the purpose of
/// desugaring implicit extensions methods for modules).
///
/// The `module_name` parameter is the name of the module that contains `ast`.
pub fn lookup_method(
    module_name: &QualifiedName,
    ast: &known::Module,
    method: &language_server::MethodPointer,
) -> FallibleResult<definition::Id> {
    let qualified_typename = QualifiedName::from_text(&method.defined_on_type)?;
    let defined_in_this_module = module_name == &qualified_typename;
    let method_module_name = QualifiedName::from_text(&method.module)?;
    let implicit_extension_allowed = method.defined_on_type == method_module_name.to_string();
    for child in ast.def_iter() {
        let child_name = &child.name.item;
        let name_matches = child_name.name.item == method.name;
        let type_matches = match child_name.extended_target.as_slice() {
            [] => implicit_extension_allowed || defined_in_this_module,
            [typename] => typename.item == qualified_typename.name(),
            _ => child_name.explicitly_extends_type(&method.defined_on_type),
        };
        if name_matches && type_matches {
            return Ok(definition::Id::new_single_crumb(child_name.clone()));
        }
    }

    Err(CannotFindMethod(method.clone()).into())
}

/// Get a span in module's text representation where the given definition is located.
pub fn definition_span(
    ast: &known::Module,
    id: &definition::Id,
) -> FallibleResult<enso_text::Range<Byte>> {
    let location = locate(ast, id)?;
    ast.range_of_descendant_at(&location.crumbs)
}

impl DefinitionProvider for known::Module {
    fn indent(&self) -> usize {
        0
    }

    fn scope_kind(&self) -> definition::ScopeKind {
        definition::ScopeKind::Root
    }

    fn enumerate_asts<'a>(&'a self) -> Box<dyn Iterator<Item = ChildAst<'a>> + 'a> {
        self.ast().children()
    }
}



// ================
// === MethodId ===
// ================

/// A structure identifying a method.
///
/// It is very similar to MethodPointer from language_server API, however it may point to the method
/// outside the currently opened project.
#[derive(Clone, Debug, serde::Deserialize, Eq, Hash, PartialEq, serde::Serialize)]
#[allow(missing_docs)]
pub struct MethodId {
    pub module:          QualifiedName,
    pub defined_on_type: QualifiedName,
    pub name:            String,
}



// ============
// === Test ===
// ============

#[cfg(test)]
mod tests {
    use super::*;

    use crate::definition::DefinitionName;

    use engine_protocol::language_server::MethodPointer;
    use wasm_bindgen_test::wasm_bindgen_test;

    wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);

    #[wasm_bindgen_test]
    fn import_listing() {
        let parser = parser_scala::Parser::new_or_panic();
        let expect_imports = |code: &str, expected: &[&[&str]]| {
            let ast = parser.parse_module(code, default()).unwrap();
            let info = Info { ast };
            let imports = info.iter_imports().collect_vec();
            assert_eq!(imports.len(), expected.len());
            for (import, expected_segments) in imports.iter().zip(expected) {
                itertools::assert_equal(import.module.iter(), expected_segments.iter());
            }
        };

        // TODO [mwu] waiting for fix https://github.com/enso-org/enso/issues/1016
        //   expect_imports("import", &[&[]]);
        expect_imports("import Foo", &[&["Foo"]]);
        expect_imports("import Foo.Bar", &[&["Foo", "Bar"]]);
        expect_imports("foo = bar\nimport Foo.Bar", &[&["Foo", "Bar"]]);
        expect_imports("import Foo.Bar\nfoo=bar\nimport Foo.Bar", &[&["Foo", "Bar"], &[
            "Foo", "Bar",
        ]]);
    }

    #[wasm_bindgen_test]
    fn import_adding_and_removing() {
        let parser = parser_scala::Parser::new_or_panic();
        let code = "import Foo.Bar.Baz";
        let ast = parser.parse_module(code, default()).unwrap();
        let mut info = Info { ast };
        let import = |code| {
            let ast = parser.parse_line_ast(code).unwrap();
            import::Info::from_ast(&ast).unwrap()
        };

        info.add_import(&parser, import("import Bar.Gar"));
        info.expect_code("import Bar.Gar\nimport Foo.Bar.Baz");
        info.add_import(&parser, import("import Gar.Bar"));
        info.expect_code("import Bar.Gar\nimport Foo.Bar.Baz\nimport Gar.Bar");

        info.remove_import(&import("import Foo.Bar.Baz")).unwrap();
        info.expect_code("import Bar.Gar\nimport Gar.Bar");
        info.remove_import(&import("import Foo.Bar.Baz")).unwrap_err();
        info.expect_code("import Bar.Gar\nimport Gar.Bar");
        info.remove_import(&import("import Gar.Bar")).unwrap();
        info.expect_code("import Bar.Gar");
        info.remove_import(&import("import Bar.Gar")).unwrap();
        info.expect_code("");

        info.add_import(&parser, import("import Bar.Gar"));
        info.expect_code("import Bar.Gar");
    }

    #[wasm_bindgen_test]
    fn implicit_method_resolution() {
        let parser = parser_scala::Parser::new_or_panic();
        let module_name =
            QualifiedName::from_all_segments(["local", "ProjectName", "Main"]).unwrap();
        let expect_find = |method: &MethodPointer, code, expected: &definition::Id| {
            let module = parser.parse_module(code, default()).unwrap();
            let result = lookup_method(&module_name, &module, method);
            assert_eq!(result.unwrap().to_string(), expected.to_string());

            // TODO [mwu]
            //  We should be able to use `assert_eq!(result.unwrap(),expected);`
            //  But we can't, because definition::Id uses located fields and crumbs won't match.
            //  Eventually we'll likely need to split definition names into located and unlocated
            //  ones. Definition ID should not require any location info.
        };

        let expect_not_found = |method: &MethodPointer, code| {
            let module = parser.parse_module(code, default()).unwrap();
            lookup_method(&module_name, &module, method).expect_err("expected method not found");
        };


        // === Lookup the Main (local module type) extension method ===

        let ptr = MethodPointer {
            defined_on_type: "local.ProjectName.Main".into(),
            module:          "local.ProjectName.Main".into(),
            name:            "foo".into(),
        };

        // Implicit module extension method.
        let id = definition::Id::new_plain_name("foo");
        expect_find(&ptr, "foo a b = a + b", &id);
        // Explicit module extension method.
        let id = definition::Id::new_single_crumb(DefinitionName::new_method("Main", "foo"));
        expect_find(&ptr, "Main.foo a b = a + b", &id);
        // Matching name but extending wrong type.
        expect_not_found(&ptr, "Number.foo a b = a + b");
        // Mismatched name.
        expect_not_found(&ptr, "bar a b = a + b");


        // === Lookup the Int (non-local type) extension method ===

        let ptr = MethodPointer {
            defined_on_type: "std.Base.Main.Number".into(),
            module:          "local.ProjectName.Main".into(),
            name:            "foo".into(),
        };

        expect_not_found(&ptr, "foo a b = a + b");
        let id = definition::Id::new_single_crumb(DefinitionName::new_method("Number", "foo"));
        expect_find(&ptr, "Number.foo a b = a + b", &id);
        expect_not_found(&ptr, "Text.foo a b = a + b");
        expect_not_found(&ptr, "bar a b = a + b");
    }

    #[wasm_bindgen_test]
    fn test_definition_location() {
        let code = r"
some def =
    first line
    second line

other def =
    first line
    second line
    nested def =
        nested body
    last line of other def

last def = inline expression";

        let parser = parser_scala::Parser::new_or_panic();
        let module = parser.parse_module(code, default()).unwrap();
        let module = Info { ast: module };

        let id = definition::Id::new_plain_name("other");
        let span = definition_span(&module.ast, &id).unwrap();
        assert!(code[span].ends_with("last line of other def\n"));

        let id = definition::Id::new_plain_name("last");
        let span = definition_span(&module.ast, &id).unwrap();
        assert!(code[span].ends_with("inline expression"));

        let id = definition::Id::new_plain_names(["other", "nested"]);
        let span = definition_span(&module.ast, &id).unwrap();
        assert!(code[span].ends_with("nested body"));
    }

    #[wasm_bindgen_test]
    fn add_method() {
        let parser = parser_scala::Parser::new_or_panic();
        let module = r#"Main.method1 arg = body

main = Main.method1 10"#;

        let module = Info::from(parser.parse_module(module, default()).unwrap());
        let method1_id = DefinitionName::new_method("Main", "method1");
        let main_id = DefinitionName::new_plain("main");
        let to_add = definition::ToAdd {
            name:                     DefinitionName::new_method("Main", "add"),
            explicit_parameter_names: vec!["arg1".into(), "arg2".into()],
            body_head:                Ast::infix_var("arg1", "+", "arg2"),
            body_tail:                default(),
        };

        let repr_after_insertion = |location| {
            let mut module = module.clone();
            module.add_method(to_add.clone(), location, &parser).unwrap();
            module.ast.repr()
        };

        let expected = r#"Main.add arg1 arg2 = arg1 + arg2

Main.method1 arg = body

main = Main.method1 10"#;
        assert_eq!(repr_after_insertion(Placement::Begin), expected);

        let expected = r#"Main.method1 arg = body

main = Main.method1 10

Main.add arg1 arg2 = arg1 + arg2"#;
        assert_eq!(repr_after_insertion(Placement::End), expected);

        let expected = r#"Main.method1 arg = body

Main.add arg1 arg2 = arg1 + arg2

main = Main.method1 10"#;
        assert_eq!(repr_after_insertion(Placement::After(method1_id.clone())), expected);

        assert_eq!(
            repr_after_insertion(Placement::Before(method1_id.clone())),
            repr_after_insertion(Placement::Begin)
        );
        assert_eq!(
            repr_after_insertion(Placement::After(method1_id)),
            repr_after_insertion(Placement::Before(main_id.clone()))
        );
        assert_eq!(
            repr_after_insertion(Placement::After(main_id)),
            repr_after_insertion(Placement::End)
        );

        // TODO [mwu]
        //  This test doesn't include multi-lines functions, as the result may seem somewhat
        // unexpected  due to the way that parser assigns blank lines to the former block
        // rather than module.  If anyone will care, we might revisit this after the parser
        // 2.0 rewrite.
    }
}
