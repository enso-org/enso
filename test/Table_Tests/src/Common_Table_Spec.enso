from Standard.Base import all
from Standard.Base.Data.Index_Sub_Range import While, Sample, Every
import Standard.Base.Data.Index_Sub_Range
from Standard.Base.Error.Problem_Behavior import Report_Error

from Standard.Table import Column_Name_Mapping, Sort_Column, Sort_Column_Selector, Position, Column_Selector
import Standard.Table.Data.Value_Type.Value_Type
from Standard.Table.Data.Column_Selector.Column_Selector import By_Name, By_Index, By_Column
from Standard.Table.Data.Aggregate_Column.Aggregate_Column import Count_Distinct
from Standard.Table.Errors import all

from Standard.Database.Errors import SQL_Error_Data, Unsupported_Database_Operation_Error_Data

from Standard.Test import Test, Problems

from project.Util import all

type Test_Selection
    Config supports_case_sensitive_columns=True order_by=True natural_ordering=False case_insensitive_ordering=True order_by_unicode_normalization_by_default=False case_insensitive_ascii_only=False take_drop=True allows_mixed_type_comparisons=True supports_unicode_normalization=False is_nan_and_nothing_distinct=True

## A common test suite for shared operations on the Table API.

   It is meant to be able to be re-used by tests for the in-memory and various
   database backends.

   Arguments:
   - prefix: A prefix to attach to the names of test groups, for easier
     identification.
   - table_builder: A function which takes a list of column descriptions and
     builds a Table using the backend that is meant to be tested. Each column
     description is a triple of column name, column type and a vector containing
     column elements.
   - test_selection: A selection of which suites should be run. Can be used to
     skip checks for backends which do not support particular features.
   - pending: An optional mark to disable all test groups. Can be used to
     indicate that some tests are disabled due to missing test setup.

   TODO [RW] the Any in return type of the builder should ideally be replaced with the Table interface, once that is supported.
spec prefix table_builder test_selection pending=Nothing =
    table =
        col1 = ["foo", [1,2,3]]
        col2 = ["bar", [4,5,6]]
        col3 = ["Baz", [7,8,9]]
        col4 = ["foo_1", [10,11,12]]
        col5 = ["foo_2", [13,14,15]]
        col6 = ["ab.+123", [16,17,18]]
        col7 = ["abcd123", [19,20,21]]
        table_builder [col1, col2, col3, col4, col5, col6, col7]

    expect_column_names names table =
        table.columns . map .name . should_equal names frames_to_skip=2

    Test.group prefix+"Table.at" pending=pending <|
        Test.specify "should allow selecting columns by name" <|
            column_1 = table.at "bar"
            column_1.name . should_equal "bar"
            column_1.to_vector . should_equal [4, 5, 6]

            table.at "nonexistent column name" . should_fail_with No_Such_Column_Error_Data
        Test.specify "should allow selecting columns by index" <|
            column_1 = table.at
            column_1.name . should_equal "foo"
            column_1.to_vector . should_equal [1, 2, 3]

            column_2 = table.at 2
            column_2.name . should_equal "Baz"
            column_2.to_vector . should_equal [7, 8, 9]

            column_3 = table.at -1
            column_3.name . should_equal "abcd123"
            column_3.to_vector . should_equal [19, 20, 21]

            table.at 100 . should_fail_with Index_Out_Of_Bounds_Error_Data

    Test.group prefix+"Table.column_count" pending=pending <|
        Test.specify "should allow getting the column count" <|
            table.column_count . should_equal 7

    Test.group prefix+"Table.select_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["foo", "bar"] <| table.select_columns (By_Name ["bar", "foo"])
            expect_column_names ["foo", "bar"] <| table.select_columns (["bar", "foo"])
            expect_column_names ["bar", "Baz", "foo_1", "foo_2"] <| table.select_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))
            expect_column_names ["abcd123", "foo", "bar"] <| table.select_columns (By_Index [-1, 0, 1]) reorder=True

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["Baz", "foo_1"] <| table.select_columns (By_Column [column1, column2])

        Test.specify "should allow to reorder columns if asked to" <|
            table_2 = table.select_columns (By_Name ["bar", "foo"]) reorder=True
            expect_column_names ["bar", "foo"] table_2
            table_2 . at "bar" . to_vector . should_equal [4,5,6]
            table_2 . at "foo" . to_vector . should_equal [1,2,3]

        Test.specify "should correctly handle regex matching" <|
            expect_column_names ["foo"] <| table.select_columns (By_Name ["foo"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123", "abcd123"] <| table.select_columns (By_Name ["a.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123", "abcd123"] <| table.select_columns (By_Name ["ab.+123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123"] <| table.select_columns (By_Name ["ab.+123"])
            expect_column_names ["abcd123"] <| table.select_columns (By_Name ["abcd123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should allow negative indices" <|
            expect_column_names ["foo", "bar", "foo_2"] <| table.select_columns (By_Index [-3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["bar", "Bar"] <| table.select_columns (By_Name ["bar"] Text_Matcher.Case_Insensitive)

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["foo", "bar", "foo_1", "foo_2"] <| table.select_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["bar", "foo", "foo_1", "foo_2"] <| table.select_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)) reorder=True

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo", "bar"]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo", "bar"]
            problems = [Input_Indices_Already_Matched_Data [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name.new ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Missing_Input_Columns_Data ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.select_columns selector reorder=True on_problems=_
            tester = expect_column_names ["bar", "foo"]
            problems = [Missing_Input_Columns_Data ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: no columns in the output" <|
            selector = By_Name []
            action = table.select_columns selector on_problems=_
            tester = expect_column_names []
            problems = [No_Output_Columns]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            selector = By_Name ["hmmm"]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names []
            problems = [Missing_Input_Columns_Data ["hmmm"], No_Output_Columns]
            Problems.test_problem_handling action problems tester

            action_2 = table.select_columns (By_Index [0, -7, 0, 100]) on_problems=_
            problems_2 = [Column_Indexes_Out_Of_Range_Data [100], Duplicate_Column_Selectors_Data [0], Input_Indices_Already_Matched_Data [-7]]
            tester_2 = expect_column_names ["foo"]
            Problems.test_problem_handling action_2 problems_2 tester_2

    Test.group prefix+"Table.remove_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["bar", "foo"])
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns ["bar", "foo"]
            expect_column_names ["foo", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123"] <| table.remove_columns (By_Index [-1, 0, 1])

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["foo", "bar", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns (By_Column [column1, column2])

        Test.specify "should correctly handle regex matching" <|
            last_ones = table.columns.tail.map .name
            expect_column_names last_ones <| table.remove_columns (By_Name ["foo"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            first_ones = ["foo", "bar", "Baz", "foo_1", "foo_2"]
            expect_column_names first_ones <| table.remove_columns (By_Name ["a.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names first_ones <| table.remove_columns (By_Name ["ab.+123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names first_ones+["abcd123"] <| table.remove_columns (By_Name ["ab.+123"])
            expect_column_names first_ones+["ab.+123"] <| table.remove_columns (By_Name ["abcd123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should allow negative indices" <|
            expect_column_names ["Baz", "foo_1", "ab.+123"] <| table.remove_columns (By_Index [-1, -3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["foo"] <| table.remove_columns (By_Name ["bar"] Text_Matcher.Case_Insensitive)

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["Baz", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Input_Indices_Already_Matched_Data [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name.new ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns_Data ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns_Data ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: no columns in the output" <|
            selector = By_Name [".*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names []
            problems = [No_Output_Columns]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            selector = By_Name [".*", "hmmm"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names []
            problems = [Missing_Input_Columns_Data ["hmmm"], No_Output_Columns]
            Problems.test_problem_handling action problems tester

            action_2 = table.remove_columns (By_Index [0, -7, 0, 100]) on_problems=_
            problems_2 = [Column_Indexes_Out_Of_Range_Data [100], Duplicate_Column_Selectors_Data [0], Input_Indices_Already_Matched_Data [-7]]
            tester_2 = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            Problems.test_problem_handling action_2 problems_2 tester_2

    Test.group prefix+"Table.reorder_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Name ["foo"]) Position.After_Other_Columns
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo", "bar"] <| table.reorder_columns ["foo", "bar"] Position.After_Other_Columns
            expect_column_names ["foo_1", "foo_2", "bar", "Baz", "foo", "ab.+123", "abcd123"] <| table.reorder_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))
            expect_column_names ["bar", "foo", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.reorder_columns (By_Index [1, 0]) Position.Before_Other_Columns
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Index [0]) Position.After_Other_Columns

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["foo_1", "Baz", "foo", "bar", "foo_2", "ab.+123", "abcd123"] <| table.reorder_columns (By_Column [column1, column2])

        Test.specify "should correctly handle regex matching" <|
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Name ["foo"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)) Position.After_Other_Columns
            rest = ["foo", "bar", "Baz", "foo_1", "foo_2"]
            expect_column_names ["ab.+123", "abcd123"]+rest <| table.reorder_columns (By_Name ["a.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123", "abcd123"]+rest <| table.reorder_columns (By_Name ["ab.+123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123"]+rest+["abcd123"] <| table.reorder_columns (By_Name ["ab.+123"])
            expect_column_names ["abcd123"]+rest+["ab.+123"] <| table.reorder_columns (By_Name ["abcd123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should allow negative indices" <|
            expect_column_names ["abcd123", "foo_2", "foo", "bar", "Baz", "foo_1", "ab.+123"] <| table.reorder_columns (By_Index [-1, -3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["bar", "Bar", "foo"] <| table.reorder_columns (By_Name ["bar"] Text_Matcher.Case_Insensitive)

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["bar", "foo", "foo_1", "foo_2", "Baz", "ab.+123", "abcd123"] <| table.reorder_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.reorder_columns selector on_problems=_
            tester = expect_column_names ["bar", "foo", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.reorder_columns selector Position.After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors_Data [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.reorder_columns selector Position.After_Other_Columns on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo", "bar"]
            problems = [Input_Indices_Already_Matched_Data [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.reorder_columns selector Position.After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.reorder_columns selector Position.After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Missing_Input_Columns_Data ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.reorder_columns selector Position.After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.reorder_columns selector Position.After_Other_Columns on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "bar", "foo"]
            problems = [Missing_Input_Columns_Data ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            action = table.reorder_columns (By_Index [0, -7, 0, 100]) Position.After_Other_Columns on_problems=_
            problems = [Column_Indexes_Out_Of_Range_Data [100], Duplicate_Column_Selectors_Data [0], Input_Indices_Already_Matched_Data [-7]]
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            Problems.test_problem_handling action problems tester

    Test.group prefix+"Table.sort_columns" pending=pending <|
        table =
            col1 = ["foo_21", [1,2,3]]
            col2 = ["foo_100", [4,5,6]]
            col3 = ["foo_1", [7,8,9]]
            col4 = ["Foo_2", [10,11,12]]
            col5 = ["foo_3", [13,14,15]]
            col6 = ["foo_001", [16,17,18]]
            col7 = ["bar", [19,20,21]]
            table_builder [col1, col2, col3, col4, col5, col6, col7]

        Test.specify "should work as shown in the doc examples" <|
            sorted = table.sort_columns
            expect_column_names ["Foo_2", "bar", "foo_001", "foo_1", "foo_100", "foo_21", "foo_3"] sorted
            sorted.columns.first.to_vector . should_equal [10,11,12]

            expect_column_names ["bar", "foo_001", "foo_1", "Foo_2", "foo_3", "foo_21", "foo_100"] <| table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)
            expect_column_names ["foo_3", "foo_21", "foo_100", "foo_1", "foo_001", "bar", "Foo_2"] <| table.sort_columns Sort_Direction.Descending

        Test.specify "should correctly handle case-insensitive sorting" <|
            expect_column_names ["bar", "foo_001", "foo_1", "foo_100", "Foo_2", "foo_21", "foo_3"] <| table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive)

        Test.specify "should correctly handle natural order sorting" <|
            expect_column_names ["Foo_2", "bar", "foo_001", "foo_1", "foo_3", "foo_21", "foo_100"] <| table.sort_columns text_ordering=(Text_Ordering.Default sort_digits_as_numbers=True)

        Test.specify "should correctly handle various combinations of options" <|
            expect_column_names ["foo_100", "foo_21", "foo_3", "Foo_2", "foo_1", "foo_001", "bar"] <| table.sort_columns direction=Sort_Direction.Descending text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)

    Test.group prefix+"Table.rename_columns" pending=pending <|
        table =
            col1 = ["alpha", [1,2,3]]
            col2 = ["beta", [4,5,6]]
            col3 = ["gamma", [16,17,18]]
            col4 = ["delta", [19,20,21]]
            table_builder [col1, col2, col3, col4]

        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Position ["FirstColumn"])

        Test.specify "should work by index" <|
            map = Map.from_vector [[0, "FirstColumn"], [-2, "Another"]]
            expect_column_names ["FirstColumn", "beta", "Another", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Index map)

        Test.specify "should work by position" <|
            vec = ["one", "two", "three"]
            expect_column_names ["one", "two", "three", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Position vec)

        Test.specify "should work by Vector" <|
            vec = ["one", "two", "three"]
            expect_column_names ["one", "two", "three", "delta"] <|
                table.rename_columns vec

        Test.specify "should work by name" <|
            map = Map.from_vector [["alpha", "FirstColumn"], ["delta", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Text_Matcher.Case_Sensitive))

        Test.specify "should work by name case-insensitively" <|
            map = Map.from_vector [["ALPHA", "FirstColumn"], ["DELTA", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map Text_Matcher.Case_Insensitive)

        Test.specify "should work by name using regex" <|
            map = Map.from_vector [["a.*", "FirstColumn"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should work by name using regex substitution" <|
            map = Map.from_vector [["a(.*)", "$1"]]
            expect_column_names ["lpha", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should work by column" <|
            vec = [[table.at "alpha", "FirstColumn"], [table.at "delta", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Column vec)

        Test.specify "should correctly handle problems: duplicate columns" <|
            map = Column_Name_Mapping.By_Column [[table.at "alpha", "FirstColumn"], [table.at "alpha", "Another"]]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "delta"]
            problems = [Duplicate_Column_Selectors_Data ["alpha"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            map = Column_Name_Mapping.By_Name (Map.from_vector [["alpha", "FirstColumn"], ["omicron", "Another"], [weird_name, "Fixed"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "delta"]
            problems = [Missing_Input_Columns_Data [weird_name, "omicron"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: out of bounds indices" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[0, "FirstColumn"], [-1, "Another"], [100, "Boo"], [-200, "Nothing"], [300, "Here"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "Another"]
            problems = [Column_Indexes_Out_Of_Range_Data [-200, 100, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[1, "FirstColumn"], [-3, "Another"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Another", "gamma", "delta"]
            problems = [Input_Indices_Already_Matched_Data [1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names ''" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[1, ""]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Column_1", "gamma", "delta"]
            problems = [Invalid_Output_Column_Names_Data [""]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names Nothing" <|
            map = Column_Name_Mapping.By_Position ["alpha", Nothing]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Column_1", "gamma", "delta"]
            problems = [Invalid_Output_Column_Names_Data [Nothing]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            map = Column_Name_Mapping.By_Position ["Test", "Test", "Test", "Test"]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["Test", "Test_1", "Test_2", "Test_3"]
            problems = [Duplicate_Output_Column_Names_Data ["Test", "Test", "Test"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: too many input names" <|
            map = Column_Name_Mapping.By_Position ["A", "B", "C", "D", "E", "F"]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["A", "B", "C", "D"]
            problems = [Too_Many_Column_Names_Provided_Data ["E", "F"]]
            Problems.test_problem_handling action problems tester

    order_by_pending = if pending.is_nothing.not then pending else
        if test_selection.order_by.not then "TODO: order_by is not yet supported by this backend." else
            Nothing
    Test.group prefix+"Table.order_by" pending=order_by_pending <|
        table =
            col1 = ["alpha", [3, 2, 1, 0]]
            col2 = ["beta", ["a", "b", "a", "b"]]
            col3 = ["gamma", [1, 2, 3, 4]]
            col4 = ["delta", ["a10", "a1", "a2", "a03"]]
            col5 = ["eta", ["Beta", "alpha", "bądź", "Aleph"]]
            col6 = ["xi", [1.0, 1.5, Nothing, 0.5]]
            col7 = ["psi", [Nothing, "c01", "c10", "C2"]]
            col8 = ["phi", ["śc", Nothing, 's\u0301b', "śa"]]
            col9 = ["tau", [32.0, 0.5, -0.1, 1.6]]
            col10 = ["rho", ["BB", Nothing, Nothing, "B"]]
            table_builder [col1, col2, col3, col4, col5, col6, col7, col8, col9, col10]

        Test.specify "should work as shown in the doc examples" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["alpha"])
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

            t2 = table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index -8 Sort_Direction.Descending])
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "gamma" . to_vector . should_equal [3, 1, 4, 2]
            t2.at "alpha" . to_vector . should_equal [1, 3, 0, 2]

        Test.specify "should correctly handle regexes matching multiple names" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name ".*ta"  Sort_Direction.Descending] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            t1.at "beta" . to_vector . should_equal ["b", "b", "a", "a"]
            t1.at "delta" . to_vector . should_equal ["a1", "a03", "a2", "a10"]
            t1.at "gamma" . to_vector . should_equal [2, 4, 3, 1]

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = Sort_Column_Selector.By_Index [0, 100, Sort_Column.Index -200, Sort_Column.Index 300]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = Sort_Column_Selector.By_Index [0, Sort_Column.Index 0, Sort_Column.Index 0 Sort_Direction.Descending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Duplicate_Column_Selectors_Data [Sort_Column.Index 0, Sort_Column.Index 0 Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = Sort_Column_Selector.By_Index [1, Sort_Column.Index -9 Sort_Direction.Descending, Sort_Column.Index -8 Sort_Direction.Descending, Sort_Column.Index 2 Sort_Direction.Ascending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
                table.at "gamma" . to_vector . should_equal [3, 1, 4, 2]
                table.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            problems = [Input_Indices_Already_Matched_Data [Sort_Column.Index -9 Sort_Direction.Descending, Sort_Column.Index 2]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = Sort_Column_Selector.By_Name ["alpha", Sort_Column.Name "alpha" Sort_Direction.Descending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Matched_By_Multiple_Selectors_Data "alpha" [Sort_Column.Name "alpha", Sort_Column.Name "alpha" Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" <|
            selector = Sort_Column_Selector.By_Name [Sort_Column.Name "ALPHA", Sort_Column.Name "alpha" Sort_Direction.Descending] Text_Matcher.Case_Insensitive
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Matched_By_Multiple_Selectors_Data "alpha" [Sort_Column.Name "ALPHA", Sort_Column.Name "alpha" Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = Sort_Column_Selector.By_Name [Sort_Column.Name "alpha", "hmm", Sort_Column.Name weird_name]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Missing_Input_Columns_Data [Sort_Column.Name "hmm", Sort_Column.Name weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["alpha", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "alpha"
            weird_column = table_2.at "weird_column"
            bar = table.at "beta"

            selector = Sort_Column_Selector.By_Column [bar, weird_column, Sort_Column.Column foo]
            problem = table.order_by selector on_problems=Problem_Behavior.Report_Error . catch
            problem.should_be_a Missing_Input_Columns_Data
            problem.criteria.map (selector-> selector.column.name) . should_equal ["weird_column"]

            t2 = table.order_by selector on_problems=Problem_Behavior.Ignore
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t2.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

        Test.specify "should report a problem if no columns are selected for ordering" <|
            action = table.order_by (Sort_Column_Selector.By_Name []) on_problems=_
            tester t2 =
                t2.at "alpha" . to_vector . should_equal (table.at "alpha" . to_vector)
            problems = [No_Input_Columns_Selected]
            Problems.test_problem_handling action problems tester

        Test.specify "should stack consecutive ordering operations" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha"])
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "beta" . to_vector . should_equal ["b", "a", "b", "a"]

            # Now we reverse the order
            t2 = t1.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha" Sort_Direction.Descending])
            t2.at "alpha" . to_vector . should_equal [3, 2, 1, 0]
            t2.at "beta" . to_vector . should_equal ["a", "b", "a", "b"]

            # Now we add another primary ordering, but the order from t1/t2 is kept for tie breaking.
            t3 = t1.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "beta"])
            t3.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t3.at "alpha" . to_vector . should_equal [1, 3, 0, 2]

            t4 = t2.order_by (Sort_Column_Selector.By_Name ["beta"])
            t4.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t4.at "alpha" . to_vector . should_equal [3, 1, 2, 0]

        Test.specify "should give priority to the first selected column and use the next ones for breaking ties" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["beta", Sort_Column.Name "alpha" Sort_Direction.Ascending])
            t1.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t1.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t1.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "beta", Sort_Column.Name "alpha" Sort_Direction.Descending])
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "alpha" . to_vector . should_equal [3, 1, 2, 0]
            t2.at "gamma" . to_vector . should_equal [1, 3, 2, 4]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha", Sort_Column.Name "beta"])
            t3.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t3.at "beta" . to_vector . should_equal ["b", "a", "b", "a"]
            t3.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

            t4 = table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index 0 Sort_Direction.Ascending])
            t4.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t4.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t4.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

            t5 = table.order_by (Sort_Column_Selector.By_Column [table.at "beta", Sort_Column.Column (table.at "alpha") Sort_Direction.Ascending])
            t5.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t5.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t5.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

        Test.specify "should deal with real numbers" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["tau"])
            t1.at "tau" . to_vector . should_equal [-0.1, 0.5, 1.6, 32.0]
            t1.at "alpha" . to_vector . should_equal [1, 2, 0, 3]

        Test.specify "should deal with nulls" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["xi"])
            t1.at "xi" . to_vector . should_equal [Nothing, 0.5, 1.0, 1.5]
            t1.at "alpha" . to_vector . should_equal [1, 0, 3, 2]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "rho"])
            t2.at "rho" . to_vector . should_equal [Nothing, Nothing, "B", "BB"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "rho" Sort_Direction.Descending])
            t3.at "rho" . to_vector . should_equal ["BB", "B", Nothing, Nothing]

        Test.specify "should behave as expected with Unicode normalization, depending on the defaults settings" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "phi"])
            case test_selection.order_by_unicode_normalization_by_default of
                True ->
                    t1.at "phi" . to_vector . should_equal [Nothing, "śa", 's\u0301b', "śc"]
                    t1.at "alpha" . to_vector . should_equal [2, 0, 1, 3]
                False ->
                    t1.at "phi" . to_vector . should_equal [Nothing, 's\u0301b', "śa", "śc"]
                    t1.at "alpha" . to_vector . should_equal [2, 1, 0, 3]

        Test.specify "should support natural ordering" pending=(if test_selection.natural_ordering.not then "Natural ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "delta"]) text_ordering=(Text_Ordering.Default sort_digits_as_numbers=True)
            t1.at "delta" . to_vector . should_equal ["a1", "a2", "a03", "a10"]
            t1.at "alpha" . to_vector . should_equal [2, 1, 0, 3]

            t2 = table.order_by (Sort_Column_Selector.By_Name ["delta"]) text_ordering=(Text_Ordering.Default sort_digits_as_numbers=False)
            t2.at "delta" . to_vector . should_equal ["a03", "a1", "a10", "a2"]
            t2.at "alpha" . to_vector . should_equal [0, 2, 3, 1]

        Test.specify "should support case insensitive ordering" pending=(if test_selection.case_insensitive_ordering.not then "Case insensitive ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "eta"]) text_ordering=(Text_Ordering.Case_Insensitive)
            expected = case test_selection.case_insensitive_ascii_only of
                True -> ["Aleph", "alpha", "Beta", "bądź"]
                False -> ["Aleph", "alpha", "bądź", "Beta"]
            t1.at "eta" . to_vector . should_equal expected

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "eta"]) text_ordering=(Text_Ordering.Case_Sensitive)
            t2.at "eta" . to_vector . should_equal ["Aleph", "Beta", "alpha", "bądź"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Case_Insensitive)
            t3.at "psi" . to_vector . should_equal [Nothing, "c01", "c10", "C2"]

            t4 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi" Sort_Direction.Descending]) text_ordering=(Text_Ordering.Case_Sensitive)
            t4.at "psi" . to_vector . should_equal ["c10", "c01", "C2", Nothing]

        Test.specify "should support natural and case insensitive ordering at the same time" pending=(if (test_selection.natural_ordering.not || test_selection.case_insensitive_ordering.not) then "Natural ordering or case sensitive ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)
            t1.at "psi" . to_vector . should_equal [Nothing, "c01", "C2", "c10"]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Default sort_digits_as_numbers=True)
            t2.at "psi" . to_vector . should_equal [Nothing, "C2", "c01", "c10"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Case_Insensitive)
            t3.at "psi" . to_vector . should_equal [Nothing, "c01", "c10", "C2"]

            t4 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"])
            t4.at "psi" . to_vector . should_equal [Nothing, "C2", "c01", "c10"]

        Test.specify "text ordering settings should not affect numeric columns" <|
            ordering = Text_Ordering.Case_Insensitive sort_digits_as_numbers=True
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha"]) text_ordering=ordering
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

    take_drop_by_pending = if pending.is_nothing.not then pending else
        if test_selection.take_drop.not then "TODO: take/drop are not yet supported by this backend." else
            Nothing
    Test.group prefix+"Table.take/drop" pending=take_drop_by_pending <|
        table =
            col1 = ["alpha", [1,2,3,4,5,6,7,8]]
            col2 = ["beta", ["A","B","C","D","E","F","G","H"]]
            table_builder [col1, col2]
        empty = table_builder [["alpha", []], ["beta", []]]

        Test.specify "should allow selecting first or last N rows" <|
            table.take.at "alpha" . to_vector . should_equal [1]
            table.take.at "beta" . to_vector . should_equal ["A"]
            table.drop.at "alpha" . to_vector . should_equal [2,3,4,5,6,7,8]

            table.take (First 4) . at "alpha" . to_vector . should_equal [1,2,3,4]
            table.take (First 0) . at "alpha" . to_vector . should_equal []
            table.take (First -1) . at "alpha" . to_vector . should_equal []
            table.take (First 100) . should_equal table

            table.drop (First 2) . at "beta" . to_vector . should_equal ["C","D","E","F","G","H"]
            table.drop (First 0) . should_equal table
            table.drop (First -1) . should_equal table
            table.drop (First 100) . should_equal empty

            table.take 4 . at "alpha" . to_vector . should_equal [1,2,3,4]
            table.take 0 . at "alpha" . to_vector . should_equal []
            table.take -1 . at "alpha" . to_vector . should_equal []
            table.take 100 . should_equal table

            table.drop 2 . at "beta" . to_vector . should_equal ["C","D","E","F","G","H"]
            table.drop 0 . should_equal table
            table.drop -1 . should_equal table
            table.drop 100 . should_equal empty

            table.take (Last 4) . at "beta" . to_vector . should_equal ["E","F","G","H"]
            table.take (Last 0) . should_equal empty
            table.take (Last -1) . should_equal empty
            table.take (Last 100) . should_equal table

            table.drop (Last 2) . at "alpha" . to_vector . should_equal [1,2,3,4,5,6]
            table.drop (Last 0) . should_equal table
            table.drop (Last -1) . should_equal table
            table.drop (Last 100) . should_equal empty

        Test.specify "should allow selecting rows by ranges or indices" <|
            table.take (Range_Data 2 4) . at "beta" . to_vector . should_equal ["C", "D"]
            table.take (Range_Data 0 0) . should_equal empty
            table.take (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.take (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            table.take (Range_Data 0 100) . should_equal table
            table.take (Range_Data 0 table.row_count) . should_equal table
            empty.take (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty.take (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            table.take (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            table.drop (Range_Data 2 4) . at "alpha" . to_vector . should_equal [1, 2, 5, 6, 7, 8]
            table.drop (Range_Data 0 0) . should_equal table
            table.drop (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.drop (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            table.drop (Range_Data 0 100) . should_equal empty
            table.drop (Range_Data 0 table.row_count) . should_equal empty
            empty.drop (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty.drop (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            table.drop (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            table.take (Index_Sub_Range.By_Index 0) . at "beta" . to_vector . should_equal ["A"]
            empty.take (Index_Sub_Range.By_Index 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.take (Index_Sub_Range.By_Index []) . should_equal empty
            table.take (Index_Sub_Range.By_Index [-1, -1]) . at "beta" . to_vector . should_equal ["H", "H"]
            table.take (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . at "alpha" . to_vector . should_equal [1, 1, 4, 5, 6, 7, 8]
            table.take (Range_Data 0 100 2) . at "alpha" . to_vector . should_equal [1, 3, 5, 7]
            table.take (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . at "alpha" . to_vector . should_equal [1, 3, 5, 7, 2, 4, 6]
            table.take (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . at "alpha" . to_vector . should_equal [2, 3, 3, 4, 5]
            table.take (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . at "alpha" . to_vector . should_equal [3, 4, 5, 2, 3]
            table.take (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.take (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

            table.drop (Index_Sub_Range.By_Index 0) . at "alpha" . to_vector . should_equal [2, 3, 4, 5, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index []) . should_equal table
            table.drop (Index_Sub_Range.By_Index [-1, -1]) . at "alpha" . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            table.drop (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . at "alpha" . to_vector . should_equal [2, 3]
            table.drop (Range_Data 0 100 2) . at "alpha" . to_vector . should_equal [2, 4, 6, 8]
            table.drop (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . at "alpha" . to_vector . should_equal [8]
            table.drop (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . at "alpha" . to_vector . should_equal [1, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . at "alpha" . to_vector . should_equal [1, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.drop (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

        Test.specify "should allow selecting every Nth row" <|
            table.take (Every 1) . should_equal table
            table.take (Every 3) . at "alpha" . to_vector . should_equal [1, 4, 7]
            table.take (Every 3 first=1) . at "alpha" . to_vector . should_equal [2, 5, 8]
            table.take (Every 2 first=1) . at "beta" . to_vector . should_equal ["B", "D", "F", "H"]
            table.take (Every 2 first=100) . at "alpha" . to_vector . should_equal []
            table.take (Every 200) . at "alpha" . to_vector . should_equal [1]
            empty.take (Every 2) . should_equal empty
            table.take (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty.take (Every 0) . should_fail_with Illegal_Argument_Error_Data

            table.drop (Every 1) . should_equal empty
            table.drop (Every 3) . at "alpha" . to_vector . should_equal [2, 3, 5, 6, 8]
            table.drop (Every 3 first=1) . at "alpha" . to_vector . should_equal [1, 3, 4, 6, 7]
            table.drop (Every 2 first=1) . at "alpha" . to_vector . should_equal [1, 3, 5, 7]
            table.drop (Every 2 first=100) . should_equal table
            table.drop (Every 200) . at "beta" . to_vector . should_equal ["B", "C", "D", "E", "F", "G", "H"]
            empty.drop (Every 2) . should_equal empty
            table.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data

        Test.specify "should allow sampling rows" <|
            empty = table_builder [["X", []]]
            one = table_builder [["X", ["a"]]]
            two = table_builder [["X", ["a", "a"]]]
            three = table_builder [["X", ["a", "a", "a"]]]
            three.take (Sample 0) . should_equal empty
            empty.take (Sample 0) . should_equal empty
            empty.take (Sample 1) . should_equal empty
            three.take (Sample 1) . should_equal one
            three.take (Sample 100) . should_equal three

            three.drop (Sample 0) . should_equal three
            empty.drop (Sample 0) . should_equal empty
            empty.drop (Sample 1) . should_equal empty
            one.drop (Sample 1) . should_equal empty
            three.drop (Sample 1) . should_equal two
            three.drop (Sample 100) . should_equal empty

            rnd = table.take (Sample 3 seed=42)
            random_indices = [5, 6, 2]
            alpha_sample = random_indices.map (table.at "alpha" . to_vector . at)
            beta_sample = random_indices.map (table.at "beta" . to_vector . at)
            rnd.at "alpha" . to_vector . should_equal alpha_sample
            rnd.at "beta" . to_vector . should_equal beta_sample

        Test.specify "should allow selecting rows as long as they satisfy a predicate" pending="While is not implemented for Table until the Row type is implemented." <|
            Nothing

    Test.group prefix+"Column.take/drop" pending=take_drop_by_pending <|
        table =
            col1 = ["alpha", [1,2,3,4,5,6,7,8]]
            col2 = ["beta", ["A","B","C","D","E","F","G","H"]]
            table_builder [col1, col2]
        alpha = table.at "alpha"
        beta = table.at "beta"

        empty_table = table_builder [["alpha", []], ["beta", []]]
        empty_alpha = empty_table.at "alpha"
        empty_beta = empty_table.at "beta"

        Test.specify "should allow selecting first or last N rows" <|
            alpha.take.to_vector . should_equal [1]
            beta.take.to_vector . should_equal ["A"]
            alpha.drop.to_vector . should_equal [2,3,4,5,6,7,8]

            alpha.take (First 4) . to_vector . should_equal [1,2,3,4]
            alpha.take (First 0) . should_equal empty_alpha
            alpha.take (First -1) . should_equal empty_alpha
            alpha.take (First 100) . should_equal alpha

            alpha.take 4 . to_vector . should_equal [1,2,3,4]
            alpha.take 0 . should_equal empty_alpha
            alpha.take -1 . should_equal empty_alpha
            alpha.take 100 . should_equal alpha

            beta.drop (First 2) . to_vector . should_equal ["C","D","E","F","G","H"]
            alpha.drop (First 0) . should_equal alpha
            alpha.drop (First -1) . should_equal alpha
            alpha.drop (First 100) . should_equal empty_alpha

            beta.drop 2 . to_vector . should_equal ["C","D","E","F","G","H"]
            alpha.drop 0 . should_equal alpha
            alpha.drop -1 . should_equal alpha
            alpha.drop 100 . should_equal empty_alpha

            beta.take (Last 4) . to_vector . should_equal ["E","F","G","H"]
            beta.take (Last 0) . should_equal empty_beta
            beta.take (Last -1) . should_equal empty_beta
            beta.take (Last 100) . should_equal beta

            alpha.drop (Last 2) . to_vector . should_equal [1,2,3,4,5,6]
            alpha.drop (Last 0) . should_equal alpha
            alpha.drop (Last -1) . should_equal alpha
            alpha.drop (Last 100) . should_equal empty_alpha

        Test.specify "should allow selecting rows by ranges or indices" <|
            beta.take (Range_Data 2 4) . to_vector . should_equal ["C", "D"]
            beta.take (Range_Data 0 0) . should_equal empty_beta
            beta.take (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            beta.take (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            beta.take (Range_Data 0 100) . should_equal beta
            beta.take (Range_Data 0 table.row_count) . should_equal beta
            empty_beta.take (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty_beta.take (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            beta.take (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            alpha.drop (Range_Data 2 4) . to_vector . should_equal [1, 2, 5, 6, 7, 8]
            alpha.drop (Range_Data 0 0) . should_equal alpha
            alpha.drop (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            alpha.drop (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            alpha.drop (Range_Data 0 100) . should_equal empty_alpha
            alpha.drop (Range_Data 0 table.row_count) . should_equal empty_alpha
            empty_alpha.drop (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty_alpha.drop (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            alpha.drop (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            beta.take (Index_Sub_Range.By_Index 0) . to_vector . should_equal ["A"]
            empty_beta.take (Index_Sub_Range.By_Index 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            beta.take (Index_Sub_Range.By_Index []) . should_equal empty_beta
            beta.take (Index_Sub_Range.By_Index [-1, -1]) . to_vector . should_equal ["H", "H"]
            alpha.take (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . to_vector . should_equal [1, 1, 4, 5, 6, 7, 8]
            alpha.take (Range_Data 0 100 2) . to_vector . should_equal [1, 3, 5, 7]
            alpha.take (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . to_vector . should_equal [1, 3, 5, 7, 2, 4, 6]
            alpha.take (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . to_vector . should_equal [2, 3, 3, 4, 5]
            alpha.take (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . to_vector . should_equal [3, 4, 5, 2, 3]
            alpha.take (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            alpha.take (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

            alpha.drop (Index_Sub_Range.By_Index 0) . to_vector . should_equal [2, 3, 4, 5, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index []) . should_equal alpha
            alpha.drop (Index_Sub_Range.By_Index [-1, -1]) . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            alpha.drop (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . to_vector . should_equal [2, 3]
            alpha.drop (Range_Data 0 100 2) . to_vector . should_equal [2, 4, 6, 8]
            alpha.drop (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . to_vector . should_equal [8]
            alpha.drop (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . to_vector . should_equal [1, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . to_vector . should_equal [1, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            alpha.drop (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

        Test.specify "should allow selecting every Nth row" <|
            alpha.take (Every 1) . should_equal alpha
            alpha.take (Every 3) . to_vector . should_equal [1, 4, 7]
            alpha.take (Every 3 first=1) . to_vector . should_equal [2, 5, 8]
            beta.take (Every 2 first=1) . to_vector . should_equal ["B", "D", "F", "H"]
            alpha.take (Every 2 first=100) . to_vector . should_equal []
            alpha.take (Every 200) . to_vector . should_equal [1]
            empty_beta.take (Every 2) . should_equal empty_beta
            beta.take (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty_beta.take (Every 0) . should_fail_with Illegal_Argument_Error_Data

            alpha.drop (Every 1) . should_equal empty_alpha
            alpha.drop (Every 3) . to_vector . should_equal [2, 3, 5, 6, 8]
            alpha.drop (Every 3 first=1) . to_vector . should_equal [1, 3, 4, 6, 7]
            alpha.drop (Every 2 first=1) . to_vector . should_equal [1, 3, 5, 7]
            alpha.drop (Every 2 first=100) . should_equal alpha
            beta.drop (Every 200) . to_vector . should_equal ["B", "C", "D", "E", "F", "G", "H"]
            empty_beta.drop (Every 2) . should_equal empty_beta
            beta.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty_beta.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data

        Test.specify "should allow sampling rows" <|
            three = table_builder [["X", ["a", "a", "a"]]] . at "X"
            two = table_builder [["X", ["a", "a"]]] . at "X"
            one = table_builder [["X", ["a"]]] . at "X"
            empty = table_builder [["X", []]] . at "X"

            three.take (First 2) . should_equal two
            three.take First . should_equal one
            three.take (First 0) . should_equal empty

            three.take 2 . should_equal two
            three.take . should_equal one
            three.take 0 . should_equal empty

            three.take (Sample 0) . should_equal empty
            empty.take (Sample 0) . should_equal empty
            empty.take (Sample 1) . should_equal empty
            three.take (Sample 1) . should_equal one
            three.take (Sample 100) . should_equal three

            three.drop (Sample 0) . should_equal three
            empty.drop (Sample 0) . should_equal empty
            empty.drop (Sample 1) . should_equal empty
            one.drop (Sample 1) . should_equal empty
            three.drop (Sample 1) . should_equal two
            three.drop (Sample 100) . should_equal empty

            rnd = alpha.take (Sample 3 seed=42)
            random_indices = [5, 6, 2]
            sample = alpha.take (Index_Sub_Range.By_Index random_indices)
            rnd.should_equal sample

        Test.specify "should allow selecting rows as long as they satisfy a predicate" <|
            col = table_builder [["X", [1, 3, 5, 6, 8, 9, 10, 11, 13]]] . at "X"
            col.take (While (x-> x%2 == 1)) . to_vector . should_equal [1, 3, 5]
            col.drop (While (x-> x%2 == 1)) . to_vector . should_equal [6, 8, 9, 10, 11, 13]

            three = table_builder [["X", [1, 2, 3]]] . at "X"
            empty = table_builder [["X", []]] . at "X"
            three.take (While (_ > 10)) . should_equal empty
            three.take (While (_ < 10)) . should_equal three

            three.drop (While (_ > 10)) . should_equal three
            three.drop (While (_ < 10)) . should_equal empty

    check_empty expected_column_names table =
        table.columns.map .name . should_equal expected_column_names
        expected_column_names.each x->
            table.at x . to_vector . should_equal []
        table.row_count . should_equal 0

    ## Currently these tests rely on filtering preserving the insertion ordering
       within tables. This is not necessarily guaranteed by RDBMS, so we may
       adapt this in the future. For now we implicitly assume the ordering is
       preserved, as that seems to be the case.
    Test.group prefix+"Table.filter" pending=pending <|
        Test.specify "by integer comparisons" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", [100, 3, Nothing, 4, 12]], ["Y", [100, 4, 2, Nothing, 11]]]
            t1 = t.filter "X" (Filter_Condition.Less than=10)
            t1.at "ix" . to_vector . should_equal [2, 4]
            t1.at "X" . to_vector . should_equal [3, 4]
            t.filter "X" (Filter_Condition.Less than=4) . at "X" . to_vector . should_equal [3]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=4) . at "X" . to_vector . should_equal [3, 4]
            t.filter "X" (Filter_Condition.Greater than=4) . at "X" . to_vector . should_equal [100, 12]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=4) . at "X" . to_vector . should_equal [100, 4, 12]
            t.filter "X" (Filter_Condition.Between 4 100) . at "X" . to_vector . should_equal [100, 4, 12]
            t2 = t.filter "X" (Filter_Condition.Equal to=100)
            t2 . at "X" . to_vector . should_equal [100]
            t2 . at "ix" . to_vector . should_equal [1]
            t.filter "X" (Filter_Condition.Equal to=123) . at "X" . to_vector . should_equal []
            v = t.filter "X" (Filter_Condition.Equal to="SOME TEXT :)") . at "X" . to_vector
            case test_selection.allows_mixed_type_comparisons of
                True -> v.should_equal []
                False -> v.should_fail_with SQL_Error_Data

            t.filter "X" (Filter_Condition.Equal to=(t.at "Y")) . at "X" . to_vector . should_equal [100]
            t.filter "X" (Filter_Condition.Less than=(t.at "Y")) . at "X" . to_vector . should_equal [3]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=(t.at "Y")) . at "X" . to_vector . should_equal [100, 3]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=(t.at "Y")) . at "X" . to_vector . should_equal [100, 12]
            t.filter "X" (Filter_Condition.Greater than=(t.at "Y")) . at "X" . to_vector . should_equal [12]
            t.filter "Y" (Filter_Condition.Between (t.at "ix") 100) . at "Y" . to_vector . should_equal [100, 4, 11]

        Test.specify "by text comparisons" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", ["abb", "baca", "b", Nothing, "c"]], ["Y", ["a", "b", "b", "c", "c"]]]
            t1 = t.filter "X" (Filter_Condition.Less than="c")
            t1.at "ix" . to_vector . should_equal [1, 2, 3]
            t1.at "X" . to_vector . should_equal ["abb", "baca", "b"]
            t.filter "X" (Filter_Condition.Equal_Or_Less than="b") . at "X" . to_vector . should_equal ["abb", "b"]
            t.filter "X" (Filter_Condition.Greater than="b") . at "X" . to_vector . should_equal ["baca", "c"]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than="b") . at "X" . to_vector . should_equal ["baca", "b", "c"]
            t.filter "X" (Filter_Condition.Between "b" "c") . at "X" . to_vector . should_equal ["baca", "b", "c"]
            t.filter "X" (Filter_Condition.Equal to="baca") . at "X" . to_vector . should_equal ["baca"]
            v = t.filter "X" (Filter_Condition.Equal to=52) . at "X" . to_vector
            case test_selection.allows_mixed_type_comparisons of
                True -> v.should_equal []
                False -> v.should_fail_with SQL_Error_Data

            t.filter "X" (Filter_Condition.Greater than=(t.at "Y")) . at "X" . to_vector . should_equal ["abb", "baca"]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=(t.at "Y")) . at "X" . to_vector . should_equal ["abb", "baca", "b", "c"]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=(t.at "Y")) . at "X" . to_vector . should_equal ["b", "c"]
            t.filter "X" (Filter_Condition.Less than=(t.at "Y")) . at "X" . to_vector . should_equal []
            t.filter "X" (Filter_Condition.Equal to=(t.at "Y")) . at "X" . to_vector . should_equal ["b", "c"]
            t.filter "X" (Filter_Condition.Between (t.at "Y") "bzzzz") . at "X" . to_vector . should_equal ["abb", "baca", "b"]

        Test.specify "by text search (contains, starts_with, ends_with, like)" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", ["abb", "baca", "banana", Nothing, "nana"]], ["Y", ["a", "b", "b", "c", "a"]], ["Z", ["aaaaa", "bbbbb", "[ab]", "[ab]aaaa", "[ab]ccc"]]]

            t.filter "X" (Filter_Condition.Starts_With "ba") on_problems=Report_Error . at "X" . to_vector . should_equal ["baca", "banana"]
            t.filter "X" (Filter_Condition.Ends_With "na") on_problems=Report_Error . at "X" . to_vector . should_equal ["banana", "nana"]
            t.filter "X" (Filter_Condition.Contains "ac") on_problems=Report_Error . at "X" . to_vector . should_equal ["baca"]

            t.filter "X" (Filter_Condition.Starts_With (t.at "Y")) on_problems=Report_Error . at "X" . to_vector . should_equal ["abb", "baca", "banana"]
            t.filter "X" (Filter_Condition.Ends_With (t.at "Y")) on_problems=Report_Error . at "X" . to_vector . should_equal ["nana"]
            t.filter "X" (Filter_Condition.Contains (t.at "Y")) on_problems=Report_Error . at "X" . to_vector . should_equal ["abb", "baca", "banana", "nana"]

            t.filter "X" (Filter_Condition.Like "%an%") on_problems=Report_Error . at "X" . to_vector . should_equal ["banana", "nana"]
            t.filter "X" (Filter_Condition.Like "_a%") on_problems=Report_Error . at "X" . to_vector . should_equal ["baca", "banana", "nana"]
            t.filter "X" (Filter_Condition.Like "%b") on_problems=Report_Error . at "X" . to_vector . should_equal ["abb"]
            t.filter "X" (Filter_Condition.Like "nana") on_problems=Report_Error . at "X" . to_vector . should_equal ["nana"]
            t.filter "Z" (Filter_Condition.Like "[ab]_%") on_problems=Report_Error . at "Z" . to_vector . should_equal ["[ab]aaaa", "[ab]ccc"]

            t.filter "X" (Filter_Condition.Not_Like "%b") on_problems=Report_Error . at "X" . to_vector . should_equal ["baca", "banana", "nana"]
            t.filter "Z" (Filter_Condition.Not_Like "[ab]%") on_problems=Report_Error . at "Z" . to_vector . should_equal ["aaaaa", "bbbbb"]

        Test.specify "text operations should also match newlines" <|
            t = table_builder [["X", ['a\n\n\n', 'a\n', 'a\n\n\nb', 'a\nb', 'caa\nbb']]]
            t.filter "X" (Filter_Condition.Like 'a_') on_problems=Report_Error . at "X" . to_vector . should_equal ['a\n']
            t.filter "X" (Filter_Condition.Like 'a%') on_problems=Report_Error . at "X" . to_vector . should_equal ['a\n\n\n', 'a\n', 'a\n\n\nb', 'a\nb']
            t.filter "X" (Filter_Condition.Like 'a_b') on_problems=Report_Error . at "X" . to_vector . should_equal ['a\nb']
            t.filter "X" (Filter_Condition.Like '%\nb') on_problems=Report_Error . at "X" . to_vector . should_equal ['a\n\n\nb', 'a\nb']

            t.filter "X" (Filter_Condition.Contains '\nb') on_problems=Report_Error . at "X" . to_vector . should_equal ['a\n\n\nb', 'a\nb', 'caa\nbb']
            t.filter "X" (Filter_Condition.Ends_With '\nb') on_problems=Report_Error . at "X" . to_vector . should_equal ['a\n\n\nb', 'a\nb']
            t.filter "X" (Filter_Condition.Ends_With '\n') on_problems=Report_Error . at "X" . to_vector . should_equal ['a\n\n\n', 'a\n']
            t.filter "X" (Filter_Condition.Starts_With 'c') on_problems=Report_Error . at "X" . to_vector . should_equal ['caa\nbb']

        if test_selection.supports_unicode_normalization then
            t = table_builder [["X", ['śnieg', 's\u0301nieg', 'X', Nothing, 'połać', 'połac\u0301']]]
            Test.specify "text operations should support Unicode normalization" <|
                t.filter "X" (Filter_Condition.Starts_With 'ś') on_problems=Report_Error . at "X" . to_vector . should_equal ['śnieg', 's\u0301nieg']
                t.filter "X" (Filter_Condition.Contains 'ś') on_problems=Report_Error . at "X" . to_vector . should_equal ['śnieg', 's\u0301nieg']
                t.filter "X" (Filter_Condition.Ends_With 'ś') on_problems=Report_Error . at "X" . to_vector . should_equal []
                t.filter "X" (Filter_Condition.Ends_With 'ć') on_problems=Report_Error . at "X" . to_vector . should_equal ['połać', 'połac\u0301']

                # This should be replaced with the disabled test below, once the related bug is fixed.
                t.filter "X" (Filter_Condition.Like 'ś%') on_problems=Report_Error . at "X" . to_vector . should_equal ['śnieg']

            # This test is split off just to mark is as pending, once resolved it can be merged with the one above.
            Test.specify "text operations should support Unicode normalization (like)" pending='There is a bug with Java Regex in Unicode normalized mode (CANON_EQ) with quoting.\nhttps://bugs.java.com/bugdatabase/view_bug.do?bug_id=8032926' <|
                t.filter "X" (Filter_Condition.Like 'ś%') on_problems=Report_Error . at "X" . to_vector . should_equal ['śnieg', 's\u0301nieg']

        Test.specify "by empty text" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", ["abb", "", " ", Nothing, "nana"]]]
            t.filter "X" Filter_Condition.Is_Empty on_problems=Report_Error . at "X" . to_vector . should_equal ["", Nothing]
            t.filter "X" Filter_Condition.Not_Empty on_problems=Report_Error . at "X" . to_vector . should_equal ["abb", " ", "nana"]

        Test.specify "should check types for text operations" <|
            t = table_builder [["ix", [1, 2, 3, 4]], ["X", [Nothing, "A", "", " "]]]
            check_column_type_error_handling action =
                tester = check_empty ["ix", "X"]
                check_problem problem =
                    problem.should_be_a Invalid_Value_Type.Invalid_Value_Type_Data
                    problem.expected . should_equal Value_Type.Char
                warnings_tester warnings =
                    (warnings.length >= 1).should_be_true
                    check_problem warnings.first
                error_tester result = check_problem result.catch
                Problems.test_advanced_problem_handling action error_tester warnings_tester tester
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Starts_With (t.at "ix")) on_problems=_)
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Ends_With (t.at "ix")) on_problems=_)
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Contains (t.at "ix")) on_problems=_)
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Like (t.at "ix")) on_problems=_)
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Not_Like (t.at "ix")) on_problems=_)

            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Starts_With "A") on_problems=_)
            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Ends_With "A") on_problems=_)
            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Contains "A") on_problems=_)
            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Like "A") on_problems=_)
            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Not_Like "A") on_problems=_)

            check_column_type_error_handling (t.filter "ix" Filter_Condition.Is_Empty on_problems=_)
            check_column_type_error_handling (t.filter "ix" Filter_Condition.Not_Empty on_problems=_)

            check_scalar_type_error_handling name action =
                tester = check_empty ["ix", "X"]
                problems = [Type_Error_Data Text Integer name]
                Problems.test_problem_handling action problems tester
            check_scalar_type_error_handling "prefix" (t.filter "X" (Filter_Condition.Starts_With 42) on_problems=_)
            check_scalar_type_error_handling "suffix" (t.filter "X" (Filter_Condition.Ends_With 42) on_problems=_)
            check_scalar_type_error_handling "substring" (t.filter "X" (Filter_Condition.Contains 42) on_problems=_)
            check_scalar_type_error_handling "pattern" (t.filter "X" (Filter_Condition.Like 42) on_problems=_)
            check_scalar_type_error_handling "pattern" (t.filter "X" (Filter_Condition.Not_Like 42) on_problems=_)

        Test.specify "by nulls" <|
            t = table_builder [["ix", [1, 2, 3, 4]], ["X", [Nothing, 1, Nothing, 4]]]
            t1 = t.filter "X" (Filter_Condition.Is_Nothing) on_problems=Report_Error
            t1.at "ix" . to_vector . should_equal [1, 3]
            t1.at "X" . to_vector . should_equal [Nothing, Nothing]

            t2 = t.filter "X" (Filter_Condition.Not_Nothing) on_problems=Report_Error
            t2.at "ix" . to_vector . should_equal [2, 4]
            t2.at "X" . to_vector . should_equal [1, 4]

        Test.specify "by an Is_In check" <|
            t = table_builder [["ix", [1, 2, 3, Nothing, 5, 6]], ["X", ["a", "b", "ccc", "X", "f", "2"]]]
            t1 = table_builder [["txt", ["X", "a", "c", Nothing]], ["int", [Nothing, 2, 5, 4]], ["bool", [True, Nothing, Nothing, True]]]

            t.filter "X" (Filter_Condition.Is_In (t1.at "txt")) on_problems=Report_Error . at "X" . to_vector . should_equal ["a", "X"]
            t.filter "X" (Filter_Condition.Is_In (t1.at "txt" . to_vector)) on_problems=Report_Error . at "X" . to_vector . should_equal ["a", "X"]
            t.filter "X" (Filter_Condition.Not_In (t1.at "txt")) on_problems=Report_Error . at "X" . to_vector . should_equal ["b", "ccc", "f", "2"]
            t.filter "X" (Filter_Condition.Not_In (t1.at "txt" . to_vector)) on_problems=Report_Error . at "X" . to_vector . should_equal ["b", "ccc", "f", "2"]
            t.filter "X" (Filter_Condition.Is_In ["ccc"]) on_problems=Report_Error . at "X" . to_vector . should_equal ["ccc"]
            t.filter "X" (Filter_Condition.Is_In []) on_problems=Report_Error . at "X" . to_vector . should_equal []
            t.filter "X" (Filter_Condition.Not_In []) on_problems=Report_Error . at "X" . to_vector . should_equal ["a", "b", "ccc", "X", "f", "2"]

            if test_selection.allows_mixed_type_comparisons then
                mixed = t.filter "X" (Filter_Condition.Is_In (t1.at "int")) on_problems=Report_Error . at "X" . to_vector
                # Some backends (e.g. SQLite) allow to coerce integer and text types when doing mixed type comparisons.
                ((mixed == []) || (mixed == ["2"])).should_be_true

            t.filter "ix" (Filter_Condition.Is_In (t1.at "int")) on_problems=Report_Error . at "ix" . to_vector . should_equal [2, Nothing, 5]
            t.filter "ix" (Filter_Condition.Is_In (t1.at "int" . to_vector)) on_problems=Report_Error . at "ix" . to_vector . should_equal [2, Nothing, 5]
            t.filter "ix" (Filter_Condition.Is_In [2, 5, 4]) on_problems=Report_Error . at "ix" . to_vector . should_equal [2, 5]
            t.filter "ix" (Filter_Condition.Is_In [Nothing]) on_problems=Report_Error . at "ix" . to_vector . should_equal [Nothing]
            t.filter "ix" (Filter_Condition.Not_In [Nothing]) on_problems=Report_Error . at "ix" . to_vector . should_equal [1, 2, 3, 5, 6]
            t.filter "ix" (Filter_Condition.Not_In [1, 3]) on_problems=Report_Error . at "ix" . to_vector . should_equal [2, Nothing, 5, 6]

            v1 = t.filter "X" (Filter_Condition.Is_In ["c", "f", "b", "b", "b", 15, Nothing]) on_problems=Report_Error . at "X" . to_vector
            case test_selection.allows_mixed_type_comparisons of
                True -> v1.should_equal ["b", "f"]
                False -> v1.should_fail_with SQL_Error_Data
            v2 = t.filter "ix" (Filter_Condition.Is_In ["c", 3, 2, "a"]) on_problems=Report_Error . at "ix" . to_vector
            case test_selection.allows_mixed_type_comparisons of
                True -> v2.should_equal [2, 3]
                False -> v2.should_fail_with SQL_Error_Data

            t2 = table_builder [["A", [True, False, True]], ["B", [False, False, False]], ["C", [True, False, Nothing]]]
            t2.filter "A" (Filter_Condition.Is_In (t1.at "bool")) . at "A" . to_vector . should_equal [True, True]
            t2.filter "A" (Filter_Condition.Is_In (t1.at "bool" . to_vector)) . at "A" . to_vector . should_equal [True, True]
            t2.filter "B" (Filter_Condition.Is_In [True, Nothing]) . at "B" . to_vector . should_equal []
            t2.filter "C" (Filter_Condition.Is_In [True, Nothing]) . at "C" . to_vector . should_equal [True, Nothing]
            t2.filter "A" (Filter_Condition.Is_In [False]) . at "A" . to_vector . should_equal [False]
            t2.filter "B" (Filter_Condition.Is_In [False]) . at "B" . to_vector . should_equal [False, False, False]
            t2.filter "C" (Filter_Condition.Is_In [False, False]) . at "C" . to_vector . should_equal [False]

        Test.specify "by a boolean mask" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["b", [True, False, Nothing, True, True]]]
            t.filter "b" on_problems=Report_Error . at "ix" . to_vector . should_equal [1, 4, 5]
            t.filter "b" Filter_Condition.Is_False on_problems=Report_Error . at "ix" . to_vector . should_equal [2]

        Test.specify "should correctly reorder all kinds of columns" <|
            t = table_builder [["ints", [1, 2, 3, Nothing, 4]], ["floats", [4.0, Nothing, 3.0, 2.0, 1.0]], ["bools", [False, False, True, Nothing, False]], ["strings", ["a", Nothing, "b", "c", "d"]], ["mask", [False, True, True, True, Nothing]]]
            t2 = t.filter "mask" on_problems=Report_Error
            t2.at "ints" . to_vector . should_equal [2, 3, Nothing]
            t2.at "floats" . to_vector . should_equal [Nothing, 3.0, 2.0]
            t2.at "bools" . to_vector . should_equal [False, True, Nothing]
            t2.at "strings" . to_vector . should_equal [Nothing, "b", "c"]
            t2.at "mask" . to_vector . should_equal [True, True, True]

        Test.specify "should check types of boolean operations" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["b", [True, False, Nothing, True, True]]]
            tester = check_empty ["ix", "b"]
            check_problem problem =
                problem.should_be_a Invalid_Value_Type.Invalid_Value_Type_Data
                problem.expected . should_equal Value_Type.Boolean
            warnings_tester warnings =
                (warnings.length >= 1).should_be_true
                check_problem warnings.first
            error_tester result = check_problem result.catch
            Problems.test_advanced_problem_handling (t.filter "ix" Filter_Condition.Is_True on_problems=_) error_tester warnings_tester tester
            Problems.test_advanced_problem_handling (t.filter "ix" Filter_Condition.Is_False on_problems=_) error_tester warnings_tester tester

        Test.specify "by a custom expression built from table's columns" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", [10, 20, 13, 4, 5]], ["Y", [0, -100, 8, 2, 5]]]
            t.filter (t.at "X" + t.at "Y" > 9) on_problems=Report_Error . at "ix" . to_vector . should_equal [1, 3, 5]

        Test.specify "should handle selection errors: unknown column name" <|
            t = table_builder [["X", [10, 20, 13, 4, 5]]]
            action = t.filter "unknown column" on_problems=_
            tester table =
                table.at "X" . to_vector . should_equal (t.at "X" . to_vector)
            problems = [No_Such_Column_Error_Data "unknown column"]
            Problems.test_problem_handling action problems tester

        Test.specify "should handle selection errors: out of bounds index" <|
            t = table_builder [["X", [10, 20, 13, 4, 5]]]
            action = t.filter 4 on_problems=_
            tester table =
                table.at "X" . to_vector . should_equal (t.at "X" . to_vector)
            problems = [Index_Out_Of_Bounds_Error_Data 4 1]
            Problems.test_problem_handling action problems tester

    Test.group prefix+"Column Operations" pending=pending <|
        Test.specify "iif" <|
            t = table_builder [["X", [True, False, Nothing, True]]]
            t.at "X" . iif 22 33 . to_vector . should_equal [22, 33, Nothing, 22]

        Test.specify "iif on Columns" pending="Not implemented yet." Nothing

    Test.group prefix+"Dropping Missing Values" pending=pending <|
        t0 = table_builder [["a", [0, 1, Nothing, 42, Nothing, 5]], ["b", [True, Nothing, True, False, Nothing, False]], ["c", ["", "foo", "bar", Nothing, Nothing, " "]]]
        t1 =
            a = ["a", [1, Nothing, 3, 4]]
            b = ["b", ["a", "b", Nothing, " "]]
            c = ["c", [10, 20, 30, 40]]
            d = ["d", [Nothing, True, False, True]]
            e = ["e", ["", "", "foo", "bar"]]
            f = ["f", [Nothing, "", Nothing, ""]]
            table_builder [a, b, c, d, e, f]

        Test.specify "filter_blank_rows should drop rows that contain at least one missing cell" <|
            d = t0.filter_blank_rows when_any=True
            d.row_count . should_equal 1
            d.at "a" . to_vector . should_equal [5]
            d.at "b" . to_vector . should_equal [False]
            d.at "c" . to_vector . should_equal [" "]

        Test.specify "filter_blank_rows should drop rows that are all blank" <|
            d2 = t0.filter_blank_rows when_any=False
            d2.at "a" . to_vector . should_equal [0, 1, Nothing, 42, 5]
            d2.at "b" . to_vector . should_equal [True, Nothing, True, False, False]
            d2.at "c" . to_vector . should_equal ["", "foo", "bar", Nothing, " "]

        Test.specify "filter_blank_rows should deal with edge cases" <|
            t1 = table_builder [["X", [Nothing, Nothing, Nothing]]]
            t2 = t1.filter_blank_rows when_any=True
            t2.row_count . should_equal 0
            t2.at "X" . to_vector . should_equal []

            t3 = table_builder [["X", ["", "", Nothing]]]
            t4 = t3.filter_blank_rows when_any=False
            t4.row_count . should_equal 0
            t4.at "X" . to_vector . should_equal []

            empty = table_builder [["X", [1, 2, 3]]] . select_columns []
            empty.row_count . should_equal 0
            empty.columns . should_equal []

            t5 = empty.filter_blank_rows when_any=True
            t5.row_count . should_equal 0
            t5.columns . should_equal []
            t6 = empty.filter_blank_rows when_any=False
            t6.row_count . should_equal 0
            t6.columns . should_equal []

        Test.specify "should allow to remove blank columns" <|
            r1 = t1.remove_columns (Column_Selector.Blank_Columns when_any=False)
            r1.columns.map .name . should_equal ["a", "b", "c", "d", "e"]
            r1.at "a" . to_vector . should_equal [1, Nothing, 3, 4]

            r2 = t1.remove_columns (Column_Selector.Blank_Columns when_any=True)
            r2.columns.map .name . should_equal ["c"]
            r2.at "c" . to_vector . should_equal [10, 20, 30, 40]

        t3 = table_builder [["X", [2.0, 1.5, Number.nan, Number.nan]], ["Y", [Nothing, 2.0, Nothing, 5.0]]]
        t4 =
            c = ["c", [10, 20, 40, 30]]
            g = ["g", [Number.nan, 1, 2, 3.4]]
            h = ["h", [Number.nan, Nothing, Number.nan, Nothing]]
            table_builder [c, g, h]
        if test_selection.is_nan_and_nothing_distinct then
            Test.specify "should not treat NaNs as blank by default" <|
                r1 = t3.filter_blank_rows when_any=True
                # We cannot use `Vector.==` because `NaN != NaN`.
                r1.at "X" . to_vector . to_text . should_equal "[1.5, NaN]"
                r1.at "Y" . to_vector . should_equal [2.0, 5.0]

                r2 = t3.filter_blank_rows when_any=False
                r2.at "X" . to_vector . to_text . should_equal "[2.0, 1.5, NaN, NaN]"
                r2.at "Y" . to_vector . should_equal [Nothing, 2.0, Nothing, 5.0]

                r3 = t4.remove_columns (Column_Selector.Blank_Columns when_any=False)
                r3.columns.map .name . should_equal ["c", "g", "h"]
                r3.at "g" . to_vector . to_text . should_equal "[NaN, 1.0, 2.0, 3.4]"

                r4 = t4.remove_columns (Column_Selector.Blank_Columns when_any=True)
                r4.columns.map .name . should_equal ["c", "g"]
                r4.at "g" . to_vector . to_text . should_equal "[NaN, 1.0, 2.0, 3.4]"

            Test.specify "should allow to treat NaNs as blank if asked" <|
                r1 = t3.filter_blank_rows when_any=True treat_nans_as_blank=True
                # We cannot use `Vector.==` because `NaN != NaN`.
                r1.at "X" . to_vector . should_equal [1.5]
                r1.at "Y" . to_vector . should_equal [2.0]

                r2 = t3.filter_blank_rows when_any=False treat_nans_as_blank=True
                r2.at "X" . to_vector . to_text . should_equal "[2.0, 1.5, NaN]"
                r2.at "Y" . to_vector . should_equal [Nothing, 2.0, 5.0]

                r3 = t4.remove_columns (Column_Selector.Blank_Columns when_any=False treat_nans_as_blank=True)
                r3.columns.map .name . should_equal ["c", "g"]
                r3.at "g" . to_vector . to_text . should_equal "[NaN, 1.0, 2.0, 3.4]"

                r4 = t4.remove_columns (Column_Selector.Blank_Columns when_any=True treat_nans_as_blank=True)
                r4.columns.map .name . should_equal ["c"]
                r4.at "c" . to_vector . should_equal [10, 20, 40, 30]

        if test_selection.is_nan_and_nothing_distinct.not then
            Test.specify "this backend treats NaN as Nothing" <|
                t3.at "X" . to_vector . should_equal [2.0, 1.5, Nothing, Nothing]
                t3.at "X" . is_nan . to_vector . should_fail_with Unsupported_Database_Operation_Error_Data

        Test.specify "Blank_Columns selector should work for all kinds of methods accepting Column_Selector" <|
            t = table_builder [["X", [1, 2, 3, 4]], ["Y", [Nothing, "", Nothing, Nothing]], ["Z", [Nothing, True, False, Nothing]]]

            t.select_columns Column_Selector.Blank_Columns . columns . map .name . should_equal ["Y"]
            t.select_columns (Column_Selector.Blank_Columns when_any=True) . columns . map .name . should_equal ["Y", "Z"]

            t.reorder_columns Column_Selector.Blank_Columns . columns . map .name . should_equal ["Y", "X", "Z"]

            r1 = t.aggregate [Count_Distinct Column_Selector.Blank_Columns]
            r1.columns . map .name . should_equal ["Count Distinct Y"]
            r1.at "Count Distinct Y" . to_vector . should_equal [2]
            r2 = t.aggregate [(Count_Distinct Column_Selector.Blank_Columns ignore_nothing=True)]
            r2.columns . map .name . should_equal ["Count Distinct Y"]
            r2.at "Count Distinct Y" . to_vector . should_equal [1]

        Test.specify "Blank_Columns selector should deal with edge cases" <|
            t = table_builder [["X", [1, 2, 3, 4]]]
            no_cols = t.select_columns []
            no_rows = t.filter "X" (Filter_Condition.Equal to=0)
            no_cols.columns . should_equal []
            no_rows.row_count . should_equal 0
            no_rows.at "X" . to_vector . should_equal []

            no_cols.select_columns Column_Selector.Blank_Columns . columns . map .name . should_equal []
            no_rows.select_columns Column_Selector.Blank_Columns . columns . map .name . should_equal ["X"]
            no_rows.remove_columns Column_Selector.Blank_Columns . columns . map .name . should_equal []

    Test.group prefix+"Table.rows" pending=pending <|
        table = table_builder [["X", [1, 2, 3, 4]], ["Y", [5, 6, 7, 8]], ["Z", ["A", "B", "C", "D"]]]
        Test.specify "should allow to get a Vector of Table rows" <|
            rows = table.rows
            rows.length . should_equal 4

            first_row = rows.first
            first_row . length . should_equal 3
            first_row.at "X" . should_equal 1
            first_row.at "Y" . should_equal 5
            first_row.at "Z" . should_equal "A"

            last_row = rows.at -1
            last_row . length . should_equal 3
            last_row.at 0 . should_equal 4
            last_row.at 1 . should_equal 8
            last_row.at 2 . should_equal "D"
            last_row.at -1 . should_equal "D"

            rows.map .to_vector . should_equal [[1, 5, "A"], [2, 6, "B"], [3, 7, "C"], [4, 8, "D"]]

        Test.specify "should fetch rows up to the specified limit" <|
            table.rows max_rows=2 . map .to_vector . should_equal [[1, 5, "A"], [2, 6, "B"]]

        Test.specify "should correctly handle errors" <|
            table.rows.at 5 . should_fail_with Index_Out_Of_Bounds_Error_Data
            err = table.rows.at -6
            err.should_fail_with Index_Out_Of_Bounds_Error_Data
            err.catch . should_equal (Index_Out_Of_Bounds_Error_Data -6 4)

            table.rows (max_rows=2) . at 2 . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.rows . at 0 . at -4 . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.rows . at 0 . at "unknown" . should_fail_with No_Such_Column_Error_Data

        Test.specify "should visualize nicely" <|
            table.rows . to_default_visualization_data . should_equal <|
                '[[1,5,"A"],[2,6,"B"],[3,7,"C"],[4,8,"D"]]'

            # We limit to at most 100 rows, in the future we should add some kind of 'and N more rows' to the visualization, like is done for Table - or just integrate the lazy vis.
            t2 = table_builder [["X", 0.up_to 200 . to_vector]]
            t2.rows.to_default_visualization_data . should_equal (0.up_to 100 . map (x -> [x])).to_default_visualization_data
