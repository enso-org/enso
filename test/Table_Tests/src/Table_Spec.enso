from Standard.Base import all
from Standard.Base.Error.Problem_Behavior import Report_Error
import Standard.Base.Data.Index_Sub_Range
import Standard.Base.Data.Time.Duration

from Standard.Table import Table, Column, Sort_Column, Column_Selector, Sort_Column_Selector, Aggregate_Column
from Standard.Table.Data.Aggregate_Column.Aggregate_Column import all hiding First, Last
from Standard.Table.Data.Table import Empty_Error
from Standard.Table.Data.Storage import Storage
import Standard.Table.Data.Value_Type.Value_Type
from Standard.Table.Errors import Invalid_Output_Column_Names_Data, Duplicate_Output_Column_Names_Data, No_Input_Columns_Selected, Missing_Input_Columns_Data, No_Such_Column_Error_Data, Floating_Point_Grouping_Data, Invalid_Value_Type

import Standard.Visualization

from Standard.Test import Test, Test_Suite, Problems

import project.Common_Table_Spec
from project.Util import all

type My
    Data x y

    == self that = case that of
        My.Data x1 y1 -> (self.x + self.y) == (x1 + y1)
        _ -> False

    compare_to self that = self.x+self.y . compare_to that.x+that.y

    frobnicate self = case self of
        My.Data x1 y1 -> My.Data y1 x1

spec =
    Test.group "JSON construction" <|
        geo_json = Json.parse <| '''
            {
              "type": "FeatureCollection",
              "features": [
                { "type": "Feature", "properties": { "foo": 1, "bar": "value2"}, "geometry": { "type": "Point", "coordinates": [ -118.58, 34.19 ] } },
                { "type": "Feature", "properties": { "foo": 2, "baz": 3}, "geometry": { "type": "Point", "coordinates": [ 10.11, 4.88, 19 ] } }
              ]
            }
        Test.specify "should allow converting a JSON array into a table" <|
            r_1 = Json.from_pairs [['foo', 20], ['bar', 'baz'], ['baz', False]]
            r_2 = Json.from_pairs [['bar', 'xyz'], ['baz', True]]
            r_3 = Json.from_pairs [['baz', False], ['foo', 13]]
            t = [r_1, r_2, r_3].to_json.to_table ['foo', 'bar', 'baz']
            t.columns.map .name . should_equal ['foo', 'bar', 'baz']
            t.at 'foo' . to_vector . should_equal [20, Nothing, 13]
            t.at 'bar' . to_vector . should_equal ['baz', 'xyz', Nothing]
            t.at 'baz' . to_vector . should_equal [False, True, False]

        Test.specify "should allow converting a GeoJSON array of features into a table" <|
            fields = ['foo', 'bar', 'baz', 'longitude', 'elevation']
            t = geo_json.get "features" . to_table fields
            t.columns.map .name . should_equal fields
            t.at 'foo' . to_vector . should_equal [1, 2]
            t.at 'bar' . to_vector . should_equal ['value2', Nothing]
            t.at 'baz' . to_vector . should_equal [Nothing, 3]
            t.at 'longitude' . to_vector . should_equal [-118.58, 10.11]
            t.at 'elevation' . to_vector . should_equal [Nothing, 19]

        Test.specify "should allow converting a GeoJSON object into a table with provided fields" <|
            fields = ['foo', 'bar', 'longitude']
            t = geo_json.to_table fields
            t.columns.map .name . should_equal fields
            t.at 'foo' . to_vector . should_equal [1, 2]
            t.at 'bar' . to_vector . should_equal ['value2', Nothing]
            t.at 'longitude' . to_vector . should_equal [-118.58, 10.11]

        Test.specify "should allow converting a GeoJSON object into a table containing all available fields" <|
            fields = ['bar', 'baz', 'elevation', 'foo',  'latitude', 'longitude']
            t = geo_json.to_table
            t.columns.map .name . should_equal fields
            t.at 'foo' . to_vector . should_equal [1, 2]
            t.at 'bar' . to_vector . should_equal ['value2', Nothing]
            t.at 'baz' . to_vector . should_equal [Nothing, 3]
            t.at 'longitude' . to_vector . should_equal [-118.58, 10.11]
            t.at 'latitude' . to_vector . should_equal [34.19, 4.88]
            t.at 'elevation' . to_vector . should_equal [Nothing, 19]

    make_varied_type_table =
        strs = ["strs", ["a", "b", "c", Nothing]]
        ints = ["ints", [Nothing, 1, 2, 4]]
        doubles = ["doubles", [0.0, 1.5, Nothing, 2.0]]
        doubles_and_ints = ["doubles_and_ints", [0, 1.5, Nothing, 2]]
        custom_objects = ["custom_objects", [My.Data 1 2, My.Data 3 4, Nothing, Nothing]]
        dates = ["dates", [Nothing, Date.new 2000, Date.new 2022 8 20, Date.new 1999 1 1]]
        times = ["times", [Time_Of_Day.new 18 00, Time_Of_Day.new 1 2 34, Nothing, Time_Of_Day.new]]
        datetimes = ["datetimes", [Date_Time.new 2000, Date_Time.new 1999 1 2 3 4 5, Nothing, Date_Time.new 2022 8 27 11 22 25]]
        mixed = ["mixed", [1, "a", Nothing, Date.new 2022 8 27]]
        mixed_dates = ["mixed_dates", [Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40]]
        just_nulls = ["just_nulls", [Nothing, Nothing, Nothing, Nothing]]

        Table.new [strs, ints, doubles, doubles_and_ints, custom_objects, dates, times, datetimes, mixed, mixed_dates, just_nulls]
    varied_type_table = make_varied_type_table

    Test.group 'Construction' <|
        Test.specify 'should allow creating a table from rows' <|
            header = ['foo', 'bar']
            rows = [[1, False], [2, True], [3, False]]
            r = Table.from_rows header rows

            r.at 'foo' . to_vector . should_equal [1, 2, 3]
            r.at 'bar' . to_vector . should_equal [False, True, False]

        Test.specify "should correctly infer storage types" <|
            varied_type_table.at "strs" . storage_type . should_equal Storage.Text
            varied_type_table.at "ints" . storage_type . should_equal Storage.Integer
            varied_type_table.at "doubles" . storage_type . should_equal Storage.Decimal
            varied_type_table.at "doubles_and_ints" . storage_type . should_equal Storage.Decimal
            varied_type_table.at "custom_objects" . storage_type . should_equal Storage.Any
            varied_type_table.at "dates" . storage_type . should_equal Storage.Date
            varied_type_table.at "times" . storage_type . should_equal Storage.Time_Of_Day
            varied_type_table.at "datetimes" . storage_type . should_equal Storage.Date_Time
            varied_type_table.at "mixed" . storage_type . should_equal Storage.Any
            varied_type_table.at "mixed_dates" . storage_type . should_equal Storage.Any
            varied_type_table.at "just_nulls" . storage_type . should_equal Storage.Any

        pending_python_missing = if Polyglot.is_language_installed "python" . not then
            "Can't run Python tests, Python is not installed."
        Test.specify "should also work with polyglot values coming from Python" pending=pending_python_missing <|
            enso_dates = ["enso_dates", [Date.new 2022 8 27, Date.new 1999 1 1]]
            py_dates = ["py_dates", [py_make_date 2022 8 27, py_make_date 1999 1 1]]
            py_objects = ["py_objects", [py_make_object "a" "b", py_make_object "foo" "bar"]]
            table = Table.new [enso_dates, py_dates, py_objects]
            table.info.at "Column" . to_vector . should_equal ["enso_dates", "py_dates", "py_objects"]
            table.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Date, Storage.Any]

            (table.at "enso_dates" == table.at "py_dates").to_vector . should_equal [True, True]

        Test.specify "should also work with polyglot values coming from JS" <|
            enso_dates = ["enso_dates", [Date.new 2022 8 27, Date.new 1999 1 1]]
            js_dates = ["js_dates", [js_make_date 2022 8 27, js_make_date 1999 1 1]]
            js_objects = ["js_objects", [js_make_object "a" "b", js_make_object "foo" "bar"]]
            table = Table.new [enso_dates, js_dates, js_objects]
            table.info.at "Column" . to_vector . should_equal ["enso_dates", "js_dates", "js_objects"]
            table.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Date_Time, Storage.Any]

            enso_date_times = table.at "enso_dates" . map .to_date_time
            enso_date_times.storage_type . should_equal Storage.Date_Time
            js_converted_dates = table.at "js_dates" . map .date
            js_converted_dates.storage_type . should_equal Storage.Date
            (js_converted_dates == table.at "enso_dates").to_vector . should_equal [True, True]
            (enso_date_times == table.at "js_dates").to_vector . should_equal [True, True]

        Test.specify "should handle Unicode normalization when accessing table columns" <|
            col1 = ['s\u0301ciana', [1, 2, 3]]
            col2 = ['café', [4, 5, 6]]
            t = Table.new [col1, col2]
            t.at 'ściana' . to_vector . should_equal [1, 2, 3]
            t.at 's\u0301ciana' . to_vector . should_equal [1, 2, 3]
            t.at 'cafe\u0301' . to_vector . should_equal [4, 5, 6]
            t.at 'café' . to_vector . should_equal [4, 5, 6]
            t.at 'sciana' . should_fail_with No_Such_Column_Error_Data

    Test.group "Vector conversion" <|
        Test.specify "should allow converting columns to valid vectors" <|
            col_1 = Column.from_vector 'x' [1, 2, 3]
            col_1.to_vector.reduce (+) . should_equal 6

            col_2 = Column.from_vector 'y' [My.Data 1 2, My.Data 2 3]
            col_2.to_vector.map (my -> my.x + my.y) . should_equal [3, 5]

            col_3 = Column.from_vector 'z' [False, True, False]
            col_3.to_vector.map .not . should_equal [True, False, True]

    Test.group "Mapping Operations" <|
        Test.specify "should allow mapping a function over a column" <|
            c_str = Column.from_vector 'x' ['a', 'b', Nothing, 'b']
            c_str.map (+ "x") . to_vector . should_equal ['ax', 'bx', Nothing, 'bx']
            c_int = Column.from_vector 'x' [1, 2, 1, 5, 1]
            c_int.map (+ 1) . to_vector . should_equal [2, 3, 2, 6, 2]
            c_dec = Column.from_vector 'x' [1.9, 2.0, 1.2, 5.6, 1.9]
            c_dec.map (+ 1.5) . to_vector . should_equal [3.4, 3.5, 2.7, 7.1, 3.4]
            c_bool = Column.from_vector 'x' [True, False, Nothing, True, False]
            c_bool.map (_.to_text) . to_vector . should_equal ["True", "False", Nothing, "True", "False"]
            c_any = Column.from_vector 'x' [My.Data 1 6, My.Data 6 3, My.Data 2 5, My.Data 3 4, My.Data 200 300]
            c_any.map (_.frobnicate) . to_vector . should_equal [My.Data 6 1, My.Data 3 6, My.Data 5 2, My.Data 4 3, My.Data 300 200]

        Test.specify "should correctly handle storage of results" <|
            c_int = Column.from_vector 'year' [2022, 2000, 1999]
            r = c_int . map Date_Time.new
            r.to_vector . should_equal [Date_Time.new 2022, Date_Time.new 2000, Date_Time.new 1999]
            r.storage_type . should_equal Storage.Date_Time

        Test.specify "should allow zipping columns with a custom function" <|
            b = Column.from_vector 'w' [6.3, 3.1, 5.2, 4.6, 8.0]
            a = Column.from_vector 'z' ['foo', 'bar', 'baz', 'spam', 'eggs']
            c = a.zip b x-> y-> x + y.to_text
            c.to_vector.should_equal ['foo6.3', 'bar3.1', 'baz5.2', 'spam4.6', 'eggs8.0']
            c.storage_type . should_equal Storage.Text

            x = Column.from_vector 'a' [1, Nothing, 2, Nothing]
            y = Column.from_vector 'b' [0, 0, 0, 0]
            r = x.zip y skip_missing=False x-> y-> if x == 1 then x else y
            r.to_vector.should_equal [1, 0, 0, 0]
            r.storage_type . should_equal Storage.Integer

            u = Column.from_vector 'u' [12, 13, 0]
            v = Column.from_vector 'v' [0, 30, 45]
            r2 = u.zip v h-> m-> Time_Of_Day.new h m
            r2.to_vector . should_equal [Time_Of_Day.new 12 0, Time_Of_Day.new 13 30, Time_Of_Day.new 0 45]
            r2.storage_type . should_equal Storage.Time_Of_Day

        Test.specify "should handle vectorized equality and fall back on non-vectorized if needed" <|
            c_str = Column.from_vector 'x' ['a', 'b', Nothing, 'b']
            (c_str == 'b').to_vector.should_equal [False, True, Nothing, True]
            c_int = Column.from_vector 'x' [1, 2, 1, 5, 1]
            (c_int == 1).to_vector.should_equal [True, False, True, False, True]
            c_dec = Column.from_vector 'x' [1.9, 2.0, 1.2, 5.6, 1.9]
            (c_dec == 1.9).to_vector.should_equal [True, False, False, False, True]
            c_bool = Column.from_vector 'x' [True, False, Nothing, True, False]
            (c_bool == False).to_vector.should_equal [False, True, Nothing, False, True]
            c_any = Column.from_vector 'x' [My.Data 1 6, My.Data 6 3, My.Data 2 5, My.Data 3 4, My.Data 200 300]
            (c_any == My.Data 7 0).to_vector.should_equal [True, False, True, True, False]

        Test.specify "should switch between maps and zips based on argument type" <|
            a = Column.from_vector 'x' [0, 1, 7, 3, 6]
            b = Column.from_vector 'w' [6.3, 3.1, 5.2, Nothing, 8]
            (a + 3.2).to_vector.should_equal [3.2, 4.2, 10.2, 6.2, 9.2]
            (a + b).to_vector.should_equal [6.3, 4.1, 12.2, Nothing, 14]
            gt_const = a > 5
            gt_const.to_vector.should_equal [False, False, True, False, True]
            gt_b = a > b
            gt_b.to_vector.should_equal [False, False, True, Nothing, False]
            both = gt_const && gt_b
            both.to_vector.should_equal [False, False, True, Nothing, False]

        Test.specify "should handle Text operations" <|
            a = Column.from_vector 'a' ["abab", "abc", Nothing, "bca", "acca"]
            nils = [Nothing, Nothing, Nothing, Nothing, Nothing]

            a.starts_with "ab" . to_vector . should_equal [True, True, Nothing, False, False]
            b = Column.from_vector 'b' ["ba", "ab", "d", Nothing, "ac"]
            a.starts_with b . to_vector . should_equal [False, True, Nothing, Nothing, True]
            a.starts_with Nothing . to_vector . should_equal nils

            a.ends_with "ca" . to_vector . should_equal [False, False, Nothing, True, True]
            c = Column.from_vector 'c' ["ab", "b", "d", Nothing, "cc"]
            a.ends_with c . to_vector . should_equal [True, False, Nothing, Nothing, False]
            a.ends_with Nothing . to_vector . should_equal nils

            a.contains "c" . to_vector . should_equal [False, True, Nothing, True, True]
            a.contains c . to_vector . should_equal [True, True, Nothing, Nothing, True]
            a.contains Nothing . to_vector . should_equal nils

        Test.specify "should take Unicode normalization into account in Text operations" <|
            x = Column.from_vector 'x' ['s', 'ś', 's\u0301']
            y = Column.from_vector 'y' ['s\u0301', 's\u0301', 'ś']

            x=='s' . to_vector . should_equal [True, False, False]
            x=='ś' . to_vector . should_equal [False, True, True]
            x=='s\u0301' . to_vector . should_equal [False, True, True]
            x=='ą' . to_vector . should_equal [False, False, False]
            x==y . to_vector . should_equal [False, True, True]

            z = Column.from_vector 'z' ['śląsk', 's\u0301ciana', 'sanok', 'rzeczywistość', 'ostros\u0301c\u0301']
            z.starts_with 's' . to_vector . should_equal [False, False, True, False, False]
            z.starts_with 'ś' . to_vector . should_equal [True, True, False, False, False]
            z.starts_with 's\u0301' . to_vector . should_equal [True, True, False, False, False]
            z.starts_with 'ą' . to_vector . should_equal [False, False, False, False, False]
            z.ends_with 'ść' . to_vector . should_equal [False, False, False, True, True]
            z.ends_with 's\u0301c\u0301' . to_vector . should_equal [False, False, False, True, True]
            z.ends_with 'ok' . to_vector . should_equal [False, False, True, False, False]
            z.contains 's' . to_vector . should_equal [True, False, True, True, True]
            z.contains 'ś' . to_vector . should_equal [True, True, False, True, True]
            z.contains 's\u0301' . to_vector . should_equal [True, True, False, True, True]

    Test.group "Masking Tables" <|
        Test.specify "should allow selecting table rows based on a boolean column" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [True, False, False, True])
            r.at "a" . to_vector . should_equal ["1", "10"]
            r.at "b" . to_vector . should_equal [2, 11]
            r.at "c" . to_vector . should_equal [Nothing, 12]
        Test.specify "should treat NA values in the mask as false and extend the mask with NAs" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [Nothing, True, False])
            r.at "a" . to_vector . should_equal ["4"]
            r.at "b" . to_vector . should_equal [Nothing]
            r.at "c" . to_vector . should_equal [6]
        Test.specify "should work correctly if a mask is bigger than the table itself" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [True, False, False, False, True])
            r.at "a" . to_vector . should_equal ["1"]
            r.at "b" . to_vector . should_equal [2]
            r.at "c" . to_vector . should_equal [Nothing]

    Test.group "Joining Tables" <|
        a_0 = ['x', [0, 1, 7, 3, 6]]
        a_1 = ['y', ["foo", "bar", "baz", "spam", "eggs"]]
        a = Table.new [a_0, a_1]
        b_0 = ['w', [6, 3, 5, 5, 3, 3]]
        b_1 = ['z', ["foo", "foo", "bar", "spam", "bar", "eggs"]]
        b = Table.new [b_0, b_1]

        Test.specify "should allow joining tables index-on-index" <|
            r_1 = a.set_index 'x' . join (b.set_index 'w')
            r_1.at 'y' . to_vector . should_equal ['foo', 'bar', 'baz', 'spam', 'spam', 'spam', 'eggs']
            r_1.at 'z' . to_vector . should_equal [Nothing, Nothing, Nothing, 'foo', 'bar', 'eggs', 'foo']
            r_2 = a.set_index 'y' . join (b.set_index 'z') drop_unmatched=True
            r_2.at 'x' . to_vector . should_equal [0, 0, 1, 1, 3, 6]
            r_2.at 'w' . to_vector . should_equal [6, 3, 5, 3, 5, 3]

        Test.specify "should allow joining tables column-on-index" <|
            r_1 = a.join (b.set_index 'w') on='x'
            r_1.at 'y' . to_vector . should_equal ['foo', 'bar', 'baz', 'spam', 'spam', 'spam', 'eggs']
            r_1.at 'z' . to_vector . should_equal [Nothing, Nothing, Nothing, 'foo', 'bar', 'eggs', 'foo']
            r_2 = a.join (b.set_index 'z') drop_unmatched=True on='y'
            r_2.at 'x' . to_vector . should_equal [0, 0, 1, 1, 3, 6]
            r_2.at 'w' . to_vector . should_equal [6, 3, 5, 3, 5, 3]

        Test.specify "should allow joining tables on the default index" <|
            x = Table.new [['x', [1, 2, 4, 6]]]
            y = Table.new [['y', [8, 9]]]
            r_1 = x.join y
            r_1.at 'x' . to_vector . should_equal [1, 2, 4, 6]
            r_1.at 'y' . to_vector . should_equal [8, 9, Nothing, Nothing]

            r_2 = x.join y drop_unmatched=True
            r_2.at 'x' . to_vector . should_equal [1, 2]
            r_2.at 'y' . to_vector . should_equal [8, 9]

        Test.specify "should append suffixes to disambiguate column names" <|
            x = Table.new [['x', [1, 2, 4, 6]]]
            y = Table.new [['x', [8, 9]]]
            r_1 = x.join y
            r_1.columns.map .name . should_equal ['x_left', 'x_right']

            r_2 = x.join y left_suffix='_old' right_suffix='_new'
            r_2.columns.map .name . should_equal ['x_old', 'x_new']

    Test.group "Filling Missing Values" <|
        Test.specify "should coerce non-coercible types to Object" <|
            strs = Column.from_vector 'x' ["a", Nothing, "b", Nothing]
            strs_filled = strs.fill_missing False
            strs_filled.to_vector . should_equal ["a", False, "b", False]
            strs_filled.storage_type . should_equal Storage.Any

            ints = Column.from_vector 'x' [1, Nothing, 2, Nothing]
            ints_filled = ints.fill_missing "X"
            ints_filled.to_vector . should_equal [1, "X", 2, "X"]
            ints_filled.storage_type . should_equal Storage.Any

            bools = Column.from_vector 'x' [True, False, Nothing]
            bools_filled = bools.fill_missing "X"
            bools_filled.to_vector . should_equal [True, False, "X"]
            bools_filled.storage_type . should_equal Storage.Any

        Test.specify "should coerce long and double types to double" <|
            ints = Column.from_vector 'x' [1, Nothing, 2, Nothing]
            ints_filled = ints.fill_missing 0.5
            ints_filled.to_vector . should_equal [1.0, 0.5, 2.0, 0.5]
            ints_filled.storage_type . should_equal Storage.Decimal

            decimals = Column.from_vector 'x' [0.5, Nothing, Nothing, 0.25]
            decimals_filled = decimals.fill_missing 42
            decimals_filled.to_vector . should_equal [0.5, 42.0, 42.0, 0.25]
            decimals_filled.storage_type . should_equal Storage.Decimal

        Test.specify "should keep String, Boolean, Long and Double type" <|
            strs = Column.from_vector 'x' ["a", Nothing, "b", Nothing]
            strs_filled = strs.fill_missing "X"
            strs_filled.to_vector . should_equal ["a", "X", "b", "X"]
            strs_filled.storage_type . should_equal Storage.Text

            bools = Column.from_vector 'x' [True, False, Nothing]
            bools_filled = bools.fill_missing False
            bools_filled.to_vector . should_equal [True, False, False]
            bools_filled.storage_type . should_equal Storage.Boolean

            ints = Column.from_vector 'x' [1, Nothing, 2, Nothing]
            ints_filled = ints.fill_missing 42
            ints_filled.to_vector . should_equal [1, 42, 2, 42]
            ints_filled.storage_type . should_equal Storage.Integer

            decimals = Column.from_vector 'x' [0.5, Nothing, Nothing, 0.25]
            decimals_filled = decimals.fill_missing 1.0
            decimals_filled.to_vector . should_equal [0.5, 1.0, 1.0, 0.25]
            decimals_filled.storage_type . should_equal Storage.Decimal

    Test.group "Counting Values" <|
        Test.specify "should count missing and non-missing values" <|
            col = Column.from_vector 'x' [1, Nothing, 2]
            col.length . should_equal 3
            col.count . should_equal 2
            col.count_missing . should_equal 1

    Test.group "Dropping Missing Values" <|
        Test.specify "should correctly handle NaNs with mixed type columns" <|
            t = Table.new [["X", [1, 2, 3, 4, 5]], ["Y", ["A", "", Nothing, Number.nan, 0]]]
            t1 = t.filter_blank_rows when_any=True treat_nans_as_blank=False
            t1.at "X" . to_vector . should_equal [1, 4, 5]
            # Comparing text value because `Number.nan != Number.nan`.
            t1.at "Y" . to_vector . to_text . should_equal "['A', NaN, 0]"
            t2 = t.filter_blank_rows when_any=True treat_nans_as_blank=True
            t2.at "X" . to_vector . should_equal [1, 5]
            t2.at "Y" . to_vector . should_equal ['A', 0]

            t3 = Table.new [["X", [1, 2, 3]], ["Y", ["", Nothing, Number.nan]]]
            t4 = t3.remove_columns (Column_Selector.Blank_Columns treat_nans_as_blank=True)
            t4.columns . map .name . should_equal ["X"]

        Test.specify "Blank_Columns selector should work for all kinds of methods accepting Column_Selector" <|
            t = Table.new [["X", [1, 2, 3, 4, 5]], ["Y", ["", Nothing, Nothing, Number.nan, ""]]]
            r1 = t.distinct (Column_Selector.Blank_Columns treat_nans_as_blank=True)
            r1.at "Y" . to_vector . to_text . should_equal "['', Nothing, NaN]"
            r1.at "X" . to_vector . should_equal [1, 2, 4]

            # TODO this could be moved to Common_Table_Spec once replace_text is implemented for Database too
            t2 = Table.new [["X", [1, 2, 3, 4, 5]], ["Y", ["", Nothing, Nothing, Nothing, ""]], ["Z", ["", "---", "-1", "", "foobar"]]]
            r2 = t2.replace_text (Column_Selector.Blank_Columns when_any=True) "-" "A"
            r2.at "X" . to_vector . should_equal [1, 2, 3, 4, 5]
            r2.at "Y" . to_vector . should_equal ["", Nothing, Nothing, Nothing, ""]
            r2.at "Z" . to_vector . should_equal ["", "AAA", "A1", "", "foobar"]

    Test.group "Info" <|
        Test.specify "should return Table information" <|
            a = ["strs", ["a", "b", Nothing, "a"]]
            b = ["ints", [1, 2, Nothing, Nothing]]
            c = ["objs", [1, "a", "c", Any]]
            r = Table.new [a, b, c]
            i = r.info
            i.index . to_vector . should_equal ["strs", "ints", "objs"]
            i.at "Items Count" . to_vector . should_equal [3, 2, 4]
            i.at "Storage Type" . to_vector . should_equal [Storage.Text, Storage.Integer, Storage.Any]

    Test.group "Sorting Tables" <|
        df = (enso_project.data / "clothes.csv").read

        Test.specify "should allow sorting by a single column name" <|
            r_1 = df.order_by (Sort_Column_Selector.By_Name ["Quantity"])
            r_1.at 'Id' . to_vector . should_equal [2,4,1,3,5,6]

            r_3 = df.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "Rating" Sort_Direction.Descending])
            r_3.at 'Id' . to_vector . should_equal [3,1,4,5,2,6]

        Test.specify 'should allow sorting by multiple column names' <|
            r_1 = df.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Quantity', 'Rating'])
            r_1.at 'Id' . to_vector . should_equal [2,4,1,3,6,5]

            r_2 = df.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Rating' Sort_Direction.Descending, Sort_Column.Name 'Quantity' Sort_Direction.Descending])
            r_2.at 'Id' . to_vector . should_equal [3,1,4,5,6,2]

        Test.specify 'should allow sorting with specific by-column rules' <|
            r_1 = df.order_by (Sort_Column_Selector.By_Name ["Quantity", Sort_Column.Name "Price" Sort_Direction.Descending])
            r_1.at 'Id' . to_vector . should_equal [4,2,3,1,6,5]

        Test.specify 'should respect defined comparison operations for custom types' <|
            c_1 = ['id', [1, 2, 3, 4, 5, 6]]
            c_2 = ['val', [My.Data 1 2, My.Data 3 4, My.Data 2 1, My.Data 5 2, My.Data 7 0, My.Data 4 -1]]
            df = Table.new [c_1, c_2]
            r = df.order_by (Sort_Column_Selector.By_Name ['val'])
            r.at 'id' . to_vector . should_equal [1,3,6,2,4,5]

        Test.specify 'should return warnings and errors when passed a non-existent column' <|
            action = df.order_by (Sort_Column_Selector.By_Name ['foobar']) on_problems=_
            tester table =
                table.at 'Id' . to_vector . should_equal [1,2,3,4,5,6]
            problems = [Missing_Input_Columns_Data [Sort_Column.Name 'foobar'], No_Input_Columns_Selected]
            Problems.test_problem_handling action problems tester

        Test.specify 'should correctly reorder all kinds of columns and leave the original columns untouched' <|
            ord = [0, 3, 2, 4, 1]
            ints = [1, 2, 3, 4, 5]
            reals = [1.3, 4.6, 3.2, 5.2, 1.6]
            bools = [False, False, True, True, False]
            texts = ["foo", "foo", "bar", "baz", "spam"]
            dates = [Date.new 2020, Date.new 1999, Date.new 2000 10 3, Date.new 1999 12 31, Date.new 2000 2 7]
            times = [Time_Of_Day.new 12, Time_Of_Day.new 1 30 40, Time_Of_Day.new 23 59 59, Time_Of_Day.new 12 30 0, Time_Of_Day.new 10 20 30]
            datetimes = [Date_Time.new 2020 1 1 12, Date_Time.new 1999 1 1 1 30 40, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 1999 12 31 12 30 0, Date_Time.new 2000 10 3 10 20 30]
            objs = [My.Data 100 2, My.Data 2 3, My.Data 6 7, My.Data 8 9, My.Data 10 30]
            mixed_dates = [Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 2000]

            df = Table.new [['ord', ord], ['ints', ints], ['reals', reals], ['bools', bools], ['texts', texts], ['objs', objs], ['dates', dates], ['times', times], ['datetimes', datetimes], ['mixed_dates', mixed_dates]]
            r = df.order_by (Sort_Column_Selector.By_Name ['ord'])

            r.at 'ints' . to_vector . should_equal [1, 5, 3, 2, 4]
            df.at 'ints' . to_vector . should_equal ints

            r.at 'reals' . to_vector . should_equal [1.3, 1.6, 3.2, 4.6, 5.2]
            df.at 'reals' . to_vector . should_equal reals

            r.at 'bools' . to_vector . should_equal [False, False, True, False, True]
            df.at 'bools' . to_vector . should_equal bools

            r.at 'texts' . to_vector . should_equal ['foo', 'spam', 'bar', 'foo', 'baz']
            df.at 'texts' . to_vector . should_equal texts

            r.at 'objs' . to_vector . should_equal [My.Data 100 2, My.Data 10 30, My.Data 6 7, My.Data 2 3, My.Data 8 9]
            df.at 'objs' . to_vector . should_equal objs

            r.at 'dates' . to_vector . should_equal [Date.new 2020, Date.new 2000 2 7, Date.new 2000 10 3, Date.new 1999, Date.new 1999 12 31]
            df.at 'dates' . to_vector . should_equal dates

            r.at 'times' . to_vector . should_equal [Time_Of_Day.new 12, Time_Of_Day.new 10 20 30, Time_Of_Day.new 23 59 59, Time_Of_Day.new 1 30 40, Time_Of_Day.new 12 30 0]
            df.at 'times' . to_vector . should_equal times

            r.at 'datetimes' . to_vector . should_equal [Date_Time.new 2020 1 1 12, Date_Time.new 2000 10 3 10 20 30, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 1999 1 1 1 30 40, Date_Time.new 1999 12 31 12 30 0]
            df.at 'datetimes' . to_vector . should_equal datetimes

            # TODO move this test to Common_Table_Spec once we support dates there
            r2 = df.order_by (Sort_Column_Selector.By_Name ['dates'])
            r2.at 'dates' . to_vector . should_equal [Date.new 1999, Date.new 1999 12 31, Date.new 2000 2 7, Date.new 2000 10 3, Date.new 2020]
            r2.at 'ints' . to_vector . should_equal [2, 4, 5, 3, 1]

            r3 = df.order_by (Sort_Column_Selector.By_Name ['times'])
            r3.at 'times' . to_vector . should_equal [Time_Of_Day.new 1 30 40, Time_Of_Day.new 10 20 30, Time_Of_Day.new 12, Time_Of_Day.new 12 30 0, Time_Of_Day.new 23 59 59]
            r3.at 'ints' . to_vector . should_equal [2, 5, 1, 4, 3]

            r4 = df.order_by (Sort_Column_Selector.By_Name ['datetimes'])
            r4.at 'datetimes' . to_vector . should_equal [Date_Time.new 1999 1 1 1 30 40, Date_Time.new 1999 12 31 12 30 0, Date_Time.new 2000 10 3 10 20 30, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 2020 1 1 12]
            r4.at 'ints' . to_vector . should_equal [2, 4, 5, 3, 1]

            r5 = df.order_by (Sort_Column_Selector.By_Name ['objs'])
            r5.at 'objs' . to_vector . should_equal [My.Data 2 3, My.Data 6 7, My.Data 8 9, My.Data 10 30, My.Data 100 2]
            r5.at 'ints' . to_vector . should_equal [2, 3, 4, 5, 1]

            r6 = df.order_by (Sort_Column_Selector.By_Name ['mixed_dates'])
            r6 . should_fail_with Incomparable_Values_Error

    Test.group "Sorting Columns" <|
        Test.specify 'should sort columns with specified ordering and missing placement' <|
            c = Column.from_vector 'foo' [1, 7, Nothing, 4, 8, Nothing]

            r_1 = c.sort
            r_1.to_vector.should_equal [1,4,7,8,Nothing,Nothing]

            r_2 = c.sort order=Sort_Direction.Descending
            r_2.to_vector.should_equal [8,7,4,1,Nothing,Nothing]

            r_3 = c.sort order=Sort_Direction.Descending missing_last=False
            r_3.to_vector.should_equal [Nothing,Nothing,8,7,4,1]

        Test.specify 'should respect defined comparison operations for custom types' <|
            c = Column.from_vector 'foo'  [My.Data 1 2, My.Data 3 4, My.Data 2 1, My.Data 5 2, My.Data 7 0, My.Data 4 -1]
            r = c.sort
            r.to_vector.should_equal [My.Data 1 2, My.Data 2 1, My.Data 4 -1, My.Data 3 4, My.Data 5 2, My.Data 7 0]

        Test.specify 'should allow passing a custom comparator' <|
            c = Column.from_vector 'foo' [My.Data 1 2, My.Data 2 5, My.Data 3 4, My.Data 6 3, Nothing, My.Data 1 0]
            cmp a b = (a.x-a.y).abs . compare_to (b.x-b.y).abs
            r = c.sort comparator=cmp
            r.to_vector.should_equal [My.Data 1 2, My.Data 3 4, My.Data 1 0, My.Data 2 5, My.Data 6 3, Nothing]

        Test.specify 'should handle Unicode characters correctly' <|
            c = Column.from_vector 'c' ['z', 'a', 'd', 'f', 's', 'e\u0301', 'ś', 'ą', 's\u0301', 'w', 'b']
            c.sort.to_vector . should_equal ['a', 'ą', 'b', 'd', 'e\u0301', 'f', 's', 's\u0301', 'ś', 'w', 'z']

    Test.group "Concatenating Tables" <|
        Test.specify 'should concat tables with the same schema' <|
            c_1_1 = ['foo', [1, 2, 3, 4]]
            c_1_2 = ['bar', ['baz', 'quux', 'spam', 'eggs']]
            t_1 = Table.new [c_1_1, c_1_2]

            c_2_1 = ['foo', [5, 6, 7]]
            c_2_2 = ['bar', [False, True, False]]
            t_2 = Table.new [c_2_1, c_2_2]

            r = t_1.concat t_2

            r.column_count.should_equal 2
            r.at 'foo' . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            r.at 'bar' . to_vector . should_equal ['baz', 'quux', 'spam', 'eggs', False, True, False]

        Test.specify 'should missing-pad unmatched columns' <|
            c_1_1 = ['foo', [1, 2, 3, 4]]
            c_1_2 = ['bar', ['baz', 'quux', 'spam', 'eggs']]
            t_1 = Table.new [c_1_1, c_1_2]

            c_2_1 = ['foo', [5, 6, 7]]
            c_2_2 = ['baz', [False, True, False]]
            t_2 = Table.new [c_2_1, c_2_2]

            r = t_1.concat t_2

            r.column_count.should_equal 3
            r.at 'foo' . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            r.at 'bar' . to_vector . should_equal ['baz', 'quux', 'spam', 'eggs', Nothing, Nothing, Nothing]
            r.at 'baz' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, False, True, False]

        Test.specify 'should concatenate indexes' <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col', [5, 6, 7]]

            i_2 = ['ix_2', [False, True]]
            c_2 = ['col', [7, 8]]

            t_1 = Table.new [i_1, c_1] . set_index 'ix'
            t_2 = Table.new [i_2, c_2] . set_index 'ix_2'

            r = t_1.concat t_2

            r.index.to_vector.should_equal [1, 2, 3, False, True]

    Test.group "Index" <|
        t = Table.new [['ix', [1, 2, 3]], ['c1', [4, 5, 6]]] . set_index 'ix'
        c = Column.from_vector "name" ["a", "b", "c"]
        Test.specify "should be accessible by `at` like other columns" <|
            c = t.at 'ix'
            i = t.index
            c.to_vector . should_equal i.to_vector

        Test.specify "should be able to be set by column" <|
            with_index = t.set_index c
            with_index.index.to_vector . should_equal c.to_vector

    Test.group "Slicing Tables" <|
        Test.specify 'should allow taking first n rows' <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3] . set_index 'ix'

            t_1.take (First 10) . at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector)
            t_1.take 10 . at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector)

            t_2 = t_1.take (First 2)
            t_2.index.to_vector . should_equal (t_1.index.to_vector . take (First 2))
            t_2.at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector . take (First 2))
            t_2.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take (First 2))
            t_2.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take (First 2))

            t_3 = t_1.take 2
            t_3.index.to_vector . should_equal (t_1.index.to_vector . take 2)
            t_3.at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector . take 2)
            t_3.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take 2)
            t_3.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take 2)

            t_1.at 'col' . take (First 2) . to_vector . should_equal (t_1.at 'col' . to_vector . take (First 2))
            t_1.at 'col' . take 2 . to_vector . should_equal (t_1.at 'col' . to_vector . take 2)

        Test.specify "should allow taking the last n rows" <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col1', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3] . set_index 'ix'

            t_1.take (Last 10) . at 'col1' . to_vector . should_equal (t_1.at 'col1' . to_vector)

            t_2 = t_1.take (Last 2)
            t_2.index.to_vector . should_equal (t_1.index.to_vector . take (Last 2))
            t_2.at 'col1' . to_vector . should_equal (t_1.at 'col1' . to_vector . take (Last 2))
            t_2.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take (Last 2))
            t_2.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take (Last 2))

            t_1.at 'col1' . take (Last 2) . to_vector . should_equal (t_1.at 'col1' . to_vector . take (Last 2))

        Test.specify "should allow taking/dropping a prefix of rows that satisfy a predicate" <|
            t1 = Table.new [["X", [1, 2, 3, 4, 5, 5]], ["Y", [9, 8, 7, 2, 10, 5]]]

            t2 = t1.take (Index_Sub_Range.While row-> row.to_vector.sum == 10)
            t2.at "X" . to_vector . should_equal [1, 2, 3]
            t2.at "Y" . to_vector . should_equal [9, 8, 7]

            t3 = t1.drop (Index_Sub_Range.While row-> row.to_vector.sum == 10)
            t3.at "X" . to_vector . should_equal [4, 5, 5]
            t3.at "Y" . to_vector . should_equal [2, 10, 5]

            t4 = t1.take (Index_Sub_Range.While row-> row.at "X" < 3)
            t4.at "X" . to_vector . should_equal [1, 2]
            t4.at "Y" . to_vector . should_equal [9, 8]

            t5 = t1.drop (Index_Sub_Range.While row-> row.at 1 > 3)
            t5.at "X" . to_vector . should_equal [4, 5, 5]
            t5.at "Y" . to_vector . should_equal [2, 10, 5]

            t6 = t1.take (Index_Sub_Range.While row-> row.at "X" > 1)
            t6.at "X" . to_vector . should_equal []
            t6.at "Y" . to_vector . should_equal []

        Test.specify "should allow reversing the table" <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col1', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3] . set_index 'ix'

            expected_i_1 = ['ix', [3, 2, 1]]
            expected_c_1 = ['col1', [7, 6, 5]]
            expected_c_2 = ['col2', ["c", Nothing, "a"]]
            expected_c_3 = ['col3', [Nothing, True, False]]
            expected = Table.new [expected_i_1, expected_c_1, expected_c_2, expected_c_3] . set_index 'ix'

            t_2 = t_1.reverse

            t_2.index.to_vector . should_equal expected.index.to_vector
            t_2.at 'col1' . to_vector . should_equal (expected.at 'col1' . to_vector)
            t_2.at 'col2' . to_vector . should_equal (expected.at 'col2' . to_vector)
            t_2.at 'col3' . to_vector . should_equal (expected.at 'col3' . to_vector)

    Test.group "Visualizing tables" <|
        Test.specify "should specify default visualizations correctly" <|
            c_1_1 = ['x', [1, 2, 3]]
            c_1_2 = ['Y', [5.3, 56.2, 6.3]]
            t_1 = Table.new [c_1_1, c_1_2]
            t_1.default_visualization.should_equal Visualization.Id.scatter_plot

            c_2_1 = ['LaTituDe', [5,3,2]]
            c_2_2 = ['longitude', [6,7,8]]
            t_2 = Table.new [c_2_1, c_2_2]
            t_2.default_visualization.should_equal Visualization.Id.geo_map

            c_3_1 = ['latitude', [5,2,5]]
            c_3_2 = ['Y', [2,4,2]]
            c_3_3 = ['name', ["foo", "bar", "baz"]]
            t_3 = Table.new [c_3_1, c_3_2, c_3_3]
            t_3.default_visualization.should_equal Visualization.Id.table

    selection = Common_Table_Spec.Test_Selection.Config supports_case_sensitive_columns=True order_by=True natural_ordering=True case_insensitive_ordering=True order_by_unicode_normalization_by_default=True supports_unicode_normalization=True
    Common_Table_Spec.spec "[In-Memory] " table_builder=Table.new test_selection=selection

    Test.group "Use First Row As Names" <|
        expect_column_names names table =
            table.columns . map .name . should_equal names frames_to_skip=2

        Test.specify "should work happily with mixed types" <|
            c_0 = ['A', ["H", "B", "C"]]
            c_1 = ['B', [Date.new 1980, Date.new 1979, Date.new 2000]]
            c_2 = ['x', [1, 2, 3]]
            c_3 = ['Y', [5.3, 56.2, 6.3]]
            c_4 = ['Z', [True, False, True]]
            table = Table.new [c_0, c_1, c_2, c_3, c_4]
            expect_column_names ["H", "1980-01-01", "1", "5.3", "True"] <| table.use_first_row_as_names

        Test.specify "should correctly handle problems: invalid names ''" <|
            c_0 = ['A', ["", "B", "C"]]
            c_2 = ['x', [1, 2, 3]]
            table = Table.new [c_0, c_2]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["Column_1", "1"]
            problems = [Invalid_Output_Column_Names_Data [""]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names Nothing" <|
            c_0 = ['A', ["A", "B", "C"]]
            c_2 = ['x', [Nothing, 2, 3]]
            table = Table.new [c_0, c_2]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["A", "Column_1"]
            problems = [Invalid_Output_Column_Names_Data [Nothing]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            c_0 = ['A', ["A", "B", "C"]]
            c_1 = ['B', ["A", "B", "C"]]
            c_2 = ['x', ["A", "B", "C"]]
            c_3 = ['C', ["A", "B", "C"]]
            table = Table.new [c_0, c_1, c_2, c_3]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["A", "A_1", "A_2", "A_3"]
            problems = [Duplicate_Output_Column_Names_Data ["A", "A", "A"]]
            Problems.test_problem_handling action problems tester

    Test.group "Table.replace_text" <|
        Test.specify "should replace text in full-text table columns" <|
            bools = ["bools", [False, False, True, True, False]]
            texts = ["texts", ["foo", "foo", "bar", "baz", "spam"]]
            table = Table.new [bools, texts]
            actual = table.replace_text "texts" "a" "o"
            actual.at "bools" . to_vector . should_equal [False, False, True, True, False]
            actual.at "texts" . to_vector . should_equal ["foo", "foo", "bor", "boz", "spom"]
            Problems.assume_no_problems actual

        Test.specify "should replace text in mixed columns" <|
            bools = ["bools", [False, False, True, True, False]]
            mixed = ["mixed", ["foo", 5, "bar", False, "spam"]]
            table = Table.new [bools, mixed]
            actual = table.replace_text "mixed" "a" "o"
            actual.at "bools" . to_vector . should_equal [False, False, True, True, False]
            actual.at "mixed" . to_vector . should_equal ["foo", 5, "bor", False, "spom"]
            Problems.assume_no_problems actual

        Test.specify "should support operating on multiple columns at once" <|
            bools = ["bools", [False, False, True]]
            texts1 = ["texts1", ["foo", "bar", "baz"]]
            texts2 = ["texts2", ["baz", "quux", "spam"]]
            table = Table.new [bools, texts1, texts2]
            actual = table.replace_text (Column_Selector.By_Name ["texts1", "texts2"]) "a" "o"
            actual.at "bools"  . to_vector . should_equal [False, False, True]
            actual.at "texts1" . to_vector . should_equal ["foo", "bor", "boz"]
            actual.at "texts2" . to_vector . should_equal ["boz", "quux", "spom"]
            Problems.assume_no_problems actual

        Test.specify "should support regex replacement" <|
            bools = ["bools", [False, False, True, True, False]]
            texts = ["texts", ["foo", "bar", "baz", "spam"]]
            table = Table.new [bools, texts]
            actual = table.replace_text "texts" "(a|o)" "$1e" matcher=Regex_Matcher.Regex_Matcher_Data
            actual.at "texts" . to_vector . should_equal ["foeoe", "baer", "baez", "spaem"]
            Problems.assume_no_problems actual

        Test.specify 'should return warnings and errors when passed a non-existent column' <|
            table = Table.new [["bools", [False, True]], ["texts", ["foo", "bar"]]]
            action = table.replace_text "invalid_name" "a" "b" on_problems=_
            tester = _.should_equal table
            problems = [Missing_Input_Columns_Data ['invalid_name']]
            Problems.test_problem_handling action problems tester

        Test.specify "should return warnings and errors when selected non-text column" <|
            table = Table.new [["bools", [False, True]], ["texts", ["foo", "bar"]]]
            action = table.replace_text "bools" "a" "b" on_problems=_
            tester = _.should_equal table
            problems = [Invalid_Value_Type.Invalid_Value_Type_Data Value_Type.Char Value_Type.Boolean]
            Problems.test_problem_handling action problems tester

    Test.group "[In-Memory] Table.aggregate" <|
        Test.specify "should return columns with correct types" <|
            dates = ["dates", [Date.new 1999, Date.new 2000, Date.new 2000, Date.new 2000]]
            texts = ["texts", ["a", "bb", "a", "bb"]]
            mixed = ["mixed", [1, "a", "a", 1]]
            ints = ["ints", [0, 1, 1, 0]]
            floats = ["floats", [0.1, 1.0, 2.0, 1.5]]
            objects = ["objects", [My.Data 0 1, My.Data 0 1, My.Data 2 2, My.Data 2 2]]
            table = Table.new [dates, texts, mixed, ints, floats, objects]

            t1 = table.aggregate [Group_By "dates", Shortest "texts", Aggregate_Column.First "texts", Aggregate_Column.First "objects", Aggregate_Column.First "ints", Aggregate_Column.Last "mixed"]
            t1.info.at "Column" . to_vector . should_equal ["dates", "Shortest texts", "First texts", "First objects", "First ints", "Last mixed"]
            t1.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Text, Storage.Text, Storage.Any, Storage.Integer, Storage.Any]

            t2 = table.aggregate [Mode "dates", Count_Not_Nothing "objects", Count_Distinct "texts", Minimum "ints", Maximum "floats"]
            t2.info.at "Column" . to_vector . should_equal ["Mode dates", "Count Not Nothing objects", "Count Distinct texts", "Minimum ints", "Maximum floats"]
            t2.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Integer, Storage.Integer, Storage.Integer, Storage.Decimal]

            t3 = table.aggregate [Group_By "texts", Group_By "ints", Aggregate_Column.Last "floats"]
            t3.info.at "Column" . to_vector . should_equal ["texts", "ints", "Last floats"]
            t3.info.at "Storage Type" . to_vector . should_equal [Storage.Text, Storage.Integer, Storage.Decimal]

            t4 = table.aggregate [Group_By "mixed", Sum "ints", Sum "floats"]
            t4.info.at "Column" . to_vector . should_equal ["mixed", "Sum ints", "Sum floats"]
            t4.info.at "Storage Type" . to_vector . should_equal [Storage.Any, Storage.Decimal, Storage.Decimal]

        Test.specify "should take Unicode normalization into account when grouping by Text" <|
            texts = ["texts", ['ściana', 'ściana', 'łąka', 's\u0301ciana', 'ła\u0328ka', 'sciana']]
            ints = ["ints", [1, 2, 4, 8, 16, 32]]
            table = Table.new [texts, ints]
            r1 = table.aggregate [Group_By "texts", Sum "ints"] . order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "texts"])
            r1.at "texts" . to_vector . should_equal ['sciana', 'ściana', 'łąka']
            r1.at "Sum ints" . to_vector . should_equal [32, 11, 20]

            r2 = table.aggregate [Count_Distinct "texts"]
            r2.at "Count Distinct texts" . to_vector . should_equal [3]

    ## We have a separate set of tests for In-Memory distinct as it gives us
       more guarantees: preserving order of rows and always selecting the first
       row of ones sharing the same distinctness key. For database tests (to be
       added later) we can not rely on ordering.
    Test.group "[In-Memory] Table.distinct" <|
        Test.specify "should allow to select distinct rows based on a subset of columns" <|
            a = ["A", ["a", "a", "a", "a", "a", "a"]]
            b = ["B", [1, 1, 2, 2, 1, 2]]
            c = ["C", [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]]
            t = Table.new [a, b, c]

            r1 = t.distinct (Column_Selector.By_Name ["A"]) on_problems=Report_Error
            r1.at "A" . to_vector . should_equal ["a"]
            r1.at "B" . to_vector . should_equal [1]
            r1.at "C" . to_vector . should_equal [0.1]

            r2 = t.distinct (Column_Selector.By_Name ["A", "B"]) on_problems=Report_Error
            r2.at "A" . to_vector . should_equal ["a", "a"]
            r2.at "B" . to_vector . should_equal [1, 2]
            r2.at "C" . to_vector . should_equal [0.1, 0.3]

            r3 = t.distinct ["A"] on_problems=Report_Error
            r3.at "A" . to_vector . should_equal ["a"]
            r3.at "B" . to_vector . should_equal [1]
            r3.at "C" . to_vector . should_equal [0.1]

            r4 = t.distinct ["A", "B"] on_problems=Report_Error
            r4.at "A" . to_vector . should_equal ["a", "a"]
            r4.at "B" . to_vector . should_equal [1, 2]
            r4.at "C" . to_vector . should_equal [0.1, 0.3]

        Test.specify "should handle nulls correctly" <|
            a = ["A", ["a", Nothing, "b", "a", "b", Nothing, "a", "b"]]
            b = ["B", [1, 2, 3, 4, 5, 6, 7, 8]]
            t = Table.new [a, b]
            r = t.distinct (Column_Selector.By_Name ["A"]) on_problems=Report_Error
            r.at "A" . to_vector . should_equal ["a", Nothing, "b"]
            r.at "B" . to_vector . should_equal [1, 2, 3]

        Test.specify "should handle Unicode normalization of keys correctly" <|
            t1 = Table.new [["X", ['ś', 's\u0301', 's', 'ś']]]
            t1.distinct . at "X" . to_vector . should_equal ['ś', 's']

        Test.specify "should allow to control case-sensitivity of keys" <|
            x = ["X", ['A', 'a', 'enso', 'śledź', 'Enso', 'A', 's\u0301ledz\u0301']]
            y = ["Y", [1, 2, 3, 4, 5, 6, 7]]
            t1 = Table.new [x, y]
            d1 = t1.distinct (Column_Selector.By_Name ["X"]) on_problems=Report_Error
            d1.at "X" . to_vector . should_equal ['A', 'a', 'enso', 'śledź', 'Enso']
            d1.at "Y" . to_vector . should_equal [1, 2, 3, 4, 5]

            d2 = t1.distinct (Column_Selector.By_Name ["X"]) case_sensitivity=Case_Sensitivity.Insensitive on_problems=Report_Error
            d2.at "X" . to_vector . should_equal ['A', 'enso', 'śledź']
            d2.at "Y" . to_vector . should_equal [1, 3, 4]

            t2 = Table.new [["X", ["łąka", "STRASSE", "Straße", "ﬃ", "ŁĄka", "ffi"]]]
            t2.distinct case_sensitivity=Case_Sensitivity.Insensitive . at "X" . to_vector . should_equal ["łąka", "STRASSE", "ﬃ"]

        Test.specify "should report a warning if the key contains floating point values" <|
            t1 = Table.new [["X", [3.0, 1.0, 2.0, 2.0, 1.0]]]
            action1 = t1.distinct on_problems=_
            tester1 table =
                table.at "X" . to_vector . should_equal [3.0, 1.0, 2.0]
            problems1 = [Floating_Point_Grouping_Data "Distinct" [0, 1, 2, 3, 4]]
            Problems.test_problem_handling action1 problems1 tester1

            t2 = Table.new [["X", [1.00000000000001, -0.3, 1.00000000000002, 1.5, 1.00000000000002, 1.00000000000002]]]
            action2 = t2.distinct on_problems=_
            tester2 table =
                table.at "X" . to_vector . should_equal [1.00000000000001, -0.3, 1.00000000000002, 1.5]
            problems2 = [Floating_Point_Grouping_Data "Distinct" [0, 1, 2, 3, 4, 5]]
            Problems.test_problem_handling action2 problems2 tester2

        Test.specify "should report a warning and report the whole table if no columns were selected" <|
            t = Table.new [["A", [1, 2, 1, 1]]]
            test table = table.should_equal t

            action1 = t.distinct (Column_Selector.By_Name []) on_problems=_
            problems1 = [No_Input_Columns_Selected]
            Problems.test_problem_handling action1 problems1 test

            action2 = t.distinct (Column_Selector.By_Name ["mismatched"]) on_problems=_
            problems2 = [Missing_Input_Columns_Data ["mismatched"], No_Input_Columns_Selected]
            Problems.test_problem_handling action2 problems2 test

        Test.specify "until hashing is supported, should throw an error when trying to aggregate a custom object" <|
            t = Table.new [["X", [My.Data 1 2, My.Data 3 4, My.Data 1 2]]]
            t.distinct . should_fail_with Illegal_Argument_Error_Data

        Test.specify "should group by all columns by default" <|
            a = ["A", ["a", "b", "a", "b", "a", "b"]]
            b = ["B", [2, 1, 2, 2, 2, 1]]
            t = Table.new [a, b]
            r = t.distinct on_problems=Report_Error
            r.at "A" . to_vector . should_equal ["a", "b", "b"]
            r.at "B" . to_vector . should_equal [2, 1, 2]
    Test.group "[In-Memory] Table.filter" <|
        Test.specify "by a custom predicate" <|
            t = Table.new [["ix", [1, 2, 3, 4, 5]], ["X", [5, 0, 4, 5, 1]]]
            t1 = t.filter "X" (x -> x % 2 == 0)
            t1.at "ix" . to_vector . should_equal [2, 3]
            t1.at "X" . to_vector . should_equal [0, 4]

            t2 = t.filter 1 (>2)
            t2.at "ix" . to_vector . should_equal [1, 3, 4]
            t2.at "X" . to_vector . should_equal [5, 4, 5]

            t3 = t.filter (t.at "X" + 1) (x -> x % 2 == 0)
            t3.at "ix" . to_vector . should_equal [1, 4, 5]
            t3.at "X" . to_vector . should_equal [5, 5, 1]

        Test.specify "by custom object comparisons" <|
            t = Table.new [["ix", [1, 2, 3, 4, 5]], ["X", [My.Data 1 2, My.Data 300 400, My.Data 100 200, My.Data 5 6, My.Data 7 8]]]
            t1 = t.filter "X" (Filter_Condition.Between (My.Data 10 20) (My.Data 300 400))
            t1.at "ix" . to_vector . should_equal [2, 3]
            t1.at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200]
            t.filter "X" (Filter_Condition.Less than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 1 2]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 1 2, My.Data 5 6]
            t.filter "X" (Filter_Condition.Greater than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200, My.Data 7 8]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200, My.Data 5 6, My.Data 7 8]
            t.filter "X" (Filter_Condition.Equal to=(My.Data 2 1)) . at "X" . to_vector . should_equal [My.Data 1 2]
            t.filter "X" (Filter_Condition.Equal to=42) . at "X" . to_vector . should_equal []

            c = Column.from_vector "Y" [My.Data 2 1, My.Data 400 300, My.Data 101 202, My.Data 10 10, My.Data 15 0]
            t.filter "X" (Filter_Condition.Equal to=c) . at "X" . to_vector . should_equal [My.Data 1 2, My.Data 300 400, My.Data 7 8]
            t.filter "X" (Filter_Condition.Less than=c) . at "X" . to_vector . should_equal [My.Data 100 200, My.Data 5 6]
            t.filter "X" (Filter_Condition.Greater than=c) . at "X" . to_vector . should_equal []

        Test.specify "by a boolean mask of varying length" <|
            t = Table.new [["A", [1, 2, 3]], ["B", [4, 5, 6]]]

            t1 = t.filter (Column.from_vector "f" [False, True])
            t1.at "A" . to_vector . should_equal [2]
            t1.at "B" . to_vector . should_equal [5]

            t2 = t.filter (Column.from_vector "f" [False, True, True, True, True, True, True, True])
            t2.at "A" . to_vector . should_equal [2, 3]
            t2.at "B" . to_vector . should_equal [5, 6]

        Test.specify "by an Is_In check, on various types of columns" <|
            ins = Table.new <|
                str = ["str", ["c", "b", Nothing, Nothing]]
                int = ["int", [1, 2, 3, 3]]
                int2 = ["int2", [1, Nothing, Nothing, 1]]
                dbl = ["dbl", [0.0, 0.0, Nothing, Nothing]]
                dates = ["dates", [Date.new 2000, Date.new 1999 1 1, Date.new 1999 1 1, Date_Time.new 2022 8 20]]
                dts = ["dts", [Date_Time.new 2022 8 27 11 22 25, Nothing, Date_Time.new 2030, Date.new 2000]]
                tod = ["tod", [Time_Of_Day.new 18 00, Time_Of_Day.new 18 19, Date_Time.new 2000 1 1, Time_Of_Day.new 18 19]]
                mix = ["mix", [42, Date_Time.new 2022 8 27, 1, 1]]
                nulls = ["nulls", [Nothing, Nothing, Nothing, 0]]
                custom = ["custom", [2, My.Data 2 1, Nothing, Nothing]]
                [str, int, int2, dbl, dates, dts, tod, mix, nulls, custom]
            varied_type_table.filter "strs" (Filter_Condition.Is_In (ins.at "str")) . at "strs" . to_vector . should_equal ["b", "c", Nothing]
            varied_type_table.filter "strs" (Filter_Condition.Is_In (ins.at "str" . to_vector)) . at "strs" . to_vector . should_equal ["b", "c", Nothing]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int")) . at "ints" . to_vector . should_equal [1, 2]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int" . to_vector)) . at "ints" . to_vector . should_equal [1, 2]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int2")) . at "ints" . to_vector . should_equal [Nothing, 1]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int2" . to_vector)) . at "ints" . to_vector . should_equal [Nothing, 1]
            varied_type_table.filter "doubles" (Filter_Condition.Is_In (ins.at "dbl")) . at "doubles" . to_vector . should_equal [0.0, Nothing]
            varied_type_table.filter "doubles" (Filter_Condition.Is_In (ins.at "dbl" . to_vector)) . at "doubles" . to_vector . should_equal [0.0, Nothing]
            varied_type_table.filter "dates" (Filter_Condition.Is_In (ins.at "dates")) . at "dates" . to_vector . should_equal [Date.new 2000, Date.new 1999 1 1]
            varied_type_table.filter "dates" (Filter_Condition.Is_In (ins.at "dates" . to_vector)) . at "dates" . to_vector . should_equal [Date.new 2000, Date.new 1999 1 1]
            varied_type_table.filter "datetimes" (Filter_Condition.Is_In (ins.at "dts")) . at "datetimes" . to_vector . should_equal [Nothing, Date_Time.new 2022 8 27 11 22 25]
            varied_type_table.filter "datetimes" (Filter_Condition.Is_In (ins.at "dts" . to_vector)) . at "datetimes" . to_vector . should_equal [Nothing, Date_Time.new 2022 8 27 11 22 25]
            varied_type_table.filter "times" (Filter_Condition.Is_In (ins.at "tod")) . at "times" . to_vector . should_equal [Time_Of_Day.new 18 00]
            varied_type_table.filter "times" (Filter_Condition.Is_In (ins.at "tod" . to_vector)) . at "times" . to_vector . should_equal [Time_Of_Day.new 18 00]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In [42, "a", 1, Nothing, Date.new 2022 8 27, Date_Time.new 2022 8 27]) . at "mixed" . to_vector . should_equal [1, "a", Nothing, Date.new 2022 8 27]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In (ins.at "mix")) . at "mixed" . to_vector . should_equal [1]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In (ins.at "mix" . to_vector)) . at "mixed" . to_vector . should_equal [1]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In []) . at "just_nulls" . to_vector . should_equal []
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In (ins.at "nulls")) . at "just_nulls" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In (ins.at "nulls" . to_vector)) . at "just_nulls" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In [0]) . at "just_nulls" . to_vector . should_equal []
            varied_type_table.filter "custom_objects" (Filter_Condition.Is_In (ins.at "custom")) . at "custom_objects" . to_vector . should_equal [My.Data 1 2, Nothing, Nothing]
            varied_type_table.filter "custom_objects" (Filter_Condition.Is_In (ins.at "custom" . to_vector)) . at "custom_objects" . to_vector . should_equal [My.Data 1 2, Nothing, Nothing]

            t2 = Table.new [["ints", [1, 2, 3]], ["doubles", [1.2, 0.0, 1.0]]]
            t2.filter "ints" (Filter_Condition.Is_In [2.0, 1.5, 3, 4]) . at "ints" . to_vector . should_equal [2, 3]
            t2.filter "doubles" (Filter_Condition.Is_In [0.1, 1, 3, 1.2]) . at "doubles" . to_vector . should_equal [1.2, 1.0]
            t3 = Table.new [["ints", [0, 2]], ["doubles", [1.0, 2.0]]]
            t2.filter "ints" (Filter_Condition.Is_In (t3.at "doubles")) . at "ints" . to_vector . should_equal [1, 2]
            t2.filter "doubles" (Filter_Condition.Is_In (t3.at "ints")) . at "doubles" . to_vector . should_equal [0.0]

            # We test these very carefully as our implementation relies on some short-circuit logic that is not as trivial as the hashmap checks which are done for other builtin types.
            [True, False].each has_nulls->
                [True, False].each has_true->
                    [True, False].each has_false->
                        vec_builder = Vector.new_builder
                        if has_nulls then vec_builder.append Nothing
                        if has_true then vec_builder.append True
                        if has_false then vec_builder.append False
                        in_vector = vec_builder.to_vector

                        vectors = [[True, False, Nothing], [Nothing, Nothing, Nothing], [False, False, True], [True, True, True], [False, False, False], [Nothing, True, True], [False, Nothing, False]]
                        vectors.each column_vector->
                            not x = case x of
                                True -> False
                                False -> True
                                Nothing -> Nothing
                            negated_column_vector = column_vector.map not
                            t = Table.new [["X", column_vector]]
                            in_column = Column.from_vector "in" in_vector

                            expected_vector = column_vector.filter (Filter_Condition.Is_In in_vector)
                            expected_neg_vector = negated_column_vector.filter (Filter_Condition.Is_In in_vector)

                            t.filter "X" (Filter_Condition.Is_In in_vector) on_problems=Report_Error . at "X" . to_vector . should_equal expected_vector
                            t.filter "X" (Filter_Condition.Is_In in_column) on_problems=Report_Error . at "X" . to_vector . should_equal expected_vector
                            t2 = t.set "Y" (t.at "X" . not)
                            t2.filter "Y" (Filter_Condition.Is_In in_vector) on_problems=Report_Error . at "Y" . to_vector . should_equal expected_neg_vector
                            t2.filter "Y" (Filter_Condition.Is_In in_column) on_problems=Report_Error . at "Y" . to_vector . should_equal expected_neg_vector

        Test.specify "should perform `Is_In` efficiently for builtin types" <|
            first_day = Date_Time.new 2000 1 1
            make_date x = first_day + (Duration.new seconds=x)
            init = Duration.time_execution <|
                t = Table.new [["X", (200.up_to 10000 . to_vector)]]
                vec = 4000.up_to 13000 . to_vector
                expected_vector = 4000.up_to 10000 . to_vector
                expected_vector_2 = 200.up_to 10000 . with_step 2 . to_vector
                dates_vec = vec.map make_date
                bool_vec = Vector.fill 7000 True
                date_col = t.at "X" . map make_date
                [t, vec, expected_vector, expected_vector_2, dates_vec, bool_vec, date_col]
            t = init.second . at 0
            vec = init.second . at 1
            expected_vector = init.second . at 2
            expected_vector_2 = init.second . at 3
            dates_vec = init.second . at 4
            bool_vec = init.second . at 5
            date_col = init.second . at 6

            expected_max_time_ms = init.first.total_milliseconds * 2
            check_timing name ~action =
                res = Duration.time_execution action
                runtime_ms = res.first.total_milliseconds
                if runtime_ms > expected_max_time_ms then
                    Test.fail "Expected `Is_In` on "+name+" to be efficient, but it took "+runtime_ms.to_text+"ms while initialization itself took just "+expected_max_time_ms.to_text+"ms."

            check_timing "integers" <|
                t.filter "X" (Filter_Condition.Is_In vec) . at "X" . to_vector . should_equal expected_vector

            check_timing "booleans" <|
                t.filter (t.at "X" % 2 == 0) (Filter_Condition.Is_In bool_vec) . at "X" . to_vector . should_equal expected_vector_2

            check_timing "dates" <|
                t.filter date_col (Filter_Condition.Is_In dates_vec) . at "X" . to_vector . should_equal expected_vector

main = Test_Suite.run_main spec

## JS indexes months form 0, so we need to subtract 1.
foreign js js_make_date year month day = """
    return new Date(year, month - 1, day)

foreign js js_make_object key value = """
    var obj = {}
    obj[key] = value
    return obj

foreign python py_make_date year month day = """
    import datetime
    return datetime.date(year, month, day)

foreign python py_make_object key value = """
    return {key: value}
