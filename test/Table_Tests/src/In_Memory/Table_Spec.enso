from Standard.Base import all
import Standard.Base.Error.Common.Index_Out_Of_Bounds
import Standard.Base.Error.Common.Type_Error
import Standard.Base.Error.Illegal_Argument.Illegal_Argument
import Standard.Base.Error.Incomparable_Values.Incomparable_Values

from Standard.Table import Table, Column, Sort_Column, Column_Selector, Sort_Column_Selector, Aggregate_Column
import Standard.Table.Main as Table_Module
from Standard.Table.Data.Aggregate_Column.Aggregate_Column import all hiding First, Last
from Standard.Table.Data.Storage import Storage
import Standard.Table.Data.Value_Type.Value_Type
from Standard.Table.Errors import Invalid_Output_Column_Names, Duplicate_Output_Column_Names, No_Input_Columns_Selected, Missing_Input_Columns, No_Such_Column, Floating_Point_Grouping, Invalid_Value_Type

import Standard.Visualization

from Standard.Database import Database, SQLite, In_Memory

from Standard.Test import Test, Test_Suite, Problems
import Standard.Test.Extensions

from project.Util import all

type My
    Data x y

    == self that = case that of
        My.Data x1 y1 -> (self.x + self.y) == (x1 + y1)
        _ -> False

    compare_to self that = self.x+self.y . compare_to that.x+that.y

    frobnicate self = case self of
        My.Data x1 y1 -> My.Data y1 x1

spec =
    make_varied_type_table =
        strs = ["strs", ["a", "b", "c", Nothing]]
        ints = ["ints", [Nothing, 1, 2, 4]]
        doubles = ["doubles", [0.0, 1.5, Nothing, 2.0]]
        doubles_and_ints = ["doubles_and_ints", [0, 1.5, Nothing, 2]]
        custom_objects = ["custom_objects", [My.Data 1 2, My.Data 3 4, Nothing, Nothing]]
        dates = ["dates", [Nothing, Date.new 2000, Date.new 2022 8 20, Date.new 1999 1 1]]
        times = ["times", [Time_Of_Day.new 18 00, Time_Of_Day.new 1 2 34, Nothing, Time_Of_Day.new]]
        datetimes = ["datetimes", [Date_Time.new 2000, Date_Time.new 1999 1 2 3 4 5, Nothing, Date_Time.new 2022 8 27 11 22 25]]
        mixed = ["mixed", [1, "a", Nothing, Date.new 2022 8 27]]
        mixed_dates = ["mixed_dates", [Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40]]
        just_nulls = ["just_nulls", [Nothing, Nothing, Nothing, Nothing]]

        Table.new [strs, ints, doubles, doubles_and_ints, custom_objects, dates, times, datetimes, mixed, mixed_dates, just_nulls]
    varied_type_table = make_varied_type_table

    Test.group "Construction" <|
        Test.specify "should allow creating a table from rows" <|
            header = ['foo', 'bar']
            rows = [[1, False], [2, True], [3, False]]
            r = Table.from_rows header rows
            r.row_count.should_equal 3
            r.at "foo" . to_vector . should_equal [1, 2, 3]
            r.at "bar" . to_vector . should_equal [False, True, False]

            r2 = Table.from_rows header []
            r2.row_count . should_equal 0
            r2.at "foo" . to_vector . should_equal []
            r2.at "bar" . to_vector . should_equal []

        Test.specify "should allow creating a table from columns" <|
            r = Table.new [["foo", [1, 2, 3]], ["bar", [False, True, False]]]
            r.row_count.should_equal 3
            r.at "foo" . to_vector . should_equal [1, 2, 3]
            r.at "bar" . to_vector . should_equal [False, True, False]

            r2 = Table.new [["foo", []], ["bar", []]]
            r2.row_count . should_equal 0
            r2.at "foo" . to_vector . should_equal []
            r2.at "bar" . to_vector . should_equal []

        Test.specify "should handle error scenarios gracefully" <|
            Table.new [["X", [1,2,3]], ["Y", [4]]] . should_fail_with Illegal_Argument.Error
            Table.new [["X", [1]], ["X", [2]]] . should_fail_with Illegal_Argument.Error
            Table.new [] . should_fail_with Illegal_Argument.Error

            Table.from_rows ["X", "X"] [] . should_fail_with Illegal_Argument.Error
            Table.from_rows ["X", "Y"] [[1,2], [1]] . should_fail_with Index_Out_Of_Bounds.Error
            Table.from_rows [] [] . should_fail_with Illegal_Argument.Error
            Table.from_rows [] [[]] . should_fail_with Illegal_Argument.Error

        Test.specify "should correctly infer storage types" <|
            varied_type_table.at "strs" . storage_type . should_equal Storage.Text
            varied_type_table.at "ints" . storage_type . should_equal Storage.Integer
            varied_type_table.at "doubles" . storage_type . should_equal Storage.Decimal
            varied_type_table.at "doubles_and_ints" . storage_type . should_equal Storage.Decimal
            varied_type_table.at "custom_objects" . storage_type . should_equal Storage.Any
            varied_type_table.at "dates" . storage_type . should_equal Storage.Date
            varied_type_table.at "times" . storage_type . should_equal Storage.Time_Of_Day
            varied_type_table.at "datetimes" . storage_type . should_equal Storage.Date_Time
            varied_type_table.at "mixed" . storage_type . should_equal Storage.Any
            varied_type_table.at "mixed_dates" . storage_type . should_equal Storage.Any
            varied_type_table.at "just_nulls" . storage_type . should_equal Storage.Any

        pending_python_missing = if Polyglot.is_language_installed "python" . not then
            "Can't run Python tests, Python is not installed."
        Test.specify "should also work with polyglot values coming from Python" pending=pending_python_missing <|
            enso_dates = ["enso_dates", [Date.new 2022 8 27, Date.new 1999 1 1]]
            py_dates = ["py_dates", [py_make_date 2022 8 27, py_make_date 1999 1 1]]
            py_objects = ["py_objects", [py_make_object "a" "b", py_make_object "foo" "bar"]]
            table = Table.new [enso_dates, py_dates, py_objects]
            table.info.at "Column" . to_vector . should_equal ["enso_dates", "py_dates", "py_objects"]
            table.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Date, Storage.Any]

            (table.at "enso_dates" == table.at "py_dates").to_vector . should_equal [True, True]

        Test.specify "should also work with polyglot values coming from JS" <|
            enso_dates = ["enso_dates", [Date.new 2022 8 27, Date.new 1999 1 1]]
            js_dates = ["js_dates", [js_make_date 2022 8 27, js_make_date 1999 1 1]]
            js_objects = ["js_objects", [js_make_object "a" "b", js_make_object "foo" "bar"]]
            table = Table.new [enso_dates, js_dates, js_objects]
            table.info.at "Column" . to_vector . should_equal ["enso_dates", "js_dates", "js_objects"]
            table.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Date_Time, Storage.Any]

            enso_date_times = table.at "enso_dates" . map .to_date_time
            enso_date_times.storage_type . should_equal Storage.Date_Time
            js_converted_dates = table.at "js_dates" . map .date
            js_converted_dates.storage_type . should_equal Storage.Date
            (js_converted_dates == table.at "enso_dates").to_vector . should_equal [True, True]
            (enso_date_times == table.at "js_dates").to_vector . should_equal [True, True]

        Test.specify "should handle Unicode normalization when accessing table columns" <|
            col1 = ['s\u0301ciana', [1, 2, 3]]
            col2 = ['café', [4, 5, 6]]
            t = Table.new [col1, col2]
            t.at 'ściana' . to_vector . should_equal [1, 2, 3]
            t.at 's\u0301ciana' . to_vector . should_equal [1, 2, 3]
            t.at 'cafe\u0301' . to_vector . should_equal [4, 5, 6]
            t.at 'café' . to_vector . should_equal [4, 5, 6]
            t.at 'sciana' . should_fail_with No_Such_Column.Error

    Test.group "Vector conversion" <|
        Test.specify "should allow converting columns to valid vectors" <|
            col_1 = Column.from_vector 'x' [1, 2, 3]
            col_1.to_vector.reduce (+) . should_equal 6

            col_2 = Column.from_vector 'y' [My.Data 1 2, My.Data 2 3]
            col_2.to_vector.map (my -> my.x + my.y) . should_equal [3, 5]

            col_3 = Column.from_vector 'z' [False, True, False]
            col_3.to_vector.map .not . should_equal [True, False, True]

    Test.group "Mapping Operations" <|
        Test.specify "should allow mapping a function over a column" <|
            c_str = Column.from_vector 'x' ['a', 'b', Nothing, 'b']
            c_str.map (+ "x") . to_vector . should_equal ['ax', 'bx', Nothing, 'bx']
            c_int = Column.from_vector 'x' [1, 2, 1, 5, 1]
            c_int.map (+ 1) . to_vector . should_equal [2, 3, 2, 6, 2]
            c_dec = Column.from_vector 'x' [1.9, 2.0, 1.2, 5.6, 1.9]
            c_dec.map (+ 1.5) . to_vector . should_equal [3.4, 3.5, 2.7, 7.1, 3.4]
            c_bool = Column.from_vector 'x' [True, False, Nothing, True, False]
            c_bool.map (_.to_text) . to_vector . should_equal ["True", "False", Nothing, "True", "False"]
            c_any = Column.from_vector 'x' [My.Data 1 6, My.Data 6 3, My.Data 2 5, My.Data 3 4, My.Data 200 300]
            c_any.map (_.frobnicate) . to_vector . should_equal [My.Data 6 1, My.Data 3 6, My.Data 5 2, My.Data 4 3, My.Data 300 200]

        Test.specify "should correctly handle storage of results" <|
            c_int = Column.from_vector 'year' [2022, 2000, 1999]
            r = c_int . map Date_Time.new
            r.to_vector . should_equal [Date_Time.new 2022, Date_Time.new 2000, Date_Time.new 1999]
            r.storage_type . should_equal Storage.Date_Time

        Test.specify "should allow zipping columns with a custom function" <|
            b = Column.from_vector 'w' [6.3, 3.1, 5.2, 4.6, 8.0]
            a = Column.from_vector 'z' ['foo', 'bar', 'baz', 'spam', 'eggs']
            c = a.zip b x-> y-> x + y.to_text
            c.to_vector.should_equal ['foo6.3', 'bar3.1', 'baz5.2', 'spam4.6', 'eggs8.0']
            c.storage_type . should_equal Storage.Text

            x = Column.from_vector 'a' [1, Nothing, 2, Nothing]
            y = Column.from_vector 'b' [0, 0, 0, 0]
            r = x.zip y skip_missing=False x-> y-> if x == 1 then x else y
            r.to_vector.should_equal [1, 0, 0, 0]
            r.storage_type . should_equal Storage.Integer

            u = Column.from_vector 'u' [12, 13, 0]
            v = Column.from_vector 'v' [0, 30, 45]
            r2 = u.zip v h-> m-> Time_Of_Day.new h m
            r2.to_vector . should_equal [Time_Of_Day.new 12 0, Time_Of_Day.new 13 30, Time_Of_Day.new 0 45]
            r2.storage_type . should_equal Storage.Time_Of_Day

        Test.specify "should handle vectorized equality and fall back on non-vectorized if needed" <|
            c_str = Column.from_vector 'x' ['a', 'b', Nothing, 'b']
            (c_str == 'b').to_vector.should_equal [False, True, Nothing, True]
            c_int = Column.from_vector 'x' [1, 2, 1, 5, 1]
            (c_int == 1).to_vector.should_equal [True, False, True, False, True]
            c_dec = Column.from_vector 'x' [1.9, 2.0, 1.2, 5.6, 1.9]
            (c_dec == 1.9).to_vector.should_equal [True, False, False, False, True]
            c_bool = Column.from_vector 'x' [True, False, Nothing, True, False]
            (c_bool == False).to_vector.should_equal [False, True, Nothing, False, True]
            c_any = Column.from_vector 'x' [My.Data 1 6, My.Data 6 3, My.Data 2 5, My.Data 3 4, My.Data 200 300]
            (c_any == My.Data 7 0).to_vector.should_equal [True, False, True, True, False]

        Test.specify "should switch between maps and zips based on argument type" <|
            a = Column.from_vector 'x' [0, 1, 7, 3, 6]
            b = Column.from_vector 'w' [6.3, 3.1, 5.2, Nothing, 8]
            (a + 3.2).to_vector.should_equal [3.2, 4.2, 10.2, 6.2, 9.2]
            (a + b).to_vector.should_equal [6.3, 4.1, 12.2, Nothing, 14]
            gt_const = a > 5
            gt_const.to_vector.should_equal [False, False, True, False, True]
            gt_b = a > b
            gt_b.to_vector.should_equal [False, False, True, Nothing, False]
            both = gt_const && gt_b
            both.to_vector.should_equal [False, False, True, Nothing, False]

        Test.specify "should handle Text operations" <|
            a = Column.from_vector 'a' ["abab", "abc", Nothing, "bca", "acca"]
            nils = [Nothing, Nothing, Nothing, Nothing, Nothing]

            a.starts_with "ab" . to_vector . should_equal [True, True, Nothing, False, False]
            b = Column.from_vector 'b' ["ba", "ab", "d", Nothing, "ac"]
            a.starts_with b . to_vector . should_equal [False, True, Nothing, Nothing, True]
            a.starts_with Nothing . to_vector . should_equal nils

            a.ends_with "ca" . to_vector . should_equal [False, False, Nothing, True, True]
            c = Column.from_vector 'c' ["ab", "b", "d", Nothing, "cc"]
            a.ends_with c . to_vector . should_equal [True, False, Nothing, Nothing, False]
            a.ends_with Nothing . to_vector . should_equal nils

            a.contains "c" . to_vector . should_equal [False, True, Nothing, True, True]
            a.contains c . to_vector . should_equal [True, True, Nothing, Nothing, True]
            a.contains Nothing . to_vector . should_equal nils

        Test.specify "should take Unicode normalization into account in Text operations" <|
            x = Column.from_vector 'x' ['s', 'ś', 's\u0301']
            y = Column.from_vector 'y' ['s\u0301', 's\u0301', 'ś']

            x=='s' . to_vector . should_equal [True, False, False]
            x=='ś' . to_vector . should_equal [False, True, True]
            x=='s\u0301' . to_vector . should_equal [False, True, True]
            x=='ą' . to_vector . should_equal [False, False, False]
            x==y . to_vector . should_equal [False, True, True]

            z = Column.from_vector 'z' ['śląsk', 's\u0301ciana', 'sanok', 'rzeczywistość', 'ostros\u0301c\u0301']
            z.starts_with 's' . to_vector . should_equal [False, False, True, False, False]
            z.starts_with 'ś' . to_vector . should_equal [True, True, False, False, False]
            z.starts_with 's\u0301' . to_vector . should_equal [True, True, False, False, False]
            z.starts_with 'ą' . to_vector . should_equal [False, False, False, False, False]
            z.ends_with 'ść' . to_vector . should_equal [False, False, False, True, True]
            z.ends_with 's\u0301c\u0301' . to_vector . should_equal [False, False, False, True, True]
            z.ends_with 'ok' . to_vector . should_equal [False, False, True, False, False]
            z.contains 's' . to_vector . should_equal [True, False, True, True, True]
            z.contains 'ś' . to_vector . should_equal [True, True, False, True, True]
            z.contains 's\u0301' . to_vector . should_equal [True, True, False, True, True]

    Test.group "Masking Tables" <|
        Test.specify "should allow selecting table rows based on a boolean column" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [True, False, False, True])
            r.at "a" . to_vector . should_equal ["1", "10"]
            r.at "b" . to_vector . should_equal [2, 11]
            r.at "c" . to_vector . should_equal [Nothing, 12]
        Test.specify "should treat NA values in the mask as false and extend the mask with NAs" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [Nothing, True, False])
            r.at "a" . to_vector . should_equal ["4"]
            r.at "b" . to_vector . should_equal [Nothing]
            r.at "c" . to_vector . should_equal [6]
        Test.specify "should work correctly if a mask is bigger than the table itself" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [True, False, False, False, True])
            r.at "a" . to_vector . should_equal ["1"]
            r.at "b" . to_vector . should_equal [2]
            r.at "c" . to_vector . should_equal [Nothing]

    Test.group "Filling Missing Values" <|
        Test.specify "should coerce non-coercible types to Object" <|
            strs = Column.from_vector 'x' ["a", Nothing, "b", Nothing]
            strs_filled = strs.fill_missing False
            strs_filled.to_vector . should_equal ["a", False, "b", False]
            strs_filled.storage_type . should_equal Storage.Any

            ints = Column.from_vector 'x' [1, Nothing, 2, Nothing]
            ints_filled = ints.fill_missing "X"
            ints_filled.to_vector . should_equal [1, "X", 2, "X"]
            ints_filled.storage_type . should_equal Storage.Any

            bools = Column.from_vector 'x' [True, False, Nothing]
            bools_filled = bools.fill_missing "X"
            bools_filled.to_vector . should_equal [True, False, "X"]
            bools_filled.storage_type . should_equal Storage.Any

        Test.specify "should coerce long and double types to double" <|
            ints = Column.from_vector 'x' [1, Nothing, 2, Nothing]
            ints_filled = ints.fill_missing 0.5
            ints_filled.to_vector . should_equal [1.0, 0.5, 2.0, 0.5]
            ints_filled.storage_type . should_equal Storage.Decimal

            decimals = Column.from_vector 'x' [0.5, Nothing, Nothing, 0.25]
            decimals_filled = decimals.fill_missing 42
            decimals_filled.to_vector . should_equal [0.5, 42.0, 42.0, 0.25]
            decimals_filled.storage_type . should_equal Storage.Decimal

        Test.specify "should keep String, Boolean, Long and Double type" <|
            strs = Column.from_vector 'x' ["a", Nothing, "b", Nothing]
            strs_filled = strs.fill_missing "X"
            strs_filled.to_vector . should_equal ["a", "X", "b", "X"]
            strs_filled.storage_type . should_equal Storage.Text

            bools = Column.from_vector 'x' [True, False, Nothing]
            bools_filled = bools.fill_missing False
            bools_filled.to_vector . should_equal [True, False, False]
            bools_filled.storage_type . should_equal Storage.Boolean

            ints = Column.from_vector 'x' [1, Nothing, 2, Nothing]
            ints_filled = ints.fill_missing 42
            ints_filled.to_vector . should_equal [1, 42, 2, 42]
            ints_filled.storage_type . should_equal Storage.Integer

            decimals = Column.from_vector 'x' [0.5, Nothing, Nothing, 0.25]
            decimals_filled = decimals.fill_missing 1.0
            decimals_filled.to_vector . should_equal [0.5, 1.0, 1.0, 0.25]
            decimals_filled.storage_type . should_equal Storage.Decimal

    Test.group "Counting Values" <|
        Test.specify "should count missing and non-missing values" <|
            col = Column.from_vector 'x' [1, Nothing, 2]
            col.length . should_equal 3
            col.count . should_equal 2
            col.count_missing . should_equal 1

    Test.group "Dropping Missing Values" <|
        Test.specify "should correctly handle NaNs with mixed type columns" <|
            t = Table.new [["X", [1, 2, 3, 4, 5]], ["Y", ["A", "", Nothing, Number.nan, 0]]]
            t1 = t.filter_blank_rows when_any=True treat_nans_as_blank=False
            t1.at "X" . to_vector . should_equal [1, 4, 5]
            # Comparing text value because `Number.nan != Number.nan`.
            t1.at "Y" . to_vector . to_text . should_equal "[A, NaN, 0]"
            t2 = t.filter_blank_rows when_any=True treat_nans_as_blank=True
            t2.at "X" . to_vector . should_equal [1, 5]
            t2.at "Y" . to_vector . should_equal ['A', 0]

            t3 = Table.new [["X", [1, 2, 3]], ["Y", ["", Nothing, Number.nan]]]
            t4 = t3.remove_columns (Column_Selector.Blank_Columns treat_nans_as_blank=True)
            t4.columns . map .name . should_equal ["X"]

        Test.specify "Blank_Columns selector should work for all kinds of methods accepting Column_Selector" <|
            t = Table.new [["X", [1, 2, 3, 4, 5]], ["Y", ["", Nothing, Nothing, Number.nan, ""]]]
            r1 = t.distinct (Column_Selector.Blank_Columns treat_nans_as_blank=True)
            r1.at "Y" . to_vector . to_text . should_equal "[, Nothing, NaN]"
            r1.at "X" . to_vector . should_equal [1, 2, 4]

            # TODO this could be moved to Common_Table_Operations once replace_text is implemented for Database too
            t2 = Table.new [["X", [1, 2, 3, 4, 5]], ["Y", ["", Nothing, Nothing, Nothing, ""]], ["Z", ["", "---", "-1", "", "foobar"]]]
            r2 = t2.replace_text (Column_Selector.Blank_Columns when_any=True) "-" "A"
            r2.at "X" . to_vector . should_equal [1, 2, 3, 4, 5]
            r2.at "Y" . to_vector . should_equal ["", Nothing, Nothing, Nothing, ""]
            r2.at "Z" . to_vector . should_equal ["", "AAA", "A1", "", "foobar"]

    Test.group "Info" <|
        Test.specify "should return Table information" <|
            a = ["strs", ["a", "b", Nothing, "a"]]
            b = ["ints", [1, 2, Nothing, Nothing]]
            c = ["objs", [1, "a", "c", Any]]
            r = Table.new [a, b, c]
            i = r.info
            i.at "Column" . to_vector . should_equal ["strs", "ints", "objs"]
            i.at "Items Count" . to_vector . should_equal [3, 2, 4]
            i.at "Storage Type" . to_vector . should_equal [Storage.Text, Storage.Integer, Storage.Any]

    Test.group "Sorting Tables" <|
        Test.specify 'should respect defined comparison operations for custom types' <|
            c_1 = ['id', [1, 2, 3, 4, 5, 6]]
            c_2 = ['val', [My.Data 1 2, My.Data 3 4, My.Data 2 1, My.Data 5 2, My.Data 7 0, My.Data 4 -1]]
            df = Table.new [c_1, c_2]
            r = df.order_by (Sort_Column_Selector.By_Name ['val'])
            r.at 'id' . to_vector . should_equal [1,3,6,2,4,5]

        Test.specify 'should correctly reorder all kinds of columns and leave the original columns untouched' <|
            ord = [0, 3, 2, 4, 1]
            ints = [1, 2, 3, 4, 5]
            reals = [1.3, 4.6, 3.2, 5.2, 1.6]
            bools = [False, False, True, True, False]
            texts = ["foo", "foo", "bar", "baz", "spam"]
            dates = [Date.new 2020, Date.new 1999, Date.new 2000 10 3, Date.new 1999 12 31, Date.new 2000 2 7]
            times = [Time_Of_Day.new 12, Time_Of_Day.new 1 30 40, Time_Of_Day.new 23 59 59, Time_Of_Day.new 12 30 0, Time_Of_Day.new 10 20 30]
            datetimes = [Date_Time.new 2020 1 1 12, Date_Time.new 1999 1 1 1 30 40, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 1999 12 31 12 30 0, Date_Time.new 2000 10 3 10 20 30]
            objs = [My.Data 100 2, My.Data 2 3, My.Data 6 7, My.Data 8 9, My.Data 10 30]
            mixed_dates = [Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 2000]

            df = Table.new [['ord', ord], ['ints', ints], ['reals', reals], ['bools', bools], ['texts', texts], ['objs', objs], ['dates', dates], ['times', times], ['datetimes', datetimes], ['mixed_dates', mixed_dates]]
            r = df.order_by (Sort_Column_Selector.By_Name ['ord'])

            r.at 'ints' . to_vector . should_equal [1, 5, 3, 2, 4]
            df.at 'ints' . to_vector . should_equal ints

            r.at 'reals' . to_vector . should_equal [1.3, 1.6, 3.2, 4.6, 5.2]
            df.at 'reals' . to_vector . should_equal reals

            r.at 'bools' . to_vector . should_equal [False, False, True, False, True]
            df.at 'bools' . to_vector . should_equal bools

            r.at 'texts' . to_vector . should_equal ['foo', 'spam', 'bar', 'foo', 'baz']
            df.at 'texts' . to_vector . should_equal texts

            r.at 'objs' . to_vector . should_equal [My.Data 100 2, My.Data 10 30, My.Data 6 7, My.Data 2 3, My.Data 8 9]
            df.at 'objs' . to_vector . should_equal objs

            r.at 'dates' . to_vector . should_equal [Date.new 2020, Date.new 2000 2 7, Date.new 2000 10 3, Date.new 1999, Date.new 1999 12 31]
            df.at 'dates' . to_vector . should_equal dates

            r.at 'times' . to_vector . should_equal [Time_Of_Day.new 12, Time_Of_Day.new 10 20 30, Time_Of_Day.new 23 59 59, Time_Of_Day.new 1 30 40, Time_Of_Day.new 12 30 0]
            df.at 'times' . to_vector . should_equal times

            r.at 'datetimes' . to_vector . should_equal [Date_Time.new 2020 1 1 12, Date_Time.new 2000 10 3 10 20 30, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 1999 1 1 1 30 40, Date_Time.new 1999 12 31 12 30 0]
            df.at 'datetimes' . to_vector . should_equal datetimes

            # TODO move this test to Common_Table_Operations once we support dates there
            r2 = df.order_by (Sort_Column_Selector.By_Name ['dates'])
            r2.at 'dates' . to_vector . should_equal [Date.new 1999, Date.new 1999 12 31, Date.new 2000 2 7, Date.new 2000 10 3, Date.new 2020]
            r2.at 'ints' . to_vector . should_equal [2, 4, 5, 3, 1]

            r3 = df.order_by (Sort_Column_Selector.By_Name ['times'])
            r3.at 'times' . to_vector . should_equal [Time_Of_Day.new 1 30 40, Time_Of_Day.new 10 20 30, Time_Of_Day.new 12, Time_Of_Day.new 12 30 0, Time_Of_Day.new 23 59 59]
            r3.at 'ints' . to_vector . should_equal [2, 5, 1, 4, 3]

            r4 = df.order_by (Sort_Column_Selector.By_Name ['datetimes'])
            r4.at 'datetimes' . to_vector . should_equal [Date_Time.new 1999 1 1 1 30 40, Date_Time.new 1999 12 31 12 30 0, Date_Time.new 2000 10 3 10 20 30, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 2020 1 1 12]
            r4.at 'ints' . to_vector . should_equal [2, 4, 5, 3, 1]

            r5 = df.order_by (Sort_Column_Selector.By_Name ['objs'])
            r5.at 'objs' . to_vector . should_equal [My.Data 2 3, My.Data 6 7, My.Data 8 9, My.Data 10 30, My.Data 100 2]
            r5.at 'ints' . to_vector . should_equal [2, 3, 4, 5, 1]

            r6 = df.order_by (Sort_Column_Selector.By_Name ['mixed_dates'])
            r6 . should_fail_with Incomparable_Values

    Test.group "Sorting Columns" <|
        Test.specify 'should sort columns with specified ordering and missing placement' <|
            c = Column.from_vector 'foo' [1, 7, Nothing, 4, 8, Nothing]

            r_1 = c.sort
            r_1.to_vector.should_equal [1,4,7,8,Nothing,Nothing]

            r_2 = c.sort Sort_Direction.Descending
            r_2.to_vector.should_equal [8,7,4,1,Nothing,Nothing]

            r_3 = c.sort Sort_Direction.Descending missing_last=False
            r_3.to_vector.should_equal [Nothing,Nothing,8,7,4,1]

        Test.specify 'should respect defined comparison operations for custom types' <|
            c = Column.from_vector 'foo'  [My.Data 1 2, My.Data 3 4, My.Data 2 1, My.Data 5 2, My.Data 7 0, My.Data 4 -1]
            r = c.sort
            r.to_vector.should_equal [My.Data 1 2, My.Data 2 1, My.Data 4 -1, My.Data 3 4, My.Data 5 2, My.Data 7 0]

        Test.specify 'should allow passing a custom comparator' <|
            c = Column.from_vector 'foo' [My.Data 1 2, My.Data 2 5, My.Data 3 4, My.Data 6 3, Nothing, My.Data 1 0]
            cmp a b = (a.x-a.y).abs . compare_to (b.x-b.y).abs
            r = c.sort by=cmp
            r.to_vector.should_equal [My.Data 1 2, My.Data 3 4, My.Data 1 0, My.Data 2 5, My.Data 6 3, Nothing]

        Test.specify 'should handle Unicode characters correctly' <|
            c = Column.from_vector 'c' ['z', 'a', 'd', 'f', 's', 'e\u0301', 'ś', 'ą', 's\u0301', 'w', 'b']
            c.sort.to_vector . should_equal ['a', 'ą', 'b', 'd', 'e\u0301', 'f', 's', 's\u0301', 'ś', 'w', 'z']

    Test.group "Slicing Tables" <|
        Test.specify 'should allow taking first n rows' <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3]

            t_1.take (First 10) . at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector)
            t_1.take 10 . at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector)

            t_2 = t_1.take (First 2)
            t_2.at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector . take (First 2))
            t_2.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take (First 2))
            t_2.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take (First 2))

            t_3 = t_1.take 2
            t_3.at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector . take 2)
            t_3.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take 2)
            t_3.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take 2)

            t_1.at 'col' . take (First 2) . to_vector . should_equal (t_1.at 'col' . to_vector . take (First 2))
            t_1.at 'col' . take 2 . to_vector . should_equal (t_1.at 'col' . to_vector . take 2)

        Test.specify "should allow taking the last n rows" <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col1', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3]

            t_1.take (Last 10) . at 'col1' . to_vector . should_equal (t_1.at 'col1' . to_vector)

            t_2 = t_1.take (Last 2)
            t_2.at 'col1' . to_vector . should_equal (t_1.at 'col1' . to_vector . take (Last 2))
            t_2.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take (Last 2))
            t_2.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take (Last 2))

            t_1.at 'col1' . take (Last 2) . to_vector . should_equal (t_1.at 'col1' . to_vector . take (Last 2))

        Test.specify "should allow taking/dropping a prefix of rows that satisfy a predicate" <|
            t1 = Table.new [["X", [1, 2, 3, 4, 5, 5]], ["Y", [9, 8, 7, 2, 10, 5]]]

            t2 = t1.take (Index_Sub_Range.While row-> row.to_vector.compute Statistic.Sum == 10)
            t2.at "X" . to_vector . should_equal [1, 2, 3]
            t2.at "Y" . to_vector . should_equal [9, 8, 7]

            t3 = t1.drop (Index_Sub_Range.While row-> row.to_vector.compute Statistic.Sum == 10)
            t3.at "X" . to_vector . should_equal [4, 5, 5]
            t3.at "Y" . to_vector . should_equal [2, 10, 5]

            t4 = t1.take (Index_Sub_Range.While row-> row.at "X" < 3)
            t4.at "X" . to_vector . should_equal [1, 2]
            t4.at "Y" . to_vector . should_equal [9, 8]

            t5 = t1.drop (Index_Sub_Range.While row-> row.at 1 > 3)
            t5.at "X" . to_vector . should_equal [4, 5, 5]
            t5.at "Y" . to_vector . should_equal [2, 10, 5]

            t6 = t1.take (Index_Sub_Range.While row-> row.at "X" > 1)
            t6.at "X" . to_vector . should_equal []
            t6.at "Y" . to_vector . should_equal []

        Test.specify "should allow reversing the table" <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col1', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3]

            expected_i_1 = ['ix', [3, 2, 1]]
            expected_c_1 = ['col1', [7, 6, 5]]
            expected_c_2 = ['col2', ["c", Nothing, "a"]]
            expected_c_3 = ['col3', [Nothing, True, False]]
            expected = Table.new [expected_i_1, expected_c_1, expected_c_2, expected_c_3]

            t_2 = t_1.reverse

            t_2.at 'col1' . to_vector . should_equal (expected.at 'col1' . to_vector)
            t_2.at 'col2' . to_vector . should_equal (expected.at 'col2' . to_vector)
            t_2.at 'col3' . to_vector . should_equal (expected.at 'col3' . to_vector)

    Test.group "Use First Row As Names" <|
        expect_column_names names table =
            table.columns . map .name . should_equal names frames_to_skip=2

        Test.specify "should work happily with mixed types" <|
            c_0 = ['A', ["H", "B", "C"]]
            c_1 = ['B', [Date.new 1980, Date.new 1979, Date.new 2000]]
            c_2 = ['x', [1, 2, 3]]
            c_3 = ['Y', [5.3, 56.2, 6.3]]
            c_4 = ['Z', [True, False, True]]
            table = Table.new [c_0, c_1, c_2, c_3, c_4]
            expect_column_names ["H", "1980-01-01", "1", "5.3", "True"] <| table.use_first_row_as_names

        Test.specify "should correctly handle problems: invalid names ''" <|
            c_0 = ['A', ["", "B", "C"]]
            c_2 = ['x', [1, 2, 3]]
            table = Table.new [c_0, c_2]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["Column_1", "1"]
            problems = [Invalid_Output_Column_Names.Error [""]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names Nothing" <|
            c_0 = ['A', ["A", "B", "C"]]
            c_2 = ['x', [Nothing, 2, 3]]
            table = Table.new [c_0, c_2]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["A", "Column_1"]
            problems = [Invalid_Output_Column_Names.Error [Nothing]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            c_0 = ['A', ["A", "B", "C"]]
            c_1 = ['B', ["A", "B", "C"]]
            c_2 = ['x', ["A", "B", "C"]]
            c_3 = ['C', ["A", "B", "C"]]
            table = Table.new [c_0, c_1, c_2, c_3]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["A", "A_1", "A_2", "A_3"]
            problems = [Duplicate_Output_Column_Names.Error ["A", "A", "A"]]
            Problems.test_problem_handling action problems tester

    Test.group "Table.replace_text" <|
        Test.specify "should replace text in full-text table columns" <|
            bools = ["bools", [False, False, True, True, False]]
            texts = ["texts", ["foo", "foo", "bar", "baz", "spam"]]
            table = Table.new [bools, texts]
            actual = table.replace_text "texts" "a" "o"
            actual.at "bools" . to_vector . should_equal [False, False, True, True, False]
            actual.at "texts" . to_vector . should_equal ["foo", "foo", "bor", "boz", "spom"]
            Problems.assume_no_problems actual

        Test.specify "should replace text in mixed columns" <|
            bools = ["bools", [False, False, True, True, False]]
            mixed = ["mixed", ["foo", 5, "bar", False, "spam"]]
            table = Table.new [bools, mixed]
            actual = table.replace_text "mixed" "a" "o"
            actual.at "bools" . to_vector . should_equal [False, False, True, True, False]
            actual.at "mixed" . to_vector . should_equal ["foo", 5, "bor", False, "spom"]
            Problems.assume_no_problems actual

        Test.specify "should support operating on multiple columns at once" <|
            bools = ["bools", [False, False, True]]
            texts1 = ["texts1", ["foo", "bar", "baz"]]
            texts2 = ["texts2", ["baz", "quux", "spam"]]
            table = Table.new [bools, texts1, texts2]
            actual = table.replace_text (Column_Selector.By_Name ["texts1", "texts2"]) "a" "o"
            actual.at "bools"  . to_vector . should_equal [False, False, True]
            actual.at "texts1" . to_vector . should_equal ["foo", "bor", "boz"]
            actual.at "texts2" . to_vector . should_equal ["boz", "quux", "spom"]
            Problems.assume_no_problems actual

        Test.specify "should support regex replacement" <|
            bools = ["bools", [False, False, True, True]]
            texts = ["texts", ["foo", "bar", "baz", "spam"]]
            table = Table.new [bools, texts]
            actual = table.replace_text "texts" "(a|o)" "$1e" matcher=Regex_Matcher.Value
            actual.at "texts" . to_vector . should_equal ["foeoe", "baer", "baez", "spaem"]
            Problems.assume_no_problems actual

        Test.specify 'should return warnings and errors when passed a non-existent column' <|
            table = Table.new [["bools", [False, True]], ["texts", ["foo", "bar"]]]
            action = table.replace_text "invalid_name" "a" "b" on_problems=_
            tester = _.should_equal table
            problems = [Missing_Input_Columns.Error ['invalid_name']]
            Problems.test_problem_handling action problems tester

        Test.specify "should return warnings and errors when selected non-text column" <|
            table = Table.new [["bools", [False, True]], ["texts", ["foo", "bar"]]]
            action = table.replace_text "bools" "a" "b" on_problems=_
            tester = _.should_equal table
            problems = [Invalid_Value_Type.Error Value_Type.Char Value_Type.Boolean]
            Problems.test_problem_handling action problems tester

    Test.group "[In-Memory] Table.aggregate" <|
        Test.specify "should return columns with correct types" <|
            dates = ["dates", [Date.new 1999, Date.new 2000, Date.new 2000, Date.new 2000]]
            texts = ["texts", ["a", "bb", "a", "bb"]]
            mixed = ["mixed", [1, "a", "a", 1]]
            ints = ["ints", [0, 1, 1, 0]]
            floats = ["floats", [0.1, 1.0, 2.0, 1.5]]
            objects = ["objects", [My.Data 0 1, My.Data 0 1, My.Data 2 2, My.Data 2 2]]
            table = Table.new [dates, texts, mixed, ints, floats, objects]

            t1 = table.aggregate [Group_By "dates", Shortest "texts", Aggregate_Column.First "texts", Aggregate_Column.First "objects", Aggregate_Column.First "ints", Aggregate_Column.Last "mixed"]
            t1.info.at "Column" . to_vector . should_equal ["dates", "Shortest texts", "First texts", "First objects", "First ints", "Last mixed"]
            t1.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Text, Storage.Text, Storage.Any, Storage.Integer, Storage.Any]

            t2 = table.aggregate [Mode "dates", Count_Not_Nothing "objects", Count_Distinct "texts", Minimum "ints", Maximum "floats"]
            t2.info.at "Column" . to_vector . should_equal ["Mode dates", "Count Not Nothing objects", "Count Distinct texts", "Minimum ints", "Maximum floats"]
            t2.info.at "Storage Type" . to_vector . should_equal [Storage.Date, Storage.Integer, Storage.Integer, Storage.Integer, Storage.Decimal]

            t3 = table.aggregate [Group_By "texts", Group_By "ints", Aggregate_Column.Last "floats"]
            t3.info.at "Column" . to_vector . should_equal ["texts", "ints", "Last floats"]
            t3.info.at "Storage Type" . to_vector . should_equal [Storage.Text, Storage.Integer, Storage.Decimal]

            t4 = table.aggregate [Group_By "mixed", Sum "ints", Sum "floats"]
            t4.info.at "Column" . to_vector . should_equal ["mixed", "Sum ints", "Sum floats"]
            t4.info.at "Storage Type" . to_vector . should_equal [Storage.Any, Storage.Decimal, Storage.Decimal]

        Test.specify "should take Unicode normalization into account when grouping by Text" <|
            texts = ["texts", ['ściana', 'ściana', 'łąka', 's\u0301ciana', 'ła\u0328ka', 'sciana']]
            ints = ["ints", [1, 2, 4, 8, 16, 32]]
            table = Table.new [texts, ints]
            r1 = table.aggregate [Group_By "texts", Sum "ints"] . order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "texts"])
            r1.at "texts" . to_vector . should_equal ['sciana', 'ściana', 'łąka']
            r1.at "Sum ints" . to_vector . should_equal [32, 11, 20]

            r2 = table.aggregate [Count_Distinct "texts"]
            r2.at "Count Distinct texts" . to_vector . should_equal [3]

    ## We have a separate set of tests for In-Memory distinct as it gives us
       more guarantees: preserving order of rows and always selecting the first
       row of ones sharing the same distinctness key. For database tests (to be
       added later) we can not rely on ordering.
    Test.group "[In-Memory] Table.distinct" <|
        Test.specify "should allow to select distinct rows based on a subset of columns, returning the first row from each group" <|
            a = ["A", ["a", "a", "a", "a", "a", "a"]]
            b = ["B", [1, 1, 2, 2, 1, 2]]
            c = ["C", [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]]
            t = Table.new [a, b, c]

            r2 = t.distinct (Column_Selector.By_Name ["A", "B"]) on_problems=Report_Error
            r2.at "A" . to_vector . should_equal ["a", "a"]
            r2.at "B" . to_vector . should_equal [1, 2]
            r2.at "C" . to_vector . should_equal [0.1, 0.3]

        Test.specify "should handle nulls correctly and preserve original ordering" <|
            a = ["A", ["a", Nothing, "b", "a", "b", Nothing, "a", "b"]]
            b = ["B", [1, 2, 3, 4, 5, 6, 7, 8]]
            t = Table.new [a, b]
            r = t.distinct (Column_Selector.By_Name ["A"]) on_problems=Report_Error
            r.at "A" . to_vector . should_equal ["a", Nothing, "b"]
            r.at "B" . to_vector . should_equal [1, 2, 3]

        Test.specify "should handle Unicode normalization of keys correctly" <|
            t1 = Table.new [["X", ['ś', 's\u0301', 's', 'ś']]]
            t1.distinct . at "X" . to_vector . should_equal ['ś', 's']

        Test.specify "should allow to control case-sensitivity of keys, correctly handling Unicode folding" <|
            x = ["X", ['A', 'a', 'enso', 'śledź', 'Enso', 'A', 's\u0301ledz\u0301']]
            y = ["Y", [1, 2, 3, 4, 5, 6, 7]]
            t1 = Table.new [x, y]
            d1 = t1.distinct (Column_Selector.By_Name ["X"]) on_problems=Report_Error
            d1.at "X" . to_vector . should_equal ['A', 'a', 'enso', 'śledź', 'Enso']
            d1.at "Y" . to_vector . should_equal [1, 2, 3, 4, 5]

            d2 = t1.distinct (Column_Selector.By_Name ["X"]) case_sensitivity=Case_Sensitivity.Insensitive on_problems=Report_Error
            d2.at "X" . to_vector . should_equal ['A', 'enso', 'śledź']
            d2.at "Y" . to_vector . should_equal [1, 3, 4]

            t2 = Table.new [["X", ["łąka", "STRASSE", "Straße", "ﬃ", "ŁĄka", "ffi"]]]
            t2.distinct case_sensitivity=Case_Sensitivity.Insensitive . at "X" . to_vector . should_equal ["łąka", "STRASSE", "ﬃ"]

        Test.specify "should report a warning if the key contains floating point values" <|
            t1 = Table.new [["X", [3.0, 1.0, 2.0, 2.0, 1.0]]]
            action1 = t1.distinct on_problems=_
            tester1 table =
                table.at "X" . to_vector . should_equal [3.0, 1.0, 2.0]
            problems1 = [Floating_Point_Grouping.Error "X"]
            Problems.test_problem_handling action1 problems1 tester1

            t2 = Table.new [["X", [1.00000000000001, -0.3, 1.00000000000002, 1.5, 1.00000000000002, 1.00000000000002]]]
            action2 = t2.distinct on_problems=_
            tester2 table =
                table.at "X" . to_vector . should_equal [1.00000000000001, -0.3, 1.00000000000002, 1.5]
            problems2 = [Floating_Point_Grouping.Error "X"]
            Problems.test_problem_handling action2 problems2 tester2

        Test.specify "until hashing is supported, should throw an error when trying to aggregate a custom object" <|
            t = Table.new [["X", [My.Data 1 2, My.Data 3 4, My.Data 1 2]]]
            t.distinct . should_fail_with Illegal_Argument.Error

    Test.group "[In-Memory] Table.filter" <|
        Test.specify "by a custom predicate" <|
            t = Table.new [["ix", [1, 2, 3, 4, 5]], ["X", [5, 0, 4, 5, 1]]]
            t1 = t.filter "X" (x -> x % 2 == 0)
            t1.at "ix" . to_vector . should_equal [2, 3]
            t1.at "X" . to_vector . should_equal [0, 4]

            t2 = t.filter 1 (>2)
            t2.at "ix" . to_vector . should_equal [1, 3, 4]
            t2.at "X" . to_vector . should_equal [5, 4, 5]

            t3 = t.filter (t.at "X" + 1) (x -> x % 2 == 0)
            t3.at "ix" . to_vector . should_equal [1, 4, 5]
            t3.at "X" . to_vector . should_equal [5, 5, 1]

        Test.specify "by custom object comparisons" <|
            t = Table.new [["ix", [1, 2, 3, 4, 5]], ["X", [My.Data 1 2, My.Data 300 400, My.Data 100 200, My.Data 5 6, My.Data 7 8]]]
            t1 = t.filter "X" (Filter_Condition.Between (My.Data 10 20) (My.Data 300 400))
            t1.at "ix" . to_vector . should_equal [2, 3]
            t1.at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200]
            t.filter "X" (Filter_Condition.Less than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 1 2]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 1 2, My.Data 5 6]
            t.filter "X" (Filter_Condition.Greater than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200, My.Data 7 8]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200, My.Data 5 6, My.Data 7 8]
            t.filter "X" (Filter_Condition.Equal to=(My.Data 2 1)) . at "X" . to_vector . should_equal [My.Data 1 2]
            t.filter "X" (Filter_Condition.Equal to=42) . at "X" . to_vector . should_equal []

            c = Column.from_vector "Y" [My.Data 2 1, My.Data 400 300, My.Data 101 202, My.Data 10 10, My.Data 15 0]
            t.filter "X" (Filter_Condition.Equal to=c) . at "X" . to_vector . should_equal [My.Data 1 2, My.Data 300 400, My.Data 7 8]
            t.filter "X" (Filter_Condition.Less than=c) . at "X" . to_vector . should_equal [My.Data 100 200, My.Data 5 6]
            t.filter "X" (Filter_Condition.Greater than=c) . at "X" . to_vector . should_equal []

        Test.specify "by a boolean mask of varying length" <|
            t = Table.new [["A", [1, 2, 3]], ["B", [4, 5, 6]]]

            t1 = t.filter (Column.from_vector "f" [False, True])
            t1.at "A" . to_vector . should_equal [2]
            t1.at "B" . to_vector . should_equal [5]

            t2 = t.filter (Column.from_vector "f" [False, True, True, True, True, True, True, True])
            t2.at "A" . to_vector . should_equal [2, 3]
            t2.at "B" . to_vector . should_equal [5, 6]

        Test.specify "by an Is_In check, on various types of columns" <|
            ins = Table.new <|
                str = ["str", ["c", "b", Nothing, Nothing]]
                int = ["int", [1, 2, 3, 3]]
                int2 = ["int2", [1, Nothing, Nothing, 1]]
                dbl = ["dbl", [0.0, 0.0, Nothing, Nothing]]
                dates = ["dates", [Date.new 2000, Date.new 1999 1 1, Date.new 1999 1 1, Date_Time.new 2022 8 20]]
                dts = ["dts", [Date_Time.new 2022 8 27 11 22 25, Nothing, Date_Time.new 2030, Date.new 2000]]
                tod = ["tod", [Time_Of_Day.new 18 00, Time_Of_Day.new 18 19, Date_Time.new 2000 1 1, Time_Of_Day.new 18 19]]
                mix = ["mix", [42, Date_Time.new 2022 8 27, 1, 1]]
                nulls = ["nulls", [Nothing, Nothing, Nothing, 0]]
                custom = ["custom", [2, My.Data 2 1, Nothing, Nothing]]
                [str, int, int2, dbl, dates, dts, tod, mix, nulls, custom]
            varied_type_table.filter "strs" (Filter_Condition.Is_In (ins.at "str")) . at "strs" . to_vector . should_equal ["b", "c", Nothing]
            varied_type_table.filter "strs" (Filter_Condition.Is_In (ins.at "str" . to_vector)) . at "strs" . to_vector . should_equal ["b", "c", Nothing]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int")) . at "ints" . to_vector . should_equal [1, 2]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int" . to_vector)) . at "ints" . to_vector . should_equal [1, 2]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int2")) . at "ints" . to_vector . should_equal [Nothing, 1]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int2" . to_vector)) . at "ints" . to_vector . should_equal [Nothing, 1]
            varied_type_table.filter "doubles" (Filter_Condition.Is_In (ins.at "dbl")) . at "doubles" . to_vector . should_equal [0.0, Nothing]
            varied_type_table.filter "doubles" (Filter_Condition.Is_In (ins.at "dbl" . to_vector)) . at "doubles" . to_vector . should_equal [0.0, Nothing]
            varied_type_table.filter "dates" (Filter_Condition.Is_In (ins.at "dates")) . at "dates" . to_vector . should_equal [Date.new 2000, Date.new 1999 1 1]
            varied_type_table.filter "dates" (Filter_Condition.Is_In (ins.at "dates" . to_vector)) . at "dates" . to_vector . should_equal [Date.new 2000, Date.new 1999 1 1]
            varied_type_table.filter "datetimes" (Filter_Condition.Is_In (ins.at "dts")) . at "datetimes" . to_vector . should_equal [Nothing, Date_Time.new 2022 8 27 11 22 25]
            varied_type_table.filter "datetimes" (Filter_Condition.Is_In (ins.at "dts" . to_vector)) . at "datetimes" . to_vector . should_equal [Nothing, Date_Time.new 2022 8 27 11 22 25]
            varied_type_table.filter "times" (Filter_Condition.Is_In (ins.at "tod")) . at "times" . to_vector . should_equal [Time_Of_Day.new 18 00]
            varied_type_table.filter "times" (Filter_Condition.Is_In (ins.at "tod" . to_vector)) . at "times" . to_vector . should_equal [Time_Of_Day.new 18 00]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In [42, "a", 1, Nothing, Date.new 2022 8 27, Date_Time.new 2022 8 27]) . at "mixed" . to_vector . should_equal [1, "a", Nothing, Date.new 2022 8 27]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In (ins.at "mix")) . at "mixed" . to_vector . should_equal [1]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In (ins.at "mix" . to_vector)) . at "mixed" . to_vector . should_equal [1]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In []) . at "just_nulls" . to_vector . should_equal []
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In (ins.at "nulls")) . at "just_nulls" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In (ins.at "nulls" . to_vector)) . at "just_nulls" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In [0]) . at "just_nulls" . to_vector . should_equal []
            varied_type_table.filter "custom_objects" (Filter_Condition.Is_In (ins.at "custom")) . at "custom_objects" . to_vector . should_equal [My.Data 1 2, Nothing, Nothing]
            varied_type_table.filter "custom_objects" (Filter_Condition.Is_In (ins.at "custom" . to_vector)) . at "custom_objects" . to_vector . should_equal [My.Data 1 2, Nothing, Nothing]

            t2 = Table.new [["ints", [1, 2, 3]], ["doubles", [1.2, 0.0, 1.0]]]
            t2.filter "ints" (Filter_Condition.Is_In [2.0, 1.5, 3, 4]) . at "ints" . to_vector . should_equal [2, 3]
            t2.filter "doubles" (Filter_Condition.Is_In [0.1, 1, 3, 1.2]) . at "doubles" . to_vector . should_equal [1.2, 1.0]
            t3 = Table.new [["ints", [0, 2]], ["doubles", [1.0, 2.0]]]
            t2.filter "ints" (Filter_Condition.Is_In (t3.at "doubles")) . at "ints" . to_vector . should_equal [1, 2]
            t2.filter "doubles" (Filter_Condition.Is_In (t3.at "ints")) . at "doubles" . to_vector . should_equal [0.0]

            # We test these very carefully as our implementation relies on some short-circuit logic that is not as trivial as the hashmap checks which are done for other builtin types.
            [True, False].each has_nulls->
                [True, False].each has_true->
                    [True, False].each has_false->
                        vec_builder = Vector.new_builder
                        if has_nulls then vec_builder.append Nothing
                        if has_true then vec_builder.append True
                        if has_false then vec_builder.append False
                        in_vector = vec_builder.to_vector

                        vectors = [[True, False, Nothing], [Nothing, Nothing, Nothing], [False, False, True], [True, True, True], [False, False, False], [Nothing, True, True], [False, Nothing, False]]
                        vectors.each column_vector->
                            not x = case x of
                                True -> False
                                False -> True
                                Nothing -> Nothing
                            negated_column_vector = column_vector.map not
                            t = Table.new [["X", column_vector]]
                            in_column = Column.from_vector "in" in_vector

                            expected_vector = column_vector.filter (Filter_Condition.Is_In in_vector)
                            expected_neg_vector = negated_column_vector.filter (Filter_Condition.Is_In in_vector)

                            t.filter "X" (Filter_Condition.Is_In in_vector) on_problems=Report_Error . at "X" . to_vector . should_equal expected_vector
                            t.filter "X" (Filter_Condition.Is_In in_column) on_problems=Report_Error . at "X" . to_vector . should_equal expected_vector
                            t2 = t.set "Y" (t.at "X" . not)
                            t2.filter "Y" (Filter_Condition.Is_In in_vector) on_problems=Report_Error . at "Y" . to_vector . should_equal expected_neg_vector
                            t2.filter "Y" (Filter_Condition.Is_In in_column) on_problems=Report_Error . at "Y" . to_vector . should_equal expected_neg_vector

        Test.specify "should perform `Is_In` efficiently for builtin types" <|
            first_day = Date_Time.new 2000 1 1
            make_date x = first_day + (Duration.new seconds=x)
            init = Duration.time_execution <|
                t = Table.new [["X", (200.up_to 10000 . to_vector)]]
                vec = 4000.up_to 13000 . to_vector
                expected_vector = 4000.up_to 10000 . to_vector
                expected_vector_2 = 200.up_to 10000 . with_step 2 . to_vector
                dates_vec = vec.map make_date
                bool_vec = Vector.fill 7000 True
                date_col = t.at "X" . map make_date
                [t, vec, expected_vector, expected_vector_2, dates_vec, bool_vec, date_col]
            t = init.second . at 0
            vec = init.second . at 1
            expected_vector = init.second . at 2
            expected_vector_2 = init.second . at 3
            dates_vec = init.second . at 4
            bool_vec = init.second . at 5
            date_col = init.second . at 6

            expected_max_time_ms = init.first.total_milliseconds * 2
            check_timing name ~action =
                res = Duration.time_execution action
                runtime_ms = res.first.total_milliseconds
                if runtime_ms > expected_max_time_ms then
                    Test.fail "Expected `Is_In` on "+name+" to be efficient, but it took "+runtime_ms.to_text+"ms while initialization itself took just "+expected_max_time_ms.to_text+"ms."

            check_timing "integers" <|
                t.filter "X" (Filter_Condition.Is_In vec) . at "X" . to_vector . should_equal expected_vector

            check_timing "booleans" <|
                t.filter (t.at "X" % 2 == 0) (Filter_Condition.Is_In bool_vec) . at "X" . to_vector . should_equal expected_vector_2

            check_timing "dates" <|
                t.filter date_col (Filter_Condition.Is_In dates_vec) . at "X" . to_vector . should_equal expected_vector

    # TODO move these to Common_Table_Operations
    Test.group "[In-Memory] Table.transpose" <|
        Test.specify "should transpose all columns by default" <|
            t = Table.new [["Key", ["x", "y", "z"]], ["Value", [1, 2, 3]], ["Another", [10, Nothing, 20]], ["Yet Another", [Nothing, "Hello", "World"]]]
            t1 = t.transpose
            t1.row_count . should_equal 12
            t1.column_count . should_equal 2
            t1.at "Name" . to_vector . should_equal ["Key", "Value", "Another", "Yet Another", "Key", "Value", "Another", "Yet Another", "Key", "Value", "Another", "Yet Another"]
            t1.at "Value" . to_vector . should_equal ["x", 1, 10, Nothing, "y", 2, Nothing, "Hello", "z", 3, 20, "World"]

        Test.specify "should allow custom names" <|
            t = Table.new [["Key", ["x", "y", "z"]], ["Value", [1, 2, 3]], ["Another", [10, Nothing, 20]], ["Yet Another", [Nothing, "Hello", "World"]]]
            t1 = t.transpose name_field="Key" value_field="Object"
            t1.row_count . should_equal 12
            t1.column_count . should_equal 2
            t1.at "Key" . to_vector . should_equal ["Key", "Value", "Another", "Yet Another", "Key", "Value", "Another", "Yet Another", "Key", "Value", "Another", "Yet Another"]
            t1.at "Object" . to_vector . should_equal ["x", 1, 10, Nothing, "y", 2, Nothing, "Hello", "z", 3, 20, "World"]

        Test.specify "should allow id fields" <|
            t = Table.new [["Key", ["x", "y", "z"]], ["Value", [1, 2, 3]], ["Another", [10, Nothing, 20]], ["Yet Another", [Nothing, "Hello", "World"]]]
            t1 = t.transpose ["Key"]
            t1.row_count . should_equal 9
            t1.column_count . should_equal 3
            t1.at "Key" . to_vector . should_equal ["x", "x", "x", "y", "y", "y", "z", "z", "z"]
            t1.at "Name" . to_vector . should_equal ["Value", "Another", "Yet Another", "Value", "Another", "Yet Another", "Value", "Another", "Yet Another"]
            t1.at "Value" . to_vector . should_equal [1, 10, Nothing, 2, Nothing, "Hello", 3, 20, "World"]

        Test.specify "should allow single id field" <|
            t = Table.new [["Key", ["x", "y", "z"]], ["Value", [1, 2, 3]], ["Another", [10, Nothing, 20]], ["Yet Another", [Nothing, "Hello", "World"]]]
            t1 = t.transpose "Key"
            t1.row_count . should_equal 9
            t1.column_count . should_equal 3
            t1.at "Key" . to_vector . should_equal ["x", "x", "x", "y", "y", "y", "z", "z", "z"]
            t1.at "Name" . to_vector . should_equal ["Value", "Another", "Yet Another", "Value", "Another", "Yet Another", "Value", "Another", "Yet Another"]
            t1.at "Value" . to_vector . should_equal [1, 10, Nothing, 2, Nothing, "Hello", 3, 20, "World"]

        Test.specify "should allow all id fields with warning or error" <|
            t = Table.new [["Key", ["x", "y", "z"]], ["Value", [1, 2, 3]], ["Another", [10, Nothing, 20]], ["Yet Another", [Nothing, "Hello", "World"]]]
            t1 = t.transpose t.column_names
            t1.row_count . should_equal 3
            t1.column_count . should_equal 6
            t1.at "Key" . to_vector . should_equal ["x", "y", "z"]
            t1.at "Value" . to_vector . should_equal [1, 2, 3]
            t1.at "Name" . to_vector . should_equal [Nothing, Nothing, Nothing]
            t1.at "Value_1" . to_vector . should_equal [Nothing, Nothing, Nothing]

            # ToDo: Verify the warnings and error handling within transpose.

    # TODO move these to Common_Table_Operations
    Test.group "[In-Memory] Table.cross_tab" <|
        Test.specify "should cross_tab counts by default using first column as names" <|
            t = Table.new [["Key", ["x", "x", "x", "x", "y", "y", "y", "z", "z"]], ["Value", [1, 2, 3, 4, 5, 6, 7, 8, 9]]]
            t1 = t.cross_tab
            t1.row_count . should_equal 1
            t1.column_count . should_equal 3
            t1.at "x" . to_vector . should_equal [4]
            t1.at "y" . to_vector . should_equal [3]
            t1.at "z" . to_vector . should_equal [2]

        Test.specify "should allow a different aggregate" <|
            t = Table.new [["Key", ["x", "x", "x", "x", "y", "y", "y", "z", "z"]], ["Value", [1, 2, 3, 4, 5, 6, 7, 8, 9]]]
            t1 = t.cross_tab values=[Sum "Value"]
            t1.row_count . should_equal 1
            t1.column_count . should_equal 3
            t1.at "x" . to_vector . should_equal [10]
            t1.at "y" . to_vector . should_equal [18]
            t1.at "z" . to_vector . should_equal [17]

        Test.specify "should allow a custom expression for the aggregate" <|
            t = Table.new [["Key", ["x", "x", "x", "x", "y", "y", "y", "z", "z"]], ["Value", [1, 2, 3, 4, 5, 6, 7, 8, 9]]]
            t1 = t.cross_tab values=[Sum "[Value]*[Value]"]
            t1.row_count . should_equal 1
            t1.column_count . should_equal 3
            t1.at "x" . to_vector . should_equal [30]
            t1.at "y" . to_vector . should_equal [110]
            t1.at "z" . to_vector . should_equal [145]

        Test.specify "should allow a chosen column" <|
            t = Table.new [["Group", ["A","B","A","B","A","B","A","B","A"]], ["Species", ["x", "x", "x", "x", "y", "y", "y", "z", "z"]], ["Value", [1, 2, 3, 4, 5, 6, 7, 8, 9]]]
            t1 = t.cross_tab [] "Species"
            t1.row_count . should_equal 1
            t1.column_count . should_equal 3
            t1.at "x" . to_vector . should_equal [4]
            t1.at "y" . to_vector . should_equal [3]
            t1.at "z" . to_vector . should_equal [2]

        Test.specify "should allow a grouping" <|
            t = Table.new [["Group", ["A","B","A","B","A","B","A","B","A"]], ["Key", ["x", "x", "x", "x", "y", "y", "y", "z", "z"]], ["Value", [1, 2, 3, 4, 5, 6, 7, 8, 9]]]
            t1 = t.cross_tab ["Group"] "Key"
            t1.row_count . should_equal 2
            t1.column_count . should_equal 4
            t1.at "Group" . to_vector . should_equal ["A", "B"]
            t1.at "x" . to_vector . should_equal [2, 2]
            t1.at "y" . to_vector . should_equal [2, 1]
            t1.at "z" . to_vector . should_equal [1, 1]

        Test.specify "should allow a grouping by text" <|
            t = Table.new [["Group", ["A","B","A","B","A","B","A","B","A"]], ["Key", ["x", "x", "x", "x", "y", "y", "y", "z", "z"]], ["Value", [1, 2, 3, 4, 5, 6, 7, 8, 9]]]
            t1 = t.cross_tab "Group" "Key"
            t1.row_count . should_equal 2
            t1.column_count . should_equal 4
            t1.at "Group" . to_vector . should_equal ["A", "B"]
            t1.at "x" . to_vector . should_equal [2, 2]
            t1.at "y" . to_vector . should_equal [2, 1]
            t1.at "z" . to_vector . should_equal [1, 1]

        Test.specify "should aggregate if name_field not found" <|
            t = Table.new [["Key", ["x", "x", "x", "x", "y", "y", "y", "z", "z"]], ["Value", [1, 2, 3, 4, 5, 6, 7, 8, 9]]]
            t1 = t.cross_tab [] "Name"
            t1.row_count . should_equal 1
            t1.column_count . should_equal 1
            t1.at "Count" . to_vector . should_equal [9]

            # ToDo: Verify the warnings and error handling within cross_tab.

    Test.group "[In-Memory] Table.join" <|
        Test.specify "should correctly report unsupported cross-backend joins" <|
            t = Table.new [["X", [1, 2, 3]]]
            t.join 42 . should_fail_with Type_Error.Error

            db = Database.connect (SQLite In_Memory)
            db_table = db.upload_table "test" (Table.new [["Y", [4, 5, 6]]])

            r = t.join db_table
            r.should_fail_with Illegal_Argument.Error
            r.catch.message . contains "cross-backend" . should_be_true

main = Test_Suite.run_main spec

## JS indexes months form 0, so we need to subtract 1.
foreign js js_make_date year month day = """
    return new Date(year, month - 1, day)

foreign js js_make_object key value = """
    var obj = {}
    obj[key] = value
    return obj

foreign python py_make_date year month day = """
    import datetime
    return datetime.date(year, month, day)

foreign python py_make_object key value = """
    return {key: value}
