from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

import Standard.Database.Feature.Feature
from Standard.Database.Errors import all
from Standard.Table import Position, Value_Type, Bits, Table
from Standard.Table.Errors import all

from Standard.Test import all

from project.Common_Table_Operations.Util import expect_column_names, run_default_backend
import project.Common_Table_Operations.Util

main filter=Nothing = run_default_backend add_specs filter

type Select_Columns_Data
    Value ~data

    table self = self.data.at 0

    setup table_builder = Select_Columns_Data.Value <|
        table =
            col1 = ["foo", [1,2,3]]
            col2 = ["bar", [4,5,6]]
            col3 = ["Baz", [7,8,9]]
            col4 = ["foo 1", [10,11,12]]
            col5 = ["foo 2", [13,14,15]]
            col6 = ["ab.+123", [16,17,18]]
            col7 = ["abcd123", [19,20,21]]
            table_builder [col1, col2, col3, col4, col5, col6, col7]
        [table]

type Mixed_Columns_Data
    Value ~data

    table self = self.data.at 0

    setup table_builder = Mixed_Columns_Data.Value <|
        table =
            col1 = ["int", [1, 2, 3]]
            col2 = ["float", [4.1, 5.2, 6.3]]
            col3 = ["text", ["A", "B", "C"]]
            col4 = ["bool", [True, False, True]]
            table_builder [col1, col2, col3, col4]
        [table]

type Sort_Columns_Data
    Value ~data

    table self = self.data.at 0

    setup table_builder = Sort_Columns_Data.Value <|
        table =
            col1 = ["foo 21", [1,2,3]]
            col2 = ["foo 100", [4,5,6]]
            col3 = ["foo 1", [7,8,9]]
            col4 = ["Foo 2", [10,11,12]]
            col5 = ["foo 3", [13,14,15]]
            col6 = ["foo 001", [16,17,18]]
            col7 = ["bar", [19,20,21]]
            table_builder [col1, col2, col3, col4, col5, col6, col7]
        [table]

type Rename_Columns_Data
    Value ~data

    table self = self.data.at 0

    setup table_builder = Rename_Columns_Data.Value <|
        table =
            col1 = ["alpha", [1,2,3]]
            col2 = ["beta", [4,5,6]]
            col3 = ["gamma", [16,17,18]]
            col4 = ["delta", [19,20,21]]
            table_builder [col1, col2, col3, col4]
        [table]

add_specs suite_builder setup =
    if setup.is_feature_supported Feature.Select_Columns then (add_select_column_specs suite_builder setup) else
        suite_builder.group setup.prefix+"Table.select_columns" group_builder->
            group_builder.specify "select_columns should report unsupported" <|
                table_builder = Util.build_sorted_table setup
                data = Select_Columns_Data.setup table_builder
                table_2 = data.table.select_columns ["bar", "foo"] reorder=True
                table_2.should_fail_with (Unsupported_Database_Operation.Error "select_columns")

add_select_column_specs suite_builder setup =
    prefix = setup.prefix
    table_builder = Util.build_sorted_table setup

    suite_builder.group prefix+"Table.select_columns" group_builder->
        data = Select_Columns_Data.setup table_builder

        group_builder.specify "should work as shown in the doc examples" <|
            expect_column_names ["foo", "bar"] <| data.table.select_columns ["bar", "foo"]
            expect_column_names ["bar", "Baz", "foo 1", "foo 2"] <| data.table.select_columns ["foo.+".to_regex, "b.*".to_regex True]
            expect_column_names ["abcd123", "foo", "bar"] <| data.table.select_columns [-1, 0, 1] reorder=True

        group_builder.specify "should allow to reorder columns if asked to" <|
            table_2 = data.table.select_columns ["bar", "foo"] reorder=True
            expect_column_names ["bar", "foo"] table_2
            table_2 . at "bar" . to_vector . should_equal [4,5,6]
            table_2 . at "foo" . to_vector . should_equal [1,2,3]

        group_builder.specify "should correctly handle regex matching" <|
            expect_column_names ["foo"] <| data.table.select_columns ["foo".to_regex]
            expect_column_names ["ab.+123", "abcd123"] <| data.table.select_columns ["a.*".to_regex]
            expect_column_names ["ab.+123", "abcd123"] <| data.table.select_columns ["ab.+123".to_regex]
            expect_column_names ["ab.+123"] <| data.table.select_columns ["ab.+123"]
            expect_column_names ["abcd123"] <| data.table.select_columns ["abcd123".to_regex]

        group_builder.specify "should allow negative indices" <|
            expect_column_names ["foo", "bar", "foo 2"] <| data.table.select_columns [-3, 0, 1]

        group_builder.specify "should allow mixed names and indexes" <|
            expect_column_names ["foo", "bar", "foo 2"] <| data.table.select_columns [-3, "bar", 0]
            expect_column_names ["foo 2", "bar", "foo"] <| data.table.select_columns [-3, "bar", 0] reorder=True
            expect_column_names ["foo", "bar", "foo 1", "foo 2", "abcd123"] <| data.table.select_columns [-1, "bar", "foo.*".to_regex]
            expect_column_names ["foo", "foo 1", "foo 2", "bar", "abcd123"] <| data.table.select_columns ["foo.*".to_regex, "bar", "foo", -1] reorder=True

        group_builder.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
            table =
                col1 = ["foo", [1,2,3]]
                col2 = ["bar", [4,5,6]]
                col3 = ["Bar", [7,8,9]]
                table_builder [col1, col2, col3]
            if setup.flagged ..Supports_Case_Sensitive_Columns then
                expect_column_names ["bar", "Bar"] <| table.select_columns ["bar"] case_sensitivity=Case_Sensitivity.Insensitive
        
        group_builder.specify "should correctly handle mis-matches due to case insensitivity regardless of backend support" <|
            table =
                col1 = ["foo", [1,2,3]]
                col2 = ["bar", [4,5,6]]
                table_builder [col1, col2]
            result = table.select_columns ["Bar"] case_sensitivity=Case_Sensitivity.Default
            case setup.flagged ..Supports_Case_Sensitive_Columns of
                True -> result.should_fail_with (Missing_Input_Columns.Error ["Bar"])
                False -> result.should_fail_with (Missing_Input_Columns.Error ["Bar"])

        group_builder.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["foo", "bar", "foo 1", "foo 2"] <| data.table.select_columns ["b.*".to_regex, "f.+".to_regex]
            expect_column_names ["bar", "foo", "foo 1", "foo 2"] <| data.table.select_columns ["b.*".to_regex, "f.+".to_regex] reorder=True

        group_builder.specify "should correctly handle problems: out of bounds indices" <|
            selector = [1, 0, 100, -200, 300]
            action = data.table.select_columns selector error_on_missing_columns=False on_problems=_
            tester = expect_column_names ["foo", "bar"]
            problems = [Missing_Input_Columns.Error [100, -200, 300]]
            Problems.test_problem_handling action problems tester

            err = data.table.select_columns selector
            err.should_fail_with Missing_Input_Columns

        group_builder.specify "should correctly handle edge-cases: duplicate indices" <|
            selector = [0, 0, 0]
            t = data.table.select_columns selector on_problems=..Report_Error
            expect_column_names ["foo"] t

            expect_column_names ["foo", "bar"] <|
                data.table.select_columns [0, 1, 0]

        group_builder.specify "should correctly handle edge-cases: aliased indices" <|
            selector = [0, -6, 1, -7]
            t = data.table.select_columns selector on_problems=..Report_Error
            expect_column_names ["foo", "bar"] t

        group_builder.specify "should correctly handle edge-cases: duplicate names" <|
            selector = ["foo", "foo"]
            t = data.table.select_columns selector on_problems=..Report_Error
            expect_column_names ["foo"] t

            expect_column_names ["foo", "bar"] <|
                data.table.select_columns ["foo", "bar", "foo", "foo", "bar"] reorder=True

            expect_column_names ["bar", "foo"] <|
                data.table.select_columns ["bar", "foo", "bar", "foo", "foo", "bar"] reorder=True

            expect_column_names ["foo", "bar"] <|
                data.table.select_columns ["bar", "foo", "foo", "bar"] reorder=False

        group_builder.specify "should correctly handle edge-cases: duplicate matches due to case insensitivity" <|
            selector = ["FOO", "foo"]
            t = data.table.select_columns selector case_sensitivity=Case_Sensitivity.Insensitive on_problems=..Report_Error
            expect_column_names ["foo"] t

            expect_column_names ["bar", "foo"] <|
                data.table.select_columns ["BAR", "foo", "bar"] reorder=True case_sensitivity=Case_Sensitivity.Insensitive

        group_builder.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = ["foo", "hmm", weird_name]
            action = data.table.select_columns selector error_on_missing_columns=False on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Missing_Input_Columns.Error ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

            err = data.table.select_columns selector on_problems=..Ignore
            err.should_fail_with Missing_Input_Columns
            err.catch.criteria . should_equal ["hmm", weird_name]

        group_builder.specify "should correctly handle problems in mixed case" <|
            err = data.table.select_columns ["foo", "hmm", 99] on_problems=..Ignore
            err.should_fail_with Missing_Input_Columns
            err.catch.criteria . should_equal ["hmm", 99]

        group_builder.specify "should correctly handle problems: no columns in the output" <|
            [Problem_Behavior.Ignore, Problem_Behavior.Report_Warning, Problem_Behavior.Report_Error].each pb->
                t = data.table.select_columns [] on_problems=pb
                t.should_fail_with No_Output_Columns
                # Just selecting [] means the No_Output_Columns does not have an additional cause.
                t.catch.cause . should_equal Nothing
                t.catch.to_display_text . should_equal "The result would contain no columns."

            data.table.select_columns ["hmmm"] . should_fail_with Missing_Input_Columns
            r2 = data.table.select_columns ["hmmm"] error_on_missing_columns=False
            r2.should_fail_with No_Output_Columns
            r2.catch.cause . should_be_a Missing_Input_Columns
            r2.catch.to_display_text . should_equal "No columns in the result, because of another problem: The criteria 'hmmm' did not match any columns."

    suite_builder.group prefix+"Table.select_columns By_Type and Table.remove_columns By_Type" group_builder->
        data = Mixed_Columns_Data.setup table_builder

        group_builder.specify "should be able to select by type of columns" <|
            expect_column_names ["int"] <| data.table.select_columns [..By_Type ..Integer]
            expect_column_names ["float"] <| data.table.select_columns [..By_Type ..Float]
            expect_column_names ["int", "float"] <| data.table.select_columns [..By_Type ..Integer, ..By_Type ..Float]
            expect_column_names ["text"] <| data.table.select_columns [..By_Type ..Char]
            expect_column_names ["bool"] <| data.table.select_columns [..By_Type ..Boolean]

        group_builder.specify "should be able to drop by type of columns" <|
            expect_column_names ["float", "text", "bool"] <| data.table.remove_columns [..By_Type ..Integer]
            expect_column_names ["int", "text", "bool"] <| data.table.remove_columns [..By_Type ..Float]
            expect_column_names ["text", "bool"] <| data.table.remove_columns [..By_Type ..Integer, ..By_Type ..Float]
            expect_column_names ["int", "float", "bool"] <| data.table.remove_columns [..By_Type ..Char]
            expect_column_names ["int", "float", "text"] <| data.table.remove_columns [..By_Type ..Boolean]

    suite_builder.group prefix+"Table.remove_columns" group_builder->
        data = Select_Columns_Data.setup table_builder

        group_builder.specify "should work as shown in the doc examples" <|
            expect_column_names ["Baz", "foo 1", "foo 2", "ab.+123", "abcd123"] <| data.table.remove_columns ["bar", "foo"]
            expect_column_names ["foo", "ab.+123", "abcd123"] <| data.table.remove_columns ["foo.+".to_regex, "b.*".to_regex] Case_Sensitivity.Insensitive
            expect_column_names ["Baz", "foo 1", "foo 2", "ab.+123"] <| data.table.remove_columns [-1, 0, 1]

        group_builder.specify "should correctly handle regex matching" <|
            last_ones = data.table.columns.drop 1 . map .name
            expect_column_names last_ones <| data.table.remove_columns ["foo".to_regex]
            first_ones = ["foo", "bar", "Baz", "foo 1", "foo 2"]
            expect_column_names first_ones <| data.table.remove_columns ["a.*".to_regex]
            expect_column_names first_ones <| data.table.remove_columns ["ab.+123".to_regex]
            expect_column_names first_ones+["abcd123"] <| data.table.remove_columns ["ab.+123"] Case_Sensitivity.Insensitive
            expect_column_names first_ones+["ab.+123"] <| data.table.remove_columns ["abcd123".to_regex]

        group_builder.specify "should allow negative indices" <|
            expect_column_names ["Baz", "foo 1", "ab.+123"] <| data.table.remove_columns [-1, -3, 0, 1]

        group_builder.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
            table =
                col1 = ["foo", [1,2,3]]
                col2 = ["bar", [4,5,6]]
                col3 = ["Bar", [7,8,9]]
                table_builder [col1, col2, col3]
            if setup.flagged ..Supports_Case_Sensitive_Columns then
                expect_column_names ["foo"] <| table.remove_columns "bar" Case_Sensitivity.Insensitive

        group_builder.specify "should correctly handle mis-matches due to case insensitivity regardless of backend support" <|
            table =
                col1 = ["foo", [1,2,3]]
                col2 = ["bar", [4,5,6]]
                table_builder [col1, col2]
            result = table.remove_columns "Bar" Case_Sensitivity.Default
            case setup.flagged ..Supports_Case_Sensitive_Columns of
                True -> expect_column_names ["foo", "bar"] <| result
                False -> expect_column_names ["foo", "bar"] <| result

        group_builder.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["Baz", "ab.+123", "abcd123"] <| data.table.remove_columns ["f.+".to_regex, "b.*".to_regex]

        group_builder.specify "should correctly handle problems: out of bounds indices" <|
            selector = [1, 0, 100, -200, 300]
            action = data.table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo 1", "foo 2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns.Error [100, -200, 300]]
            Problems.test_problem_handling action problems tester

            err = data.table.remove_columns selector error_on_missing_columns=True
            err.should_fail_with Missing_Input_Columns

        group_builder.specify "should correctly handle edge-cases: duplicate indices" <|
            selector = [0, 0, 0]
            t = data.table.remove_columns selector on_problems=..Report_Error
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123"] t

        group_builder.specify "should correctly handle edge-cases: aliased indices" <|
            selector = [0, -7, -6, 1]
            t = data.table.remove_columns selector on_problems=..Report_Error
            expect_column_names ["Baz", "foo 1", "foo 2", "ab.+123", "abcd123"]  t

        group_builder.specify "should correctly handle edge-cases: duplicate names" <|
            selector = ["foo", "foo"]
            t = data.table.remove_columns selector on_problems=..Report_Error
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123"] t

        group_builder.specify "should correctly handle edge-cases: duplicate matches due to case insensitivity" <|
            selector = ["FOO", "foo"]
            t = data.table.remove_columns selector Case_Sensitivity.Insensitive on_problems=..Report_Error
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123"] t

        group_builder.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = ["foo", "hmm", weird_name]
            action = data.table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns.Error ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

            err = data.table.remove_columns selector error_on_missing_columns=True on_problems=..Ignore
            err.should_fail_with Missing_Input_Columns

        group_builder.specify "should correctly handle problems: no columns in the output" <|
            [Problem_Behavior.Ignore, Problem_Behavior.Report_Warning, Problem_Behavior.Report_Error].each pb->
                selector = [".*".to_regex]
                t = data.table.remove_columns selector on_problems=pb
                t.should_fail_with No_Output_Columns

            selector_2 = [".*".to_regex, "hmmm".to_regex]
            t1 = data.table.remove_columns selector_2
            t1.should_fail_with No_Output_Columns
            # No cause specified - even if some criteria were unmatched, that is not the reason for the No_Output_Columns (the reason is all other columns got deleted, by other criteria that _did_ match).
            t1.catch.cause . should_equal Nothing

    suite_builder.group prefix+"Table.reorder_columns" group_builder->
        data = Select_Columns_Data.setup table_builder

        group_builder.specify "should work as shown in the doc examples" <|
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo"] <| data.table.reorder_columns "foo" Position.After_Other_Columns
            expect_column_names ["Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo", "bar"] <| data.table.reorder_columns ["foo", "bar"] Position.After_Other_Columns
            expect_column_names ["foo 1", "foo 2", "bar", "Baz", "foo", "ab.+123", "abcd123"] <| data.table.reorder_columns ["foo.+".to_regex, "b.*".to_regex] case_sensitivity=Case_Sensitivity.Insensitive
            expect_column_names ["bar", "foo", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123"] <| data.table.reorder_columns [1, 0] Position.Before_Other_Columns
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo"] <| data.table.reorder_columns [0] Position.After_Other_Columns

        group_builder.specify "should correctly handle regex matching" <|
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo"] <| data.table.reorder_columns ["foo".to_regex] Position.After_Other_Columns
            rest = ["foo", "bar", "Baz", "foo 1", "foo 2"]
            expect_column_names ["ab.+123", "abcd123"]+rest <| data.table.reorder_columns ["a.*".to_regex]
            expect_column_names ["ab.+123", "abcd123"]+rest <| data.table.reorder_columns ["ab.+123".to_regex]
            expect_column_names ["ab.+123"]+rest+["abcd123"] <| data.table.reorder_columns ["ab.+123"]
            expect_column_names ["abcd123"]+rest+["ab.+123"] <| data.table.reorder_columns ["abcd123".to_regex]

        group_builder.specify "should allow negative indices" <|
            expect_column_names ["abcd123", "foo 2", "foo", "bar", "Baz", "foo 1", "ab.+123"] <| data.table.reorder_columns [-1, -3, 0, 1]

        group_builder.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
            table =
                col1 = ["foo", [1,2,3]]
                col2 = ["bar", [4,5,6]]
                col3 = ["Bar", [7,8,9]]
                table_builder [col1, col2, col3]
            if setup.flagged ..Supports_Case_Sensitive_Columns then
                expect_column_names ["bar", "Bar", "foo"] <| table.reorder_columns ["bar"] case_sensitivity=Case_Sensitivity.Insensitive

        group_builder.specify "should correctly handle mis-matches due to case insensitivity regardless of backend support" <|
            table =
                col1 = ["foo", [1,2,3]]
                col2 = ["bar", [4,5,6]]
                table_builder [col1, col2]
            result = table.reorder_columns ["Bar"] case_sensitivity=Case_Sensitivity.Default
            case setup.flagged ..Supports_Case_Sensitive_Columns of
                True -> expect_column_names ["foo", "bar"] <| result
                False -> expect_column_names ["foo", "bar"] <| result

        group_builder.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["bar", "foo", "foo 1", "foo 2", "Baz", "ab.+123", "abcd123"] <| data.table.reorder_columns ["b.*".to_regex, "f.+".to_regex]

        group_builder.specify "should correctly handle problems: out of bounds indices" <|
            selector = [1, 0, 100, -200, 300]
            action = data.table.reorder_columns selector on_problems=_
            tester = expect_column_names ["bar", "foo", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns.Error [100, -200, 300]]
            Problems.test_problem_handling action problems tester

            err = data.table.reorder_columns selector error_on_missing_columns=True
            err.should_fail_with Missing_Input_Columns

        group_builder.specify "should correctly handle edge-cases: duplicate indices" <|
            selector = [0, 0, 0]
            t = data.table.reorder_columns selector Position.After_Other_Columns on_problems=..Report_Error
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo"] t

        group_builder.specify "should correctly handle edge-cases: aliased indices" <|
            selector = [0, -7, -6, 1]
            t = data.table.reorder_columns selector Position.After_Other_Columns on_problems=..Report_Error
            expect_column_names ["Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo", "bar"] t

        group_builder.specify "should correctly handle edge-cases: duplicate names" <|
            selector = ["foo", "foo"]
            t = data.table.reorder_columns selector Position.After_Other_Columns on_problems=..Report_Error
            expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo"] t

        group_builder.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = ["foo", "hmm", weird_name]
            action = data.table.reorder_columns selector Position.After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo 1", "foo 2", "ab.+123", "abcd123", "foo"]
            problems = [Missing_Input_Columns.Error ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

            err = data.table.reorder_columns selector Position.After_Other_Columns error_on_missing_columns=True
            err.should_fail_with Missing_Input_Columns

    suite_builder.group prefix+"Table.reorder_columns by type" group_builder->
        data = Mixed_Columns_Data.setup table_builder

        group_builder.specify "should correctly handle By_Type matching" <|
            expect_column_names ["float", "text", "bool", "int"] <| data.table.reorder_columns [..By_Type ..Integer] Position.After_Other_Columns
            expect_column_names ["float", "text", "int", "bool"] <| data.table.reorder_columns [..By_Type ..Integer, ..By_Type ..Boolean] Position.After_Other_Columns

    suite_builder.group prefix+"Table.sort_columns" group_builder->
        data = Sort_Columns_Data.setup table_builder

        group_builder.specify "should work as shown in the doc examples" <|
            sorted = data.table.sort_columns
            expect_column_names ["Foo 2", "bar", "foo 001", "foo 1", "foo 100", "foo 21", "foo 3"] sorted
            sorted.columns.first.to_vector . should_equal [10,11,12]

            expect_column_names ["bar", "foo 001", "foo 1", "Foo 2", "foo 3", "foo 21", "foo 100"] <| data.table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)
            expect_column_names ["foo 3", "foo 21", "foo 100", "foo 1", "foo 001", "bar", "Foo 2"] <| data.table.sort_columns Sort_Direction.Descending

        group_builder.specify "should correctly handle case-insensitive sorting" <|
            expect_column_names ["bar", "foo 001", "foo 1", "foo 100", "Foo 2", "foo 21", "foo 3"] <| data.table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive)

        group_builder.specify "should correctly handle natural order sorting" <|
            expect_column_names ["Foo 2", "bar", "foo 001", "foo 1", "foo 3", "foo 21", "foo 100"] <| data.table.sort_columns text_ordering=(Text_Ordering.Default sort_digits_as_numbers=True)

        group_builder.specify "should correctly handle various combinations of options" <|
            expect_column_names ["foo 100", "foo 21", "foo 3", "Foo 2", "foo 1", "foo 001", "bar"] <| data.table.sort_columns Sort_Direction.Descending text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)

    suite_builder.group prefix+"Table.rename_columns" group_builder->
        data = Rename_Columns_Data.setup table_builder

        group_builder.specify "should work as shown in the doc examples" <|
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                data.table.rename_columns ["FirstColumn"]

            expect_column_names ["prefix_alpha", "prefix_beta", "prefix_gamma", "prefix_delta"] <|
                data.table.rename_columns (data.table.columns.map c-> "prefix_" + c.name)

            t1 = table_builder [["alpha", [1]], ["name=123", [2]], ["name= foo bar", [3]]]
            expect_column_names ["alpha", "key:123", "key: foo bar"] <|
                t1.rename_columns (Dictionary.from_vector [["name=(.*)".to_regex, "key:$1"]])

        group_builder.specify "should work by index" <|
            map = Dictionary.from_vector [[0, "FirstColumn"], [-2, "Another"]]
            expect_column_names ["FirstColumn", "beta", "Another", "delta"] <|
                data.table.rename_columns map

        group_builder.specify "should work by position" <|
            vec = ["one", "two", "three"]
            expect_column_names ["one", "two", "three", "delta"] <|
                data.table.rename_columns vec

        group_builder.specify "should work by Vector" <|
            vec = ["one", "two", "three"]
            expect_column_names ["one", "two", "three", "delta"] <|
                data.table.rename_columns vec

        group_builder.specify "should work by Vector of Pairs" <|
            vec = [["beta", "one"], ["delta", "two"], ["alpha", "three"]]
            expect_column_names ["three", "one", "gamma", "two"] <|
                data.table.rename_columns vec

        group_builder.specify "should work by name" <|
            map = Dictionary.from_vector [["alpha", "FirstColumn"], ["delta", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                data.table.rename_columns map

        group_builder.specify "should work by mixed Map" <|
            map = Dictionary.from_vector [["alpha", "FirstColumn"], [-1, "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                data.table.rename_columns map

        group_builder.specify "should work by single column Table of names" <|
            table_1 = Table.new [["Name", ["one", "two", "three"]]]
            expect_column_names ["one", "two", "three", "delta"] <|
                data.table.rename_columns table_1

        group_builder.specify "should work by two column Table of old name, new name" <|
            table_2 = Table.from_rows ["Old", "New"] [["beta", "one"], ["delta", "two"], ["alpha", "three"]]
            expect_column_names ["three", "one", "gamma", "two"] <|
                data.table.rename_columns table_2

        group_builder.specify "should error if not correct table structure" <|
            table_1 = Table.new [["Name", [1, 2, 3]]]
            fail_1 = data.table.rename_columns table_1
            fail_1 . should_fail_with Illegal_Argument
            fail_1.catch.message.should_equal "Expected a table with one or two columns of text values."

            table_2 = Table.from_rows ["Old", "New"] [["beta", 1], ["delta", 2], ["alpha", 3]]
            fail_2 = data.table.rename_columns table_2
            fail_2 . should_fail_with Illegal_Argument
            fail_2.catch.message.should_equal "Expected a table with one or two columns of text values."

            table_3 = Table.new [["Name", ["A", "B", "C"]], ["NewName", ["AA", "BB", "CC"]], ["Another", ["a", "b", "c"]]]
            fail_3 = data.table.rename_columns table_3
            fail_3 . should_fail_with Illegal_Argument
            fail_3.catch.message.should_equal "Expected a table with one or two columns of text values."

        if setup.is_database then group_builder.specify "should error if renaming by Database table (it must be materialized)" <|
            db_source_table = data.table
            db_rename_table = data.table.select_columns [0, 1] . cast [0, 1] Value_Type.Char
            fail_1 = db_source_table.rename_columns db_rename_table
            fail_1.should_fail_with Illegal_Argument
            fail_1.catch.message.should_contain "materialize"

            # We also check that renaming an in-memory table with a database table as mapping also fails.
            fail_2 = (Table.new [["X", [1, 2]]]).rename_columns db_rename_table
            fail_2.should_fail_with Illegal_Argument
            fail_2.catch.message.should_contain "materialize"

        group_builder.specify "should work by name case-insensitively" <|
            map = Dictionary.from_vector [["ALPHA", "FirstColumn"], ["DELTA", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                data.table.rename_columns map Case_Sensitivity.Insensitive

        group_builder.specify "should work by name using regex" <|
            map = Dictionary.from_vector [["a.*".to_regex, "FirstColumn"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                data.table.rename_columns map

        group_builder.specify "should work by name using regex substitution" <|
            map = Dictionary.from_vector [["a(.*)".to_regex, "$1"]]
            expect_column_names ["lpha", "beta", "gamma", "delta"] <|
                data.table.rename_columns map

        group_builder.specify "should report invalid input map nicely" <|
            test_invalid_map map =
                result = data.table.rename_columns map
                result.should_fail_with Illegal_Argument
                result.catch Any . message . should_equal "mapping is not a Vector of old name to new name."

            test_invalid_map [["Alpha"]]
            test_invalid_map [["Alpha", 1]]
            test_invalid_map [["Alpha", "Beta", "Delta"]]
            test_invalid_map [[True, "Beta"]]

        group_builder.specify "should report duplicates in input map nicely" <|
            test_duplicate_names map message =
                result = data.table.rename_columns map
                result.should_fail_with Illegal_Argument
                result.catch Any . message . should_equal message

            test_duplicate_names [["Alpha", "1"], ["Alpha", "2"]] "duplicate old name mappings (Alpha)."
            test_duplicate_names [["Alpha", "1"], ["Beta", "2"], ["Gamma", "3"], ["Beta", "4"], ["Alpha", "5"]] "duplicate old name mappings (Alpha, Beta)."
            test_duplicate_names [["Alpha", "1"], ["Alpha", "2"], ["Alpha", "3"]] "duplicate old name mappings (Alpha)."
            test_duplicate_names [["Alpha", "1"], ["Beta", "2"], ["Gamma", "3"], ["Beta", "4"], ["Alpha", "5"], ["Gamma","6"], ["Delta","7"], ["Delta","8"]] "duplicate old name mappings (Alpha, Beta, Gamma, Delta)."
            test_duplicate_names [["Alpha", "1"], ["Beta", "2"], ["Gamma", "3"], ["Beta", "4"], ["Alpha", "5"], ["Gamma","6"], ["Delta","7"], ["Delta","8"], ["Echo","9"], ["Echo","10"]] "duplicate old name mappings (Alpha, Beta, Gamma, ... 2 others)."

        group_builder.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            map = Dictionary.from_vector [["alpha", "FirstColumn"], ["omicron", "Another"], [weird_name, "Fixed"]]
            action = data.table.rename_columns map error_on_missing_columns=False on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "delta"]
            err_checker err =
                err.catch.should_be_a Missing_Input_Columns.Error
                err.catch.criteria.should_equal_ignoring_order ["omicron", weird_name]
            Problems.test_advanced_problem_handling action err_checker (x-> x) tester

            err = data.table.rename_columns map
            err.should_fail_with Missing_Input_Columns

        group_builder.specify "should correctly handle problems: out of bounds indices" <|
            map = Dictionary.from_vector [[0, "FirstColumn"], [-1, "Another"], [100, "Boo"], [-200, "Nothing"], [300, "Here"]]
            action = data.table.rename_columns map error_on_missing_columns=False on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "Another"]
            err_checker err =
                err.catch.should_be_a Missing_Input_Columns.Error
                err.catch.criteria.should_equal_ignoring_order [-200, 100, 300]
            Problems.test_advanced_problem_handling action err_checker (x-> x) tester

            err = data.table.rename_columns map
            err.should_fail_with Missing_Input_Columns

        group_builder.specify "should correctly handle edge-cases: aliased indices" <|
            map1 = Dictionary.from_vector [[1, "FirstColumn"], [-3, "FirstColumn"]]
            t1 = data.table.rename_columns map1 on_problems=..Report_Error
            Problems.assume_no_problems t1
            expect_column_names ["alpha", "FirstColumn", "gamma", "delta"] t1

            map2 = Dictionary.from_vector [[1, "FirstColumn"], [-3, "DifferentName!"]]
            t2 = data.table.rename_columns map2 on_problems=..Report_Error
            t2.should_fail_with Ambiguous_Column_Rename
            err = t2.catch . inner_error
            err.column_name . should_equal "beta"
            err.new_names.sort . should_equal ["DifferentName!", "FirstColumn"]

        group_builder.specify "should correctly handle edge-cases: aliased selectors" <|
            t = table_builder [["alpha", [1,2,3]], ["bet", [4,5,6]]]
            map1 = Dictionary.from_vector [["a.*".to_regex, "AA"], [".*a".to_regex, "AA"]]
            t1 = t.rename_columns map1 on_problems=..Report_Error
            Problems.assume_no_problems t1
            expect_column_names ["AA", "bet"] t1

            map2 = Dictionary.from_vector [["a.*".to_regex, "StartsWithA"], [".*a".to_regex, "EndsWithA"]]
            t2 = t.rename_columns map2 on_problems=..Report_Error
            t2.should_fail_with Ambiguous_Column_Rename
            err = t2.catch . inner_error
            err.column_name . should_equal "alpha"
            err.new_names . sort . should_equal ["EndsWithA", "StartsWithA"]

            t3 = table_builder [["aaa", [1]], ["bbb", [2]]]
            ## The rename patterns are deliberately prepared so that both will
               match `aaa` and the resulting replacement for both will be `aaA`.
               This is to show that even if distinct rename patterns match the
               same column, if the resulting rename is unambiguous, no error is
               raised.
            map3 = Dictionary.from_vector [["a(.*)".to_regex, "$1A"], ["(.*)aa".to_regex, "$1aA"]]
            t4 = t3.rename_columns map3 on_problems=..Report_Error
            Problems.assume_no_problems t4
            expect_column_names ["aaA", "bbb"] t4

        group_builder.specify "should correctly handle problems: invalid names ''" <|
            map = Dictionary.from_vector [[1, ""]]
            [Problem_Behavior.Ignore, Problem_Behavior.Report_Warning, Problem_Behavior.Report_Error].each pb->
                r = data.table.rename_columns map on_problems=pb
                r.should_fail_with Invalid_Column_Names

        group_builder.specify "should correctly handle problems: invalid names Nothing" <|
            map = ["alpha", Nothing]
            [Problem_Behavior.Ignore, Problem_Behavior.Report_Warning, Problem_Behavior.Report_Error].each pb->
                r = data.table.rename_columns map on_problems=pb
                r.should_fail_with Invalid_Column_Names

        group_builder.specify "should correctly handle problems: invalid names null character" <|
            map = ["alpha", 'a\0b']
            [Problem_Behavior.Ignore, Problem_Behavior.Report_Warning, Problem_Behavior.Report_Error].each pb->
                r = data.table.rename_columns map on_problems=pb
                r.should_fail_with Invalid_Column_Names

        group_builder.specify "should correctly handle problems: duplicate names" <|
            map = ["Test", "Test", "Test", "Test"]
            action = data.table.rename_columns map on_problems=_
            tester = expect_column_names ["Test 1", "Test 2", "Test 3", "Test"] ignore_order=True
            problems = [Duplicate_Output_Column_Names.Error ["Test", "Test", "Test"]]
            Problems.test_problem_handling action problems tester

        group_builder.specify "should correctly handle problems: new name is clashing with existing name of existing column" <|
            map = Dictionary.from_vector [["alpha", "beta"]]
            action = data.table.rename_columns map on_problems=_
            tester = expect_column_names ["beta", "beta 1", "gamma", "delta"]
            problems = [Duplicate_Output_Column_Names.Error ["beta"]]
            Problems.test_problem_handling action problems tester

            map2 = Dictionary.from_vector [["beta", "alpha"]]
            action2 = data.table.rename_columns map2 on_problems=_
            tester2 = expect_column_names ["alpha 1", "alpha", "gamma", "delta"]
            problems2 = [Duplicate_Output_Column_Names.Error ["alpha"]]
            Problems.test_problem_handling action2 problems2 tester2

        group_builder.specify "should correctly handle problems: too many input names" <|
            map = ["A", "B", "C", "D", "E", "F"]
            action = data.table.rename_columns map on_problems=_
            tester = expect_column_names ["A", "B", "C", "D"]
            problem_checker problem =
                problem.should_be_a Too_Many_Column_Names_Provided.Error
                problem.column_names.should_equal_ignoring_order ["E", "F"]
                True
            err_checker err =
                problem_checker err.catch
            warn_checker warnings =
                warnings.all problem_checker
            Problems.test_advanced_problem_handling action err_checker warn_checker tester
