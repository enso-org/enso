from Standard.Base import all

import Standard.Table.Data.Join_Condition.Join_Condition
import Standard.Table.Data.Join_Kind.Join_Kind
from Standard.Table.Errors import all

from Standard.Test import Test, Problems
import Standard.Test.Extensions

from project.Common_Table_Operations.Util import expect_column_names, run_default_backend

main = run_default_backend spec

spec setup =
    prefix = setup.prefix
    table_builder = setup.table_builder
    join_pending = if prefix.contains "In-Memory" then Nothing else "New Joining API is not supported by the database backends yet."
    Test.group prefix+"Table.join" pending=join_pending <|
        t1 = table_builder [["X", [1, 2, 3]], ["Y", [4, 5, 6]]]
        t2 = table_builder [["Z", [2, 3, 2, 4]], ["W", [4, 5, 6, 7]]]
        Test.specify "should allow to inner join on equality of a the first column by default" <|

            t3 = t1.join t2
            expect_column_names ["X", "Y", "Z", "W"] t3
            t4 = t3.order_by ["X", "W"] # TODO materialize for DB
            t4.at "X" . to_vector . should_equal [2, 2, 3]
            t4.at "Z" . to_vector . should_equal [2, 2, 3]
            t4.at "Y" . to_vector . should_equal [5, 5, 6]
            t4.at "W" . to_vector . should_equal [4, 6, 5]

        Test.specify "should allow to perform all kinds of joins" <|
            t3 = t1.join t2 join_kind=Join_Kind.Full . order_by ["X", "W"]
            expect_column_names ["X", "Y", "Z", "W"] t3
            t3.at "X" . to_vector . should_equal [Nothing, 1, 2, 2, 3]
            t3.at "Y" . to_vector . should_equal [Nothing, 4, 5, 5, 6]
            t3.at "Z" . to_vector . should_equal [4, Nothing, 2, 2, 3]
            t3.at "W" . to_vector . should_equal [7, Nothing, 4, 6, 5]

            t4 = t1.join t2 join_kind=Join_Kind.Left_Outer . order_by ["X", "W"]
            expect_column_names ["X", "Y", "Z", "W"] t4
            t4.at "X" . to_vector . should_equal [1, 2, 2, 3]
            t4.at "Y" . to_vector . should_equal [4, 5, 5, 6]
            t4.at "Z" . to_vector . should_equal [Nothing, 2, 2, 3]
            t4.at "W" . to_vector . should_equal [Nothing, 4, 6, 5]

            t5 = t1.join t2 join_kind=Join_Kind.Right_Outer . order_by ["X", "W"]
            expect_column_names ["X", "Y", "Z", "W"] t5
            t5.at "X" . to_vector . should_equal [Nothing, 2, 2, 3]
            t5.at "Y" . to_vector . should_equal [Nothing, 5, 5, 6]
            t5.at "Z" . to_vector . should_equal [4, 2, 2, 3]
            t5.at "W" . to_vector . should_equal [7, 4, 6, 5]

        Test.specify "should allow to perform anti-joins" <|
            t6 = t1.join t2 join_kind=Join_Kind.Left_Exclusive . order_by ["X"]
            t6.columns.map .name . should_equal ["X", "Y"]
            t6.at "X" . to_vector . should_equal [1]
            t6.at "Y" . to_vector . should_equal [4]

            t7 = t1.join t2 join_kind=Join_Kind.Right_Exclusive . order_by ["Z"]
            t7.columns.map .name . should_equal ["Z", "W"]
            t7.at "Z" . to_vector . should_equal [4]
            t7.at "W" . to_vector . should_equal [7]

        Test.specify "should allow to join on equality of multiple columns and drop redundant columns" <|
            t1 = table_builder [["X", [1, 1, 1, 2, 2, 2]], ["Y", ["A", "B", "B", "C", "C", "A"]], ["Z", [1, 2, 3, 4, 5, 6]]]
            t2 = table_builder [["X", [1, 1, 3, 2, 2, 4]], ["Y", ["B", "B", "C", "C", "D", "A"]], ["Z", [1, 2, 3, 4, 5, 6]]]

            conditions = [Join_Condition.Equals "Y" "Y", Join_Condition.Equals "X" "X"]
            # TODO later we'll want `Right_Z` instead of `Z_1`
            t3 = t1.join t2 on=conditions . order_by ["X", "Y", "Z", "Z_1"]
            expect_column_names ["X", "Y", "Z", "Z_1"] t3
            t3.at "X" . to_vector . should_equal [1, 1, 1, 1, 2, 2]
            t3.at "Y" . to_vector . should_equal ["B", "B", "B", "B", "C", "C"]
            t3.at "Z" . to_vector . should_equal [2, 2, 3, 3, 4, 5]
            t3.at "Z_1" . to_vector . should_equal [1, 2, 1, 2, 4, 4]

        Test.specify "should gracefully handle unmatched columns in Join_Conditions" <|
            t1 = table_builder [["X", [1, 2]], ["Y", [3, 4]]]
            t2 = table_builder [["Z", [2, 1]], ["W", [5, 6]]]

            conditions = [Join_Condition.Equals "foo" 42, Join_Condition.Equals "X" -3, Join_Condition.Equals -1 "baz"]

            action = t1.join t2 on=conditions on_problems=_
            tester table =
                expect_column_names ["X", "Y", "Z", "W"] table
                table.row_count . should_equal 0
                table.at "X" . to_vector . should_equal []
            problems = [Column_Indexes_Out_Of_Range_Data [42, -3], Missing_Input_Columns_Data ["foo", "baz"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should rename columns of the right table to avoid duplicates" <|
            t1 = table_builder [["X", [1, 2]], ["Y", [3, 4]]]
            t2 = table_builder [["X", [2, 1]], ["Y", [2, 2]]]

            # TODO this should be Right_X, Right_Y instead of X_1, Y_1 once implemented properly
            t3 = t1.join t2 on=(Join_Condition.Equals "X" "Y") . order_by ["X_1"]
            expect_column_names ["X", "Y", "X_1", "Y_1"] t3
            t3.at "X" . to_vector . should_equal [2, 2]
            t3.at "Y_1" . to_vector . should_equal [2, 2]
            t3.at "Y" . to_vector . should_equal [4, 4]
            t3.at "X_1" . to_vector . should_equal [1, 2]

            t4 = table_builder [["Right_X", [1, 1]], ["X", [1, 2]], ["Y", [3, 4]], ["Right_Y_2", [2, 2]]]
            t5 = table_builder [["Right_X", [2, 1]], ["X", [2, 2]], ["Y", [2, 2]], ["Right_Y", [2, 2]], ["Right_Y_1", [2, 2]], ["Right_Y_4", [2, 2]]]

            t6 = t4.join t5 on=(Join_Condition.Equals "X" "Y")
            # TODO specify how we really want to handle collisions, this is just a temporary solution
            expect_column_names ["Right_X", "X", "Y", "Right_Y_2"]+["Right_X_1", "X_1", "Y_1", "Right_Y", "Right_Y_1", "Right_Y_4"] t6
            # Possible solutions:
            # All existing ones have precedence over renamed ones (regardless of ordering)
            # expect_column_names ["Right_X", "X", "Y", "Right_Y_2"]+["Right_Right_X", "Right_X_1", "Right_Y", "Right_Y_1", "Right_Y_3", "Right_Y_4"] t6
            # Renames happen in the order of appearance of columns
            # expect_column_names ["Right_X", "X", "Y", "Right_Y_2"]+["Right_Right_X", "Right_X_1", "Right_Y", "Right_Y_1", "Right_Y_1_1", "Right_Y_4"] t6
