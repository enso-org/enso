from Standard.Base import all

import Standard.Base.Errors.Common.Arithmetic_Error
import Standard.Base.Errors.Common.Incomparable_Values
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Meta.Type
import Standard.Database.Data.Column.Column
import Standard.Database.Internal.Replace_Params.Replace_Params

from Standard.Table import Value_Type, Column_Ref
from Standard.Table.Data.Type.Value_Type import Bits
from Standard.Table.Errors import all

from Standard.Database.Errors import all
import Standard.Database.Data.Table.Table as Database_Table

from Standard.Test_New import all


import enso_dev.Base_Tests.Data.Round_Spec

from project.Common_Table_Operations.Util import run_default_backend

main = run_default_backend add_specs

type Data
    Value ~connection

    setup create_connection_fn = Data.Value <|
        connection = create_connection_fn Nothing
        connection

    teardown self =
        self.connection.close

type Arithmetic_Data
    Value ~data

    connection self = self.data.at 0
    x self = self.data.at 1
    y self = self.data.at 2

    setup create_connection_fn table_builder = Arithmetic_Data.Value <|
        connection = create_connection_fn Nothing
        t2 = table_builder [["x", [1, 4, 5, Nothing]], ["y", [2.0, 3.25, 5.0, Nothing]]] connection=connection
        x = t2.at "x"
        y = t2.at "y"
        [connection, x, y]

    teardown self =
        self.connection.close

type Min_Max_Data
    Value ~data

    connection self = self.data.at 0
    a self = self.data.at 1
    b self = self.data.at 2
    c self = self.data.at 3
    t self = self.data.at 4

    setup create_connection_fn table_builder = Min_Max_Data.Value <|
        connection = create_connection_fn Nothing
        t = table_builder [["a", [1, 2, 3]], ["b", [4.5, 5.5, 6.5]], ["c", ['a', 'b', 'c']], ["d", [True, False, True]]] connection=connection
        a = t.at "a"
        b = t.at "b"
        c = t.at "c"
        [connection, a, b, c, t]

    teardown self =
        drop_table self.connection self.t
        self.connection.close

type Literal_Data
    Value ~data
    
    connection self = self.data.at 0
    col0 self = self.data.at 1
    col1 self = self.data.at 2
    
    setup create_connection_fn table_builder = Literal_Data.Value <|
        connection = create_connection_fn Nothing
        col0 = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO']]] . at "x"
        col1 = table_builder [["x", ['a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']]] . at "x"
        [connection, col0, col1]
    
    teardown self =
        self.connection.close

type Replace_Data
    Value ~data
    
    connection self = self.data.at 0
    col self = self.data.at 1
    patterns self = self.data.at 2
    replacements self = self.data.at 3
    
    setup create_connection_fn table_builder = Replace_Data.Value <|
        connection = create_connection_fn Nothing
        table = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO', 'a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']], ["patterns", ['hello', 'hello', 'hello', 'a[bcd]', 'a[bcd]']], ["replacements", ['bye', 'bye', 'bye', 'hey', 'hey']]]
        col = table.at "x"
        patterns = table.at "patterns"
        replacements = table.at "replacements"
        [connection, col, patterns, replacements]
    
    teardown self =
        self.connection.close


type Text_Replace_Data
    Value ~data

    connection self = self.data.at 0
    a self = self.data.at 1
    b self = self.data.at 2
    c self = self.data.at 3
    d self = self.data.at 4

    setup create_connection_fn table_builder = Text_Replace_Data.Value <|
        connection = create_connection_fn Nothing
        t4 = table_builder [["A", ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]], ["B", ["A","O","a","E","o","O"]], ["C", [1,2,3,4,5,6]], ["D", ['',Nothing,'',Nothing,'','']]] connection=connection
        a = t4.at "A"
        b = t4.at "B"
        c = t4.at "C"
        d = t4.at "D"
        [connection, a, b, c, d]

    teardown self =
        self.connection.close


type Trim_Data
    Value ~data

    connection self = self.data.at 0
    a self = self.data.at 1
    b self = self.data.at 2
    c self = self.data.at 3

    setup create_connection_fn table_builder = Trim_Data.Value <|
        connection = create_connection_fn Nothing
        table = table_builder [["A", [" A ", ' \t\n\rA\r\n\t ', "xxxAxx"]], ["B", [" ",' \t',"x"]], ["C", [1,2,3]]]
        a = table.at "A"
        b = table.at "B"
        c = table.at "C"

        [connection, a, b, c]

    teardown self =
        self.connection.close


type Names_Data
    Value ~data

    connection self = self.data.at 0
    t self = self.data.at 1

    setup create_connection_fn table_builder = Names_Data.Value <|
        connection = create_connection_fn Nothing
        t = table_builder [["a", [1, 2, 3]], ["b", ['x', 'y', 'z']], ["c", [1.0, 2.0, 3.0]], ["d", [True, False, True]]]
        [connection, t]

    teardown self =
        self.connection.close


add_specs suite_builder setup =
    prefix = setup.prefix
    create_connection_fn = setup.create_connection_func
    pending_datetime = if setup.test_selection.date_time.not then "Date/Time operations are not supported by this backend."

    suite_builder.group prefix+"Rounding numeric tests" group_builder->
        data = Data.setup create_connection_fn

        do_op n op =
            table = setup.table_builder [["x", [n]]] connection=data.connection
            result = table.at "x" |> op
            result.to_vector.at 0

        do_round n dp=0 use_bankers=False = do_op n (_.round dp use_bankers)

        Round_Spec.add_specs group_builder do_round

    ## Runs the provided callback with a few combinations of columns, where some
       of them are made Mixed (but still contain only the original values).
       If the backend does not support mixed columns, the callback is run only
       once.
       Note that this is called exponentially many times with the number of
       columns, so the number of columns given to this function must be limited.
    with_mixed_columns_if_supported table_structure callback =
        if table_structure.length > 3 then
            Panic.throw (Illegal_Argument.Error "with_mixed_columns_if_supported: Too many columns.")
        if table_structure.length == 0 then
            Panic.throw (Illegal_Argument.Error "with_mixed_columns_if_supported: No columns provided.")
        callback_with_clue table =
            clue = table.columns.map (c-> c.name + "->" + c.value_type.to_display_text) . join ", " "{Table: " "} "
            Test.with_clue clue <|
                callback table
        case setup.test_selection.supports_mixed_columns of
            False -> callback_with_clue (setup.table_builder table_structure)
            True ->
                all_combinations (Vector.fill table_structure.length [Nothing, Mixed_Type_Object.Value]) . each combination->
                    amended_table_structure = table_structure.zip combination column_definition-> prefix->
                        name = column_definition.first
                        values = column_definition.second
                        [name, [prefix]+values]
                    mixed_table = setup.table_builder amended_table_structure
                    aligned_table = mixed_table.drop 1
                    callback_with_clue aligned_table

    suite_builder.group prefix+"Boolean Column Operations" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "iif" <|
            t = table_builder [["X", [True, False, Nothing, True]]]
            c1 = t.at "X" . iif 22 33
            c1.to_vector . should_equal [22, 33, Nothing, 22]
            c1.value_type . is_integer . should_be_true

            c2 = t.at "X" . iif 22 33.0
            c2.to_vector . should_equal [22, 33, Nothing, 22]
            c2.value_type . is_floating_point . should_be_true

            c3 = t.at "X" . iif "A" "B"
            c3.to_vector . should_equal ["A", "B", Nothing, "A"]
            c3.value_type . is_text . should_be_true

            c4 = t.at "X" . iif Nothing "B"
            c4.to_vector . should_equal [Nothing, "B", Nothing, Nothing]
            c4.value_type . is_text . should_be_true

            c5 = t.at "X" . iif 42 Nothing
            c5.to_vector . should_equal [42, Nothing, Nothing, 42]
            c5.value_type . is_integer . should_be_true

            c6 = t.at "X" . iif Nothing Nothing
            c6.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

            t.at "X" . iif 22.0 False . should_fail_with No_Common_Type
            t.at "X" . iif 22 "0" . should_fail_with No_Common_Type

        group_builder.specify "iif on Columns" <|
            with_mixed_columns_if_supported [["X", [True, False, Nothing, False]], ["Y", [1, 2, 3, 4]], ["Z", [1.5, 2.0, 3.5, 4.0]]] t1->
                c1 = t1.at "X" . iif (t1.at "Y") (t1.at "Z")
                c1.to_vector . should_equal [1, 2.0, Nothing, 4.0]
                is_mixed = (t1.at "Y" . value_type == Value_Type.Mixed) || (t1.at "Z" . value_type == Value_Type.Mixed)
                case is_mixed of
                    True  -> c1.value_type . should_equal Value_Type.Mixed
                    False -> c1.value_type.is_floating_point . should_be_true

            with_mixed_columns_if_supported [["X", [True, False]], ["Y", [1, 2]], ["Z", [1.5, 3.0]]] t2->
                c2 = t2.at "X" . iif (t2.at "Y") (t2.at "Z")
                c2.to_vector . should_equal [1, 3]
                is_mixed = (t2.at "Y" . value_type == Value_Type.Mixed) || (t2.at "Z" . value_type == Value_Type.Mixed)
                case is_mixed of
                    True  -> c2.value_type . should_equal Value_Type.Mixed
                    False -> c2.value_type.is_floating_point . should_be_true

            with_mixed_columns_if_supported [["X", [True, False]], ["Y", [10, 20]], ["Z", [False, True]]] t3->
                is_y_mixed = t3.at "Y" . value_type == Value_Type.Mixed
                is_any_mixed = is_y_mixed || (t3.at "Z" . value_type == Value_Type.Mixed)
                c1 = t3.at "X" . iif (t3.at "Y") (t3.at "Z")
                case is_any_mixed of
                    True ->
                        c1.value_type . should_equal Value_Type.Mixed
                        c1.to_vector . should_equal [10, True]
                    False -> c1.should_fail_with No_Common_Type
                c2 = t3.at "X" . iif (t3.at "Y") "<NA>"
                case is_y_mixed of
                    True ->
                        c2.value_type . should_equal Value_Type.Mixed
                        c2.to_vector . should_equal [10, "<NA>"]
                    False -> c2.should_fail_with No_Common_Type

        group_builder.specify "iif should correctly unify text columns of various lengths" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
            t0 = table_builder [["x", [False, True, False]], ["A", ["a", "b", "c"]], ["B", ["xyz", "abc", "def"]]]
            t1 = t0 . cast "A" (Value_Type.Char size=1 variable_length=False) . cast "B" (Value_Type.Char size=3 variable_length=False)

            x = t1.at "x"
            a = t1.at "A"
            b = t1.at "B"
            a.value_type.should_equal (Value_Type.Char size=1 variable_length=False)
            b.value_type.should_equal (Value_Type.Char size=3 variable_length=False)

            c = x.iif a b
            c.to_vector.should_equal ["xyz", "b", "def"]
            Test.with_clue "c.value_type="+c.value_type.to_display_text+": " <|
                c.value_type.variable_length.should_be_true

            d = b.cast (Value_Type.Char size=1 variable_length=False)
            e = x.iif a d
            e.to_vector.should_equal ["x", "b", "d"]
            e.value_type.should_equal (Value_Type.Char size=1 variable_length=False)

            f = b.cast (Value_Type.Char size=1 variable_length=True)
            g = x.iif a f
            g.to_vector.should_equal ["x", "b", "d"]
            Test.with_clue "g.value_type="+g.value_type.to_display_text+": " <|
                g.value_type.variable_length.should_be_true

        group_builder.specify "should allow to compute &&, || and not" <|
            with_mixed_columns_if_supported [["X", [True, False, True]], ["Y", [True, False, False]]] t->
                x = t.at "X"
                y = t.at "Y"
                (x || False).to_vector . should_equal [True, False, True]
                (x || True).to_vector . should_equal [True, True, True]
                (x || y).to_vector . should_equal [True, False, True]
                (x && False).to_vector . should_equal [False, False, False]
                (x && True).to_vector . should_equal [True, False, True]
                (x && y).to_vector . should_equal [True, False, False]
                (x || y.not).to_vector . should_equal [True, True, True]

        group_builder.specify "should handle nulls correctly in not" <|
            t = table_builder [["A", [True, False, Nothing]]]
            a = t.at "A"
            a_not = a.not
            a_not.to_vector . should_equal [False, True, Nothing]

        group_builder.specify "should handle nulls correctly in &&" <|
            t = table_builder [["A", [True, True, True, False, False, False, Nothing, Nothing, Nothing]], ["B", [True, False, Nothing, True, False, Nothing, True, False, Nothing]]]
            a = t.at "A"
            (a && True).to_vector . should_equal [True, True, True, False, False, False, Nothing, Nothing, Nothing]
            (a && False).to_vector . should_equal [False, False, False, False, False, False, False, False, False]
            (a && Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, False, False, False, Nothing, Nothing, Nothing]

            a_not = a.not
            (a_not && True).to_vector . should_equal [False, False, False, True, True, True, Nothing, Nothing, Nothing]
            (a_not && False).to_vector . should_equal [False, False, False, False, False, False, False, False, False]
            (a_not && Nothing).to_vector . should_equal [False, False, False, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]

            b = t.at "B"
            (a && b).to_vector . should_equal [True, False, Nothing, False, False, False, Nothing, False, Nothing]
            (a_not && b).to_vector . should_equal [False, False, False, True, False, Nothing, Nothing, False, Nothing]

        group_builder.specify "should handle nulls correctly in ||" <|
            t = table_builder [["A", [True, True, True, False, False, False, Nothing, Nothing, Nothing]], ["B", [True, False, Nothing, True, False, Nothing, True, False, Nothing]]]
            a = t.at "A"
            (a || True).to_vector . should_equal [True, True, True, True, True, True, True, True, True]
            (a || False).to_vector . should_equal [True, True, True, False, False, False, Nothing, Nothing, Nothing]
            (a || Nothing).to_vector . should_equal [True, True, True, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]

            a_not = a.not
            (a_not || True).to_vector . should_equal [True, True, True, True, True, True, True, True, True]
            (a_not || False).to_vector . should_equal [False, False, False, True, True, True, Nothing, Nothing, Nothing]
            (a_not || Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, True, True, True, Nothing, Nothing, Nothing]

            b = t.at "B"
            (a || b).to_vector . should_equal [True, True, True, True, False, Nothing, True, Nothing, Nothing]
            (a_not || b).to_vector . should_equal [True, False, Nothing, True, True, True, True, Nothing, Nothing]

        group_builder.specify "should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']], ["Z", [True, False, Nothing]]]

            ((t.at "X") && (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") && (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") && True) . should_fail_with Invalid_Value_Type

            ((t.at "X") || (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") || (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") || True) . should_fail_with Invalid_Value_Type

            ((t.at "X") . not) . should_fail_with Invalid_Value_Type
            ((t.at "Y") . iif 10 20) . should_fail_with Invalid_Value_Type

    suite_builder.group prefix+"Column Operations - Equality & Null Handling" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should provide basic == and != comparisons" pending="TODO figure out proper null handling" <|
            with_mixed_columns_if_supported [["x", [1, 4, 5, Nothing]], ["y", [2.0, 3.25, 5.0, Nothing]]] t2->
                x = t2.at "x"
                y = t2.at "y"
                (x == y).to_vector . should_equal [False, False, True, Nothing]
                (x != y).to_vector . should_equal [True, True, False, Nothing]
                (x == 4).to_vector . should_equal [False, True, False, Nothing]
                (x == Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

        group_builder.specify "should allow to check which values are null" <|
            with_mixed_columns_if_supported [["x", [1, 4, 5, Nothing]]] t->
                x = t.at "x"
                x.is_nothing.to_vector . should_equal [False, False, False, True]
                (x + Nothing).is_nothing.to_vector . should_equal [True, True, True, True]
                x.is_present.to_vector . should_equal [True, True, True, False]
                (x + Nothing).is_present.to_vector . should_equal [False, False, False, False]

        group_builder.specify "Column equality should handle nulls correctly" pending="TODO" <|
            a = [2, 3, Nothing, Nothing]
            b = [2, 4, Nothing, 5]
            r = [True, False, True, False]
            a.zip b (==) . should_equal r

            t = table_builder [["A", a], ["B", b]]
            c = (t.at "A") == (t.at "B")
            c.to_vector . should_equal r
            c.value_type.should_equal Value_Type.Boolean

        group_builder.specify "equals_ignore_case for ASCII strings" <|
            x = ["a", "B", "c", "DEF"]
            y = ["aa", "b", "c", "dEf"]
            r = [False, True, True, True]

            x.zip y (.equals_ignore_case) . should_equal r

            with_mixed_columns_if_supported [["X", x], ["Y", y]] t->
                c = (t.at "X") . equals_ignore_case (t.at "Y")
                c.to_vector . should_equal r
                c.value_type.should_equal Value_Type.Boolean
                (t.at "X") . equals_ignore_case "Def" . to_vector . should_equal [False, False, False, True]

        group_builder.specify "equals_ignore_case should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']]]

            r1 = (t.at "X") . equals_ignore_case (t.at "Y") . to_vector
            r1.should_fail_with Invalid_Value_Type

            r2 = (t.at "Y") . equals_ignore_case (t.at "X") . to_vector
            r2.should_fail_with Invalid_Value_Type

            r3 = (t.at "Y") . equals_ignore_case 42 . to_vector
            r3.should_fail_with Invalid_Value_Type

        group_builder.specify "Text Column equality (including case-insensitive) should handle nulls correctly" pending="TODO" <|
            a = ["Z", "a", "b", Nothing, Nothing]
            b = ["Z", "A", "C", Nothing, "d"]
            r_sensitive   = [True, False, False, True, False]
            r_insensitive = [True, True,  False, True, False]

            a.zip b (==) . should_equal r_sensitive
            a.zip b (x-> y-> if x.is_nothing || y.is_nothing then x == y else x.equals_ignore_case y) . should_equal r_insensitive

            t = table_builder [["A", a], ["B", b]]
            ((t.at "A") == (t.at "B")) . to_vector . should_equal r_sensitive
            ((t.at "A").equals_ignore_case (t.at "B")) . to_vector . should_equal r_insensitive

        group_builder.specify "should report a warning if checking equality on floating point columns" <|
            t = table_builder [["X", [1.0, 2.1, 3.2]], ["Y", [1.0, 2.0, 3.2]]]

            r1 = (t.at "X") == (t.at "Y")
            r1.to_vector . should_equal [True, False, True]
            Problems.expect_warning Floating_Point_Equality r1

            r2 = (t.at "X") != (t.at "Y")
            r2.to_vector . should_equal [False, True, False]
            Problems.expect_warning Floating_Point_Equality r2

    suite_builder.group prefix+"Column.fill_nothing/empty" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should allow to fill_nothing from a value" <|
            col = table_builder [["col", [0, Nothing, 4, 5, Nothing, Nothing]]] . at "col"
            default = 300
            r = col.fill_nothing default
            r.to_vector . should_equal [0, 300, 4, 5, 300, 300]
            r.name . should_equal "col"

        group_builder.specify "should allow to fill_nothing from another column" <|
            t = table_builder [["col", [0, Nothing, 4, 5, Nothing, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            r = t.at "col" . fill_nothing (t.at "def")
            r.to_vector . should_equal [0, 2, 4, 5, Nothing, 30]
            r.name . should_equal "col"

        group_builder.specify "should allow to fill_empty from a value" <|
            col = table_builder [["col", ["0", Nothing, "4", "5", Nothing, Nothing]]] . at "col"
            default = "default"
            r = col.fill_empty default
            r.to_vector . should_equal ["0", "default", "4", "5", "default", "default"]
            r.name . should_equal "col"

        group_builder.specify "should allow to fill_empty from another column" <|
            t = table_builder [["col", ["0", Nothing, "4", "5", Nothing, Nothing]], ["def", ["1", "2", "10", "20", Nothing, "30"]]]
            r = t.at "col" . fill_nothing (t.at "def")
            r.to_vector . should_equal ["0", "2", "4", "5", Nothing, "30"]
            r.name . should_equal "col"

    suite_builder.group prefix+"Table.fill_nothing/empty" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should allow to fill_nothing from a value" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]]]
            default = 1000
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
        
        group_builder.specify "should allow to fill_nothing from larger string and expands type to fit" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]]] . cast "col0" (Value_Type.Char size=1 variable_length=False)
            actual = t.fill_nothing ["col0"] "ABCDE"
            actual.at "col0" . to_vector . should_equal ["0", "ABCDE", "4", "5", "ABCDE", "ABCDE"]
            case setup.test_selection.length_restricted_text_columns of
                True -> actual.at "col0" . value_type . should_equal (Value_Type.Char size=5 variable_length=True)
                False -> actual.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)

        group_builder.specify "should allow to fill_nothing from an empty string" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]]]
            actual = t.fill_nothing ["col0", "col1"] ""
            actual.at "col0" . to_vector . should_equal ["0", "", "4", "5", "", ""]
            actual.at "col1" . to_vector . should_equal ["", "200", "", "400", "500", ""]

        group_builder.specify "should allow to fill_nothing a fixed width from an empty string" <|
            t = table_builder [["col0", [Nothing, "200", Nothing, "400", "500", Nothing]]] . cast "col0" (Value_Type.Char size=3 variable_length=False)
            actual = t.fill_nothing ["col0"] ""
            actual.at "col0" . to_vector . should_equal ["", "200", "", "400", "500", ""]  
            case setup.test_selection.length_restricted_text_columns of
                True -> actual.at "col0" . value_type . should_equal (Value_Type.Char size=3 variable_length=True)
                False -> actual.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)
        
        group_builder.specify "should allow to fill_nothing a fixed width of width 1 correctly expanding ouptut types" <|
            t = table_builder [["col0", ["a", Nothing, " "]]] . cast "col0" (Value_Type.Char size=1 variable_length=False)
            fillBlank = t.fill_nothing ["col0"] ""
            fillOneSpace = t.fill_nothing ["col0"] " "
            fillTwoSpaces = t.fill_nothing ["col0"] "  "
            case setup.test_selection.length_restricted_text_columns of
                True -> fillBlank.at "col0" . value_type . should_equal (Value_Type.Char size=1 variable_length=True)
                    fillOneSpace.at "col0" . value_type . should_equal (Value_Type.Char size=1 variable_length=False)
                    fillTwoSpaces.at "col0" . value_type . should_equal (Value_Type.Char size=2 variable_length=True)
                False -> fillBlank.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)
                    fillOneSpace.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)
                    fillTwoSpaces.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)
            
            case setup.test_selection.removes_trailing_whitespace_casting_from_char_to_varchar of
                True -> fillBlank.at "col0" . to_vector . should_equal ["a", "", ""]
                False -> fillBlank.at "col0" . to_vector . should_equal ["a", "", " "]

            fillOneSpace.at "col0" . to_vector . should_equal ["a", " ", " "]
                   
            case setup.test_selection.removes_trailing_whitespace_casting_from_char_to_varchar of
                True -> fillTwoSpaces.at "col0" . to_vector . should_equal ["a", "", ""]
                False -> fillTwoSpaces.at "col0" . to_vector . should_equal ["a", "  ", " "]
                
        group_builder.specify "should allow to fill_nothing a fixed width with a string of correct length without changing the type" <|
            t = table_builder [["col0", [Nothing, "200", Nothing, "400", "500", Nothing]]] . cast "col0" (Value_Type.Char size=3 variable_length=False)
            actual = t.fill_nothing ["col0"] "   "
            actual.at "col0" . to_vector . should_equal ["   ", "200", "   ", "400", "500", "   "]  
            case setup.test_selection.fixed_length_text_columns of
                True -> actual.at "col0" . value_type . should_equal (Value_Type.Char size=3 variable_length=False)
                False -> actual.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)

        group_builder.specify "should allow to fill_nothing from other columns" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            actual = t.fill_nothing ["col0", "col1"] (t.at "def")
            actual.at "col0" . to_vector . should_equal [0, 2, 4, 5, Nothing, 30]
            actual.at "col1" . to_vector . should_equal [1, 200, 10, 400, 500, 30]

        group_builder.specify "should allow to fill_empty from a value" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]]]
            default = "1000"
            actual = t.fill_empty ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal ["0", "1000", "4", "5", "1000", "1000"]
            actual.at "col1" . to_vector . should_equal ["1000", "200", "1000", "400", "500", "1000"]

        group_builder.specify "should allow to fill_empty from other columns" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]], ["def", ["1", "2", "10", "20", Nothing, "30"]]]
            actual = t.fill_empty ["col0", "col1"] (t.at "def")
            actual.at "col0" . to_vector . should_equal ["0", "2", "4", "5", Nothing, "30"]
            actual.at "col1" . to_vector . should_equal ["1", "200", "10", "400", "500", "30"]

        group_builder.specify "fill_nothing should leave other columns alone" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

        group_builder.specify "fill_nothing should work with integer column selectors" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing [0, 2] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

    suite_builder.group prefix+"Table.text_replace" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should allow to replace values in a table" <|
            with_mixed_columns_if_supported [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]]] t->
                actual = t.text_replace ["col0", "col1"] "ab" "xy"
                actual.at "col0" . to_vector . should_equal ["xyc", "def", "ghi"]
                actual.at "col1" . to_vector . should_equal ["nxyc", "ndef", "asdf"]

        group_builder.specify "should allow to replace values in a table with a regex" <|
            t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]]]
            actual = t.text_replace ["col0", "col1"] "[bdi]".to_regex "xy"
            case actual.is_error && setup.is_database of
                True ->
                    actual.should_fail_with Unsupported_Database_Operation
                False ->
                    actual.at "col0" . to_vector . should_equal ["axyc", "xyef", "ghxy"]
                    actual.at "col1" . to_vector . should_equal ["naxyc", "nxyef", "asxyf"]

        group_builder.specify "should allow to replace values in a table with a column" <|
            t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]], ["col2", ["xy", "yx", "zz"]]]
            actual = t.text_replace ["col0", "col1"] "[bdi]".to_regex (t.at "col2")
            case actual.is_error && setup.is_database of
                True ->
                    actual.should_fail_with Unsupported_Database_Operation
                False ->
                    actual.at "col0" . to_vector . should_equal ["axyc", "yxef", "ghzz"]
                    actual.at "col1" . to_vector . should_equal ["naxyc", "nyxef", "aszzf"]
                    actual.at "col2" . to_vector . should_equal ["xy", "yx", "zz"]

        group_builder.specify "should allow to use Column_Ref in replace" <|
            t = table_builder [["txt", ["abc", "def", "ghi"]], ["term", ["b", "d", "i"]], ["new", ["X", "Y", "Z"]]]
            t1 = t.text_replace "txt" (Column_Ref.Name "term") (Column_Ref.Name "new")
            case t1.is_error && setup.is_database of
                True ->
                    t1.should_fail_with Unsupported_Database_Operation
                False ->
                    t1.at "txt" . to_vector . should_equal ["aXc", "Yef", "ghZ"]

    suite_builder.group prefix+"Column Comparisons" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should allow to compare numbers" <|
            with_mixed_columns_if_supported [["x", [1, 4, 5, Nothing]], ["y", [2.0, 3.25, 5.0, Nothing]]] t2->
                x = t2.at "x"
                y = t2.at "y"
                x.inferred_precise_value_type . is_integer . should_be_true
                y.inferred_precise_value_type . is_floating_point . should_be_true

                (x < y).to_vector . should_equal [True, False, False, Nothing]
                (x <= y).to_vector . should_equal [True, False, True, Nothing]
                (x > y).to_vector . should_equal (x <= y).not.to_vector
                (x >= y).to_vector . should_equal (x < y).not.to_vector

                (x < 1000).to_vector . should_equal [True, True, True, Nothing]

                [(<), (<=), (>), (>=)].each op->
                    op x y . value_type . should_equal Value_Type.Boolean
                    op x y . to_vector . should_succeed
                    op x 23 . to_vector . should_succeed
                    op y 23 . to_vector . should_succeed
                    op x 1.5 . to_vector . should_succeed

        group_builder.specify "should allow to compare texts" <|
            t0 = table_builder [["X", ["a", "b", "c"]], ["Y", ["a", "b", "d"]]]
            t = t0.cast "X" (Value_Type.Char size=1 variable_length=False)

            [(<), (<=), (>), (>=)].each op->
                op (t.at "X") (t.at "Y") . value_type . should_equal Value_Type.Boolean
                op (t.at "X") (t.at "Y") . to_vector . should_succeed
                op (t.at "X") "abc" . to_vector . should_succeed

        group_builder.specify "should allow to compare booleans" <|
            t = table_builder [["X", [True, False, True]], ["Y", [False, True, True]]]

            ((t.at "X") < (t.at "Y")).to_vector . should_equal [False, True, False]
            ((t.at "X") >= (t.at "Y")).to_vector . should_equal [True, False, True]
            ((t.at "X") <= (t.at "Y")).to_vector . should_equal [False, True, True]
            ((t.at "X") > (t.at "Y")).to_vector . should_equal [True, False, False]

            ((t.at "X") < True).to_vector . should_equal [False, True, False]
            ((t.at "X") >= True).to_vector . should_equal [True, False, True]
            ((t.at "X") <= True).to_vector . should_equal [True, True, True]
            ((t.at "X") > True).to_vector . should_equal [False, False, False]

        group_builder.specify "should report error if incomparable types are compared" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]

            [(<), (<=), (>), (>=)].each op->
                r1 = op (t.at "X") (t.at "Y")
                r1.should_fail_with Invalid_Value_Type
                r1.catch . should_be_a Invalid_Value_Type.Incomparable

                op (t.at "X") "FOO" . should_fail_with Invalid_Value_Type
                op (t.at "Y") 42 . should_fail_with Invalid_Value_Type
                op (t.at "Y") False . should_fail_with Invalid_Value_Type
                op (t.at "Z") 32 . should_fail_with Invalid_Value_Type
                op (t.at "Z") (t.at "X") . should_fail_with Invalid_Value_Type

        if setup.test_selection.supports_mixed_columns then
            group_builder.specify "should allow comparing Mixed columns" <|
                t1 = table_builder [["X", ["a", 23]], ["Y", ["b", 1]]]
                ((t1.at "X") == (t1.at "Y")) . to_vector . should_equal [False, False]
                ((t1.at "X") <= (t1.at "Y")) . to_vector . should_equal [True, False]
                ((t1.at "X") > (t1.at "Y")) . to_vector . should_equal [False, True]

                t1_2 = table_builder [["X", [1, "2"]], ["Y", ["b", 1]]]
                ((t1_2.at "X") == (t1_2.at "Y")) . to_vector . should_equal [False, False]
                ((t1_2.at "X") <= (t1_2.at "Y")) . to_vector . should_fail_with Incomparable_Values

                t2 = table_builder [["X", [1, 2]], ["Y", ["b", 1]]]
                ((t2.at "X") == (t2.at "Y")) . to_vector . should_equal [False, False]
                ((t2.at "X") <= (t2.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t2.at "Y") > (t2.at "X")) . to_vector . should_fail_with Incomparable_Values

                t3 = table_builder [["X", [1.0, 2.0]], ["Y", ["b", 1]]]
                ((t3.at "X") == (t3.at "Y")) . to_vector . should_equal [False, False]
                ((t3.at "X") <= (t3.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t3.at "Y") > (t3.at "X")) . to_vector . should_fail_with Incomparable_Values

                t4 = table_builder [["X", ["a", "b"]], ["Y", ["b", 1]]]
                ((t4.at "X") == (t4.at "Y")) . to_vector . should_equal [False, False]
                ((t4.at "X") <= (t4.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t4.at "Y") > (t4.at "X")) . to_vector . should_fail_with Incomparable_Values

                t5 = table_builder [["X", [Date.new 2022, Date.new 2019]], ["Y", ["b", 1]]]
                ((t5.at "X") == (t5.at "Y")) . to_vector . should_equal [False, False]
                ((t5.at "X") <= (t5.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t5.at "Y") > (t5.at "X")) . to_vector . should_fail_with Incomparable_Values

                t6 = table_builder [["X", [Time_Of_Day.new 21, Time_Of_Day.new 22]], ["Y", ["b", 1]]]
                ((t6.at "X") == (t6.at "Y")) . to_vector . should_equal [False, False]
                ((t6.at "X") <= (t6.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t6.at "Y") > (t6.at "X")) . to_vector . should_fail_with Incomparable_Values

                t7 = table_builder [["X", [Date_Time.new 2022, Date_Time.new 2019]], ["Y", ["b", 1]]]
                ((t7.at "X") == (t7.at "Y")) . to_vector . should_equal [False, False]
                ((t7.at "X") <= (t7.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t7.at "Y") > (t7.at "X")) . to_vector . should_fail_with Incomparable_Values

        group_builder.specify "Between should return null if any of the values are null" pending="TODO" <|
            a = [2, 3, Nothing, 7,       5,       Nothing]
            b = [0, 5, 7,       Nothing, 7,       Nothing]
            c = [9, 8, 7,       7,       Nothing, Nothing]
            r = [True, False, Nothing, Nothing, Nothing, Nothing]

            t = table_builder [["A", a], ["B", b], ["C", c]]
            ((t.at "A").between (t.at "B") (t.at "C")) . to_vector . should_equal r

    suite_builder.group prefix+"Arithmetic Column Operations" group_builder->
        data = Arithmetic_Data.setup create_connection_fn setup.table_builder

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should allow basic operations" <|
            (data.x + data.y).to_vector . should_equal [3, 7.25, 10, Nothing]
            (data.x - data.y).to_vector . should_equal [-1.0, 0.75, 0.0, Nothing]
            (data.x * data.y).to_vector . should_equal [2.0, 13.0, 25.0, Nothing]

        group_builder.specify "should allow combining a column with a scalar" <|
            (data.x + 100).to_vector . should_equal [101, 104, 105, Nothing]
            (data.x * 10).to_vector . should_equal [10, 40, 50, Nothing]
            (data.x - 10).to_vector . should_equal [-9, -6, -5, Nothing]

        group_builder.specify "should work with mixed types" <|
            with_mixed_columns_if_supported [["X", [100, 25]], ["Y", [2, 5]]] t->
                x = t.at "X"
                y = t.at "Y"
                (x + y).to_vector . should_equal [102, 30]
                (x - y).to_vector . should_equal [98, 20]
                (x * y).to_vector . should_equal [200, 125]
                (x / y).to_vector . should_equal [50, 5]
                (x % y).to_vector . should_equal [0, 0]
                (x ^ y).to_vector . should_equal [10000, 9765625]

        group_builder.specify "should correctly infer the types" <|
            (data.x + data.x).value_type . is_integer . should_be_true
            (data.x + data.y).value_type . is_floating_point . should_be_true
            (data.x + 2).value_type . is_integer . should_be_true
            (data.x + 1.5).value_type . is_floating_point . should_be_true

            (data.x - data.x).value_type . is_integer . should_be_true
            (data.x - data.y).value_type . is_floating_point . should_be_true
            (data.x - 2).value_type . is_integer . should_be_true
            (data.x - 1.5).value_type . is_floating_point . should_be_true

            (data.x * data.x).value_type . is_integer . should_be_true
            (data.x * data.y).value_type . is_floating_point . should_be_true
            (data.x * 2).value_type . is_integer . should_be_true
            (data.x * 1.5).value_type . is_floating_point . should_be_true

            (data.x ^ data.x).value_type . is_numeric . should_be_true

        group_builder.specify "should check types" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]
            x = t.at "X"
            y = t.at "Y"
            z = t.at "Z"

            (x + z) . should_fail_with Illegal_Argument
            (x + False) . should_fail_with Illegal_Argument

            # Mixing text and integers should not be allowed
            (x + y) . should_fail_with Illegal_Argument
            (x + "foo") . should_fail_with Illegal_Argument

            (x - z).should_fail_with Invalid_Value_Type
            (x - "a").should_fail_with Invalid_Value_Type
            (y - "a").should_fail_with Invalid_Value_Type
            (y - 42).should_fail_with Invalid_Value_Type

            (x * z).should_fail_with Invalid_Value_Type
            (x * "a").should_fail_with Invalid_Value_Type
            (y * "a").should_fail_with Invalid_Value_Type
            (y * 42).should_fail_with Invalid_Value_Type

            (x / z).should_fail_with Invalid_Value_Type
            (x / "a").should_fail_with Invalid_Value_Type
            (y / "a").should_fail_with Invalid_Value_Type
            (y / 42).should_fail_with Invalid_Value_Type

            (x ^ z).should_fail_with Invalid_Value_Type
            (x ^ "a").should_fail_with Invalid_Value_Type
            (y ^ "a").should_fail_with Invalid_Value_Type
            (y ^ 42).should_fail_with Invalid_Value_Type

        case setup.test_selection.is_nan_and_nothing_distinct of
            True ->
                t = table_builder [["X", [1.5, 3.0, Number.positive_infinity, Number.negative_infinity, Number.nan, Nothing]], ["Y", [1, 2, 3, 4, 5, Nothing]], ["Z", ["1", "2", "3", "4", "5", Nothing]]]

                group_builder.specify "should support is_nan" <|
                    t.at "X" . is_nan . to_vector . should_equal [False, False, False, False, True, Nothing]
                    t.at "Y" . is_nan . to_vector . should_equal [False, False, False, False, False, Nothing]
                    t.at "Z" . is_nan . to_vector . should_fail_with Invalid_Value_Type

                group_builder.specify "should support is_infinite" <|
                    t.at "X" . is_infinite . to_vector . should_equal [False, False, True, True, False, Nothing]
                    t.at "Y" . is_infinite . to_vector . should_equal [False, False, False, False, False, Nothing]
                    t.at "Z" . is_infinite . to_vector . should_fail_with Invalid_Value_Type
            False ->
                group_builder.specify "should report that is_nan is not supported" <|
                    t = table_builder [["X", [1.5]]]
                    t.at "X" . is_nan . should_fail_with Unsupported_Database_Operation

                group_builder.specify "should support is_infinite" <|
                    t = table_builder [["X", [1.5, 3.0, Number.positive_infinity, Number.negative_infinity, Nothing]], ["Y", [1, 2, 3, 4, Nothing]], ["Z", ["1", "2", "3", "4", Nothing]]]
                    t.at "X" . is_infinite . to_vector . should_equal [False, False, True, True, Nothing]
                    t.at "Y" . is_infinite . to_vector . should_equal [False, False, False, False, Nothing]
                    t.at "Z" . is_infinite . to_vector . should_fail_with Invalid_Value_Type

        group_builder.specify "should support is_blank" <|
            t = table_builder [["X", [1.5, 2, Number.nan, Nothing]], ["Y", [1, Nothing, 3, 4]]]
            t.at "X" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, False, True, True]
            t.at "Y" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, True, False, False]

        group_builder.specify "division should be aligned with the Enso arithmetic" <|
            a = [1, 5, 10, 100]
            b = [2, 2, 4, 5]
            r = [0.5, 2.5, 2.5, 20.0]
            a.zip b (/) . should_equal r

            t = table_builder [["A", a], ["B", b]]
            t.at "A" . value_type . is_integer . should_be_true
            t.at "B" . value_type . is_integer . should_be_true

            r2 = (t.at "A") / (t.at "B")
            r2 . to_vector . should_equal r
            r2.value_type . is_floating_point . should_be_true

            r3 = (t.at "A") / 2
            r3 . to_vector . should_equal [0.5, 2.5, 5.0, 50.0]
            r3.value_type . is_floating_point . should_be_true

            a2 = [1.2, 5, 10.2, 100]
            b2 = [1.2, 2, 2, 5]
            r4 = [1.0, 2.5, 5.1, 20.0]
            a2.zip b2 (/) . should_equal r4

            t2 = table_builder [["A", a2], ["B", b2]]
            t2.at "A" . value_type . is_floating_point . should_be_true
            t2.at "B" . value_type . is_floating_point . should_be_true

            r5 = (t2.at "A") / (t2.at "B")
            r5 . to_vector . should_equal r4
            r5.value_type . is_floating_point . should_be_true

            r6 = (t2.at "A") / 2
            r6 . to_vector . should_equal [0.6, 2.5, 5.1, 50.0]
            r6.value_type . is_floating_point . should_be_true

        db_pending = if setup.is_database then "Arithmetic error handling is currently not implemented for the Database backend."
        group_builder.specify "should allow division by 0 and report warnings" pending=db_pending <|
            t = table_builder [["a", [3, 1, 0]], ["b", [2, 0, 0]], ["c", [1.5, 1.5, 0.0]], ["d", [1.5, 0.0, 0.0]]]
            a = t.at "a"
            b = t.at "b"
            c = t.at "c"
            d = t.at "d"

            has_div_warnings location expected_rows result =
                Test.with_clue location <|
                    warnings = Problems.get_attached_warnings result
                    msg = "Division by zero (at rows " + expected_rows.to_text + ")."
                    warnings.first . should_equal (Arithmetic_Error.Error msg)

            r1 = a / b
            r1.to_vector.to_text . should_equal "[1.5, Infinity, NaN]"
            has_div_warnings "[a] / [b]" [1, 2] r1
            r2 = c / d
            r2.to_vector.to_text . should_equal "[1.0, Infinity, NaN]"
            has_div_warnings "[c] / [d]" [1, 2] r2
            r3 = a / d
            r3.to_vector.to_text . should_equal "[2.0, Infinity, NaN]"
            has_div_warnings "[a] / [d]" [1, 2] r3
            r4 = a / 0
            r4.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[a] / 0" [0, 1, 2] r4
            r5 = c / 0
            r5.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[c] / 0" [0, 1, 2] r5

            r6 = a % b
            r6.to_vector.to_text . should_equal "[1, Nothing, Nothing]"
            has_div_warnings "[a] % [b]" [1, 2] r6
            r7 = c % d
            r7.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[c] % [d]" [1, 2] r7
            r8 = a % d
            r8.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[a] % [d]" [1, 2] r8
            r9 = a % 0
            r9.to_vector.to_text . should_equal "[Nothing, Nothing, Nothing]"
            has_div_warnings "[a] % 0" [0, 1, 2] r9
            r10 = c % 0
            r10.to_vector.to_text . should_equal "[NaN, NaN, NaN]"
            has_div_warnings "[c] % 0" [0, 1, 2] r10

        group_builder.specify "should limit the number of rows listed in the message" pending=db_pending <|
            t1 = table_builder [["a", 0.up_to 200 . to_vector]]
            zero = t1.at "a" - t1.at "a"
            div = t1.at "a" / zero
            warnings = Problems.get_attached_warnings div
            warnings.not_empty.should_be_true
            warning = warnings.first
            warning.should_be_a Arithmetic_Error
            warning.message . should_equal "Division by zero (at rows [0, 1, 2, 3, 4, 5, 6, 7, 8, ...])."

        group_builder.specify "should return null if one of arguments is missing" <|
            nulls = [Nothing, Nothing, Nothing, Nothing]
            (data.x + Nothing).to_vector . should_equal nulls
            (data.x - Nothing).to_vector . should_equal nulls
            (data.x * Nothing).to_vector . should_equal nulls
            (data.x / Nothing).to_vector . should_equal nulls

    suite_builder.group prefix+"Rounding-like operations" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should name a rounding column correctly" <|
            table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
            table.at "x" . round . name . should_equal "round([x])"

        test_floatlike type =
            group_builder.specify "should allow round on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . round
                result.to_vector.should_equal [0, 1, 3, 4, 0, -1, -3, -4]
                result.name . should_equal "round([x])"

            group_builder.specify "should allow round on a float column (to >0 decimal places)" <|
                table = table_builder [["x", [0.51, 0.59, 3.51, 3.59, -0.51, -0.59, -3.51, -3.59]]]
                result = table.at "x" . cast type . round 1
                result.to_vector.should_equal [0.5, 0.6, 3.5, 3.6, -0.5, -0.6, -3.5, -3.6]
                result.name . should_equal "round([x])"

            group_builder.specify "should allow round on a float column (to <0 decimal places)" <|
                table = table_builder [["x", [51.2, 59.3, 351.45, 359.11, -51.2, -59.3, -351.23, -359.69]]]
                result = table.at "x" . cast type . round -1
                result.to_vector.should_equal [50.0, 60.0, 350.0, 360.0, -50.0, -60.0, -350.0, -360.0]
                result.name . should_equal "round([x])"

            group_builder.specify "should allow truncate on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . truncate
                result.to_vector.should_equal [0, 0, 3, 3, 0, 0, -3, -3]
                result.name . should_equal "truncate([x])"

            group_builder.specify "should allow ceil on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . ceil
                result.to_vector.should_equal [1, 1, 4, 4, 0, 0, -3, -3]
                result.name . should_equal "ceil([x])"

            group_builder.specify "should allow floor on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . floor
                result.to_vector.should_equal [0, 0, 3, 3, -1, -1, -4, -4]
                result.name . should_equal "floor([x])"

        test_floatlike Value_Type.Float
        if setup.test_selection.supports_decimal_type then
            test_floatlike Value_Type.Decimal

        group_builder.specify "should allow round on an int column" <|
            table = table_builder [["x", [1, 9, 31, 39, -1, -9, -31, -39]]]
            result = table.at "x" . round -1
            result.to_vector.should_equal [0, 10, 30, 40, 0, -10, -30, -40]
            result.name . should_equal "round([x])"

        group_builder.specify "should allow truncate on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . truncate
            result.to_vector.should_equal [0, 3, -3, 1, -2]
            result.name . should_equal "truncate([x])"

        group_builder.specify "should allow ceil on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . ceil
            result.to_vector.should_equal [0, 3, -3, 1, -2]
            result.name . should_equal "ceil([x])"

        group_builder.specify "should allow floor on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . floor
            result.to_vector.should_equal [0, 3, -3, 1, -2]
            result.name . should_equal "floor([x])"

        group_builder.specify "should fail on decimal_places out of range" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            table.at "x" . round 16 . should_fail_with Illegal_Argument

        if setup.test_selection.supports_decimal_type then
            group_builder.specify "should return decimals when rounding decimals" <|
                i1 = 9223372036854775807 - 1
                c = table_builder [["X", [i1]]] . at "X"
                decimal_col = c.cast Value_Type.Decimal
                decimal_col.value_type.is_decimal . should_be_true
                decimal_col2 = decimal_col + decimal_col*decimal_col
                [(.floor), (.ceil), (.truncate), (x-> x.round 0), (x-> x.round 2)].each op->
                    op decimal_col2 . to_vector . should_equal [i1 + i1*i1]

        group_builder.specify "should allow Nothing/NULL" <|
            table = table_builder [["x", [Nothing, 0.51, 0.59, 3.51, Nothing, 3.59, -0.51, -0.59, -3.51, -3.59]]]
            result = table.at "x" . round 1
            result.to_vector.should_equal [Nothing, 0.5, 0.6, 3.5, Nothing, 3.6, -0.5, -0.6, -3.5, -3.6]

        group_builder.specify "should fail on bad column type" <|
            table = table_builder [["x", ["a", "b"]]]
            table.at "x" . round . should_fail_with Invalid_Value_Type

        group_builder.specify "should work with mixed type columns" <|
            with_mixed_columns_if_supported [["X", [112, 210, 222]]] t->
                x = t.at "X"
                x.floor . to_vector . should_equal [112, 210, 222]
                x.ceil . to_vector . should_equal [112, 210, 222]
                x.round . to_vector . should_equal [112, 210, 222]
                x.truncate . to_vector . should_equal [112, 210, 222]
                x.round (-1) . to_vector . should_equal [110, 210, 220]

            with_mixed_columns_if_supported [["X", [1.0, -2.4, 3.8]]] t->
                x = t.at "X"
                x.floor . to_vector . should_equal [1, -3, 3]
                x.ceil . to_vector . should_equal [1, -2, 4]
                x.round . to_vector . should_equal [1, -2, 4]
                x.truncate . to_vector . should_equal [1, -2, 3]

    suite_builder.group prefix+"Date truncation" pending=pending_datetime group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should be able to truncate a column of Date_Times" <|
            dates = [Date_Time.new 2020 10 24 1 2 3, Date_Time.new 2020 10 24 1 2 3]
            table = table_builder [["foo", dates]]
            table.at "foo" . value_type . should_equal (Value_Type.Date_Time with_timezone=True)
            truncated = table.at "foo" . truncate
            truncated . to_vector . should_equal [Date.new 2020 10 24, Date.new 2020 10 24]
            truncated . value_type . should_equal Value_Type.Date
            truncated.name . should_equal "truncate([foo])"

    suite_builder.group prefix+"Text Column Operations" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should handle operations like starts_with, ends_with, contains" <|
            with_mixed_columns_if_supported [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]] t3->
                s1 = t3.at "s1"
                s2 = t3.at "s2"
                s1.starts_with s2 . to_vector . should_equal [True, False, False, False, Nothing]
                s1.starts_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, False, False, True, Nothing]
                s1.starts_with "foo" . to_vector . should_equal [True, False, False, False, Nothing]
                s1.starts_with "ba" . to_vector . should_equal [False, True, True, False, Nothing]
                s1.starts_with "ba" Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, True, True, Nothing]

                s1.contains s2 . to_vector . should_equal [True, True, True, False, Nothing]
                s1.contains s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]
                s1.contains "a" . to_vector . should_equal [True, True, True, False, Nothing]
                s1.contains "oo" . to_vector . should_equal [True, False, False, False, Nothing]
                s1.contains "a" Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]

                s1.ends_with s2 . to_vector . should_equal [False, True, False, False, Nothing]
                s1.ends_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, False, True, Nothing]
                s1.ends_with "ar" . to_vector . should_equal [True, True, False, False, Nothing]
                s1.ends_with "a" . to_vector . should_equal [False, False, False, False, Nothing]
                s1.ends_with "b" Case_Sensitivity.Insensitive . to_vector . should_equal [False, False, False, True, Nothing]

                s1.like s2 . to_vector . should_equal [False, False, False, False, Nothing]
                s1.like (s2+"%r") . to_vector . should_equal [True, False, False, False, Nothing]
                s1.like "%r%" . to_vector . should_equal [True, True, False, False, Nothing]

        group_builder.specify "should handle operation text_length" <|
            with_mixed_columns_if_supported [["strings", ["foobar", "", Nothing, "", "caf", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                res = col.text_length
                res.name . should_equal "text_length([strings])"

                case setup.is_database of
                    False -> res . to_vector . should_equal [6, 0, Nothing, 1, 4, 286] # Grapheme Length
                    True -> res . to_vector . should_equal [6, 0, Nothing, 3, 4, 286]  # Storage Length

        group_builder.specify "text_length should error on non-string columns" <|
            t = table_builder [["numbers", [1, 2, 3]]]
            col = t.at "numbers"
            col.text_length . should_fail_with Invalid_Value_Type
        
        group_builder.specify "should handle operation text_left and text_right with length 1" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "caf", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings" . cast (Value_Type.Char size=286 variable_length=True)
                resLeft = col.text_left 1
                resLeft.name . should_equal "text_left([strings], 1)"
                resRight = col.text_right 1
                resRight.name . should_equal "text_right([strings], 1)"
                resLeft . to_vector . should_equal ["a", "f", "", Nothing, "c", "I"] 
                resRight . to_vector . should_equal ["a", "r", "", Nothing, "", "."]
                case setup.is_database of
                    False -> resLeft . value_type . should_equal (Value_Type.Char size=286 variable_length=True)
                    True -> resLeft . value_type . should_equal (Value_Type.Char variable_length=True)
                case setup.is_database of
                    False -> resRight . value_type . should_equal (Value_Type.Char size=286 variable_length=True)
                    True -> resRight . value_type . should_equal (Value_Type.Char variable_length=True)
        
        group_builder.specify "should handle operation text_left and text_right of grapheme and non-grapheme" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "V", "caf", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                resLeft = col.text_left 3
                resLeft.name . should_equal "text_left([strings], 3)"
                resRight = col.text_right 3
                resRight.name . should_equal "text_right([strings], 3)"

                case setup.is_database of
                    False -> resLeft . to_vector . should_equal ["a", "foo", "", Nothing, "V", "caf", "It "] # Grapheme Length
                    True -> resLeft . to_vector . should_equal ["a", "foo", "", Nothing, "", "caf", "It "]  # Storage Length
                case setup.is_database of
                    False -> resRight . to_vector . should_equal ["a", "bar", "", Nothing, "V", "af", "ir."] # Grapheme Length
                    True -> resRight . to_vector . should_equal ["a", "bar", "", Nothing, "", "af", "ir."]  # Storage Length
        
        group_builder.specify "text_left and text_right should error on non-string columns" <|
            t = table_builder [["numbers", [1, 2, 3]]]
            col = t.at "numbers"
            col.text_left 6 . should_fail_with Invalid_Value_Type
            col.text_right 6 . should_fail_with Invalid_Value_Type

        group_builder.specify "text_left and text_right should error on non integer parameters" <|
            t = table_builder [["numbers", [1, 2, 3]]]
            col = t.at "numbers"
            col.text_left 3.14 . should_fail_with Invalid_Value_Type
            col.text_right 3.14 . should_fail_with Invalid_Value_Type
            col.text_left "7" . should_fail_with Invalid_Value_Type
            col.text_left "7" . should_fail_with Invalid_Value_Type

        group_builder.specify "text_left and text_right should return empty on zero argument" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "V", "caf", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                resLeft = col.text_left 0
                resLeft.name . should_equal "text_left([strings], 0)"
                resRight = col.text_right 0
                resRight.name . should_equal "text_right([strings], 0)"
                resLeft . to_vector . should_equal ["", "", "", Nothing, "", "", ""]
                resRight . to_vector . should_equal ["", "", "", Nothing, "", "", ""]

        group_builder.specify "text_left and text_right should return empty on negative arguments" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "V", "caf", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                resLeft = col.text_left -3
                resLeft.name . should_equal "text_left([strings], -3)"
                resRight = col.text_right -3
                resRight.name . should_equal "text_right([strings], -3)"
                resLeft . to_vector . should_equal ["", "", "", Nothing, "", "", ""]
                resRight . to_vector . should_equal ["", "", "", Nothing, "", "", ""]

        group_builder.specify "should handle operations like is_empty, is_blank, fill_empty" <|
            with_mixed_columns_if_supported [["s", ["", " ", "  ", Nothing, "foo"]], ["letters", ["a", "b", "c", "d", "e"]]] t->
                s = t.at "s"
                s.is_empty . to_vector . should_equal [True, False, False, True, False]
                s.is_blank . to_vector . should_equal [True, False, False, True, False]
                s.fill_empty "<>" . to_vector . should_equal ["<>", " ", "  ", "<>", "foo"]
                s.fill_empty (t.at "letters") . to_vector . should_equal ["a", " ", "  ", "d", "foo"]

        group_builder.specify "should check types" <|
            t4 = table_builder [["str", ['a', 'b']], ["int", [1, 2]]]
            str = t4.at "str"
            int = t4.at "int"
            str.starts_with int . should_fail_with Invalid_Value_Type
            str.ends_with int . should_fail_with Invalid_Value_Type
            str.contains int . should_fail_with Invalid_Value_Type
            str.like int . should_fail_with Invalid_Value_Type
            int.starts_with str . should_fail_with Invalid_Value_Type
            int.ends_with str . should_fail_with Invalid_Value_Type
            int.contains str . should_fail_with Invalid_Value_Type
            int.like str . should_fail_with Invalid_Value_Type
            str.starts_with 42 . should_fail_with Invalid_Value_Type
            str.ends_with 42 . should_fail_with Invalid_Value_Type
            str.contains 42 . should_fail_with Invalid_Value_Type
            str.like 42 . should_fail_with Invalid_Value_Type

            # Mixing text and integers should not be allowed
            (str + int) . should_fail_with Illegal_Argument

            int.fill_empty "<>" . should_fail_with Invalid_Value_Type
            str.fill_empty int . should_fail_with Invalid_Value_Type
            str.fill_empty 42 . should_fail_with Invalid_Value_Type

            int.is_empty . should_fail_with Invalid_Value_Type

        group_builder.specify "should return right types" <|
            t3 = table_builder [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]]
            s1 = t3.at "s1"
            s2 = t3.at "s2"
            [Case_Sensitivity.Default, Case_Sensitivity.Sensitive, Case_Sensitivity.Insensitive].each cs->
                s1.starts_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

                s1.starts_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

            s1.like s2 . value_type . should_equal Value_Type.Boolean
            s1.like "%r%" . value_type . should_equal Value_Type.Boolean

            s1.is_empty . value_type . should_equal Value_Type.Boolean
            s1.is_blank . value_type . should_equal Value_Type.Boolean
            s1.fill_empty "<>" . value_type . is_text . should_be_true
            s1.fill_empty s2 . value_type . is_text . should_be_true

        group_builder.specify "should support text concatenation with the + operator" <|
            with_mixed_columns_if_supported [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]] t3->
                s1 = t3.at "s1"
                s2 = t3.at "s2"
                c1 = s1 + s2
                c1.to_vector . should_equal ["foobarfoo", "barar", "baza", "BABb", Nothing]
                c1.value_type.is_text . should_be_true

                c2 = s1 + "_SUF"
                c2.to_vector . should_equal ["foobar_SUF", "bar_SUF", "baz_SUF", "BAB_SUF", Nothing]
                c2.value_type.is_text . should_be_true

                c3 = s1 + Nothing
                c3.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing]
                c3.value_type.is_text . should_be_true

    suite_builder.group prefix+"Min/Max Operations" group_builder->
        data = Min_Max_Data.setup create_connection_fn setup.table_builder

        group_builder.teardown <|
            data.teardown

        group_builder.specify "should allow one or more args and return the correct type" <|
            c1 = data.a.min 2
            c1.to_vector . should_equal [1, 2, 2]
            c1.value_type.is_integer . should_be_true

            c2 = data.a.max 2
            c2.to_vector . should_equal [2, 2, 3]
            c2.value_type.is_integer . should_be_true

            c3 = data.a.min [2.5, 2]
            c3.to_vector . should_equal [1, 2, 2]
            Test.with_clue "c3.value_type="+c3.value_type.to_display_text <|
                c3.value_type.is_floating_point . should_be_true

            c4 = data.a.max [2.5, 2]
            c4.to_vector . should_equal [2.5, 2.5, 3]
            c4.value_type.is_floating_point . should_be_true

            c5 = data.a.min data.b
            c5.to_vector . should_equal [1, 2, 3]
            Test.with_clue "c5.value_type="+c5.value_type.to_display_text+": " <|
                c5.value_type.is_floating_point . should_be_true

            c6 = data.a.max data.b
            c6.to_vector . should_equal [4.5, 5.5, 6.5]
            c6.value_type.is_floating_point . should_be_true

            c7 = data.a.min [data.a, data.b, 1]
            c7.to_vector . should_equal [1, 1, 1]
            c7.value_type.is_floating_point . should_be_true

            c8 = data.a.max [data.a, data.b, 1]
            c8.to_vector . should_equal [4.5, 5.5, 6.5]
            c8.value_type.is_floating_point . should_be_true

            c9 = (data.t.at "d").min False
            c9.to_vector . should_equal [False, False, False]
            c9.value_type.is_boolean . should_be_true

            c10 = (data.t.at "d").max False
            c10.to_vector . should_equal [True, False, True]
            c10.value_type.is_boolean . should_be_true

        group_builder.specify "should check types" <|
            [(.min), (.max)].each op->
                op data.a data.c . should_fail_with Invalid_Value_Type
                op data.a [1, 2, data.c] . should_fail_with Invalid_Value_Type
                op data.a [1, Nothing, data.c, Nothing] . should_fail_with Invalid_Value_Type
                op data.c 1 . should_fail_with Invalid_Value_Type
                op data.a True . should_fail_with Invalid_Value_Type

    do_replace column term new_text case_sensitivity=Case_Sensitivity.Default only_first=False expected =
        case setup.is_database of
            True ->
                input_type = Meta.type_of term
                params = Replace_Params.Value input_type case_sensitivity only_first
                supported_replace_params = setup.test_selection.supported_replace_params
                supported_replace_params . should_be_a Set
                are_params_supported = supported_replace_params.contains params
                case are_params_supported of
                    True -> column.replace term new_text case_sensitivity only_first . to_vector . should_equal expected
                    False -> column.replace term new_text case_sensitivity only_first . should_fail_with Unsupported_Database_Operation
            False ->
                result = column.replace term new_text case_sensitivity only_first
                result.value_type . should_equal Value_Type.Char
                result . to_vector . should_equal expected

    suite_builder.group prefix+"replace: literal text pattern and replacement" group_builder->
        data = Literal_Data.setup create_connection_fn setup.table_builder

        group_builder.teardown <|
            data.teardown

        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=false"
            do_replace data.col0 'hello' 'bye' expected=['bye Hello', 'bye bye', 'HELLO HELLO']
            do_replace data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Default expected=['bye Hello', 'bye bye', 'HELLO HELLO']
            do_replace data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Sensitive expected=['bye Hello', 'bye bye', 'HELLO HELLO']
            do_replace data.col1 'a[bcd]' 'hey' expected=['hey A[bCd] hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=true"
            do_replace data.col0 'hello' 'bye' only_first=True expected=['bye Hello', 'bye hello', 'HELLO HELLO']
            do_replace data.col1 'a[bcd]' 'hey' only_first=True expected=['hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=false"
            do_replace data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Insensitive expected=['bye bye', 'bye bye', 'bye bye']
            do_replace data.col1 'a[bcd]' 'hey' case_sensitivity=Case_Sensitivity.Insensitive expected=['hey hey hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=true"
            do_replace data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['bye Hello', 'bye hello', 'bye HELLO']
            do_replace data.col1 'a[bcd]' 'hey' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

    suite_builder.group prefix+"replace: literal regex pattern and replacement" group_builder->
        data = Literal_Data.setup create_connection_fn setup.table_builder

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "case_sensitivity=sensitive/default use_regex=True only_first=false"
            do_replace data.col1 'a[bcd]'.to_regex 'hey' expected=['a[bcd] A[bCd] a[bcd]', 'heyhey hey Ab aCAd']

        group_builder.specify "case_sensitivity=sensitive/default use_regex=True only_first=true"
            do_replace data.col1 'a[bcd]'.to_regex 'hey' only_first=True expected=['a[bcd] A[bCd] a[bcd]', 'heyac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=True only_first=false"
            do_replace data.col1 'a[bcd]'.to_regex 'hey' case_sensitivity=Case_Sensitivity.Insensitive expected=['a[bcd] A[bCd] a[bcd]', 'heyhey hey hey heyhey']

        group_builder.specify "case_sensitivity=insensitive use_regex=True only_first=true"
            do_replace data.col1 'a[bcd]'.to_regex 'hey' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['a[bcd] A[bCd] a[bcd]', 'heyac ad Ab aCAd']

        group_builder.specify "can properly escape complex regexes" <|
            regex = "^([^\(]+)|(?<foo>\w\d[a-z])+$"
            col = table_builder [["x", [regex]]] . at "x"
            do_replace col regex "asdf" ["asdf"]

    suite_builder.group prefix+"replace: pattern and replacement columns" group_builder->
        data = Replace_Data.setup create_connection_fn setup.table_builder

        group_builder.teardown <|
            data.teardown

        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=false"
            do_replace data.col data.patterns data.replacements expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Default expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Sensitive expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=true"
            do_replace data.col data.patterns data.replacements only_first=True expected=['bye Hello', 'bye hello', 'HELLO HELLO', 'hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=false"
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Insensitive expected=['bye bye', 'bye bye', 'bye bye', 'hey hey hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=true"
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['bye Hello', 'bye hello', 'bye HELLO', 'hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

    suite_builder.group prefix+"replace: empty table and nothings" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should work on empty tables" <|
            col = table_builder [["x", ['hello Hello']]] . filter "x" (Filter_Condition.Is_Nothing) . at "x"
            do_replace col 'hello' 'bye' expected=[]

        group_builder.specify "should work on Nothing text column" <|
            col = table_builder [["x", ['hello Hello', Nothing]]] . filter "x" (Filter_Condition.Is_Nothing) . at "x"
            do_replace col 'hello' 'bye' expected=[Nothing]

    if setup.is_database then suite_builder.group prefix+"replace: DB specific edge-cases" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should not allow Case_Sensitivity.Insensitive with a non-default locale" <|
            col = table_builder [["A", ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]]] . at 'A'
            locale = Locale.new "en" "GB" "UTF-8"
            col.replace 'asdf' 'zxcv' case_sensitivity=(Case_Sensitivity.Insensitive locale) . should_fail_with Illegal_Argument

        group_builder.specify "column name" <|
            table = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO', 'a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']], ["patterns", ['hello', 'hello', 'hello', 'a[bcd]', 'a[bcd]']], ["replacements", ['bye', 'bye', 'bye', 'hey', 'hey']]]
            col = table.at "x"
            patterns = table.at "patterns"
            replacements = table.at "replacements"

            supported_replace_params = setup.test_selection.supported_replace_params
            if supported_replace_params.contains (Replace_Params.Value Text Case_Sensitivity.Default False) then
                col.replace 'hello' 'bye' . name . should_equal 'replace([x], \'hello\', \'bye\')'
            if supported_replace_params.contains (Replace_Params.Value Regex Case_Sensitivity.Default False) then
                col.replace 'a[bcd]'.to_regex 'hey' . name . should_equal 'replace([x], \'a[bcd]\', \'hey\')'
            if supported_replace_params.contains (Replace_Params.Value Column Case_Sensitivity.Default False) then
                col.replace patterns replacements . name . should_equal 'replace([x], [patterns], [replacements])'

    suite_builder.group prefix+"Column Operations - Text Replace (in-memory only)" group_builder->

        if setup.is_database.not then
            data = Text_Replace_Data.setup create_connection_fn setup.table_builder

            group_builder.teardown <|
                data.teardown

            table_builder cols =
                setup.table_builder cols connection=data.connection

            group_builder.specify "should allow simple replacing" <|
                data.a.replace "a" "#" . to_vector . should_equal ["Alph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                data.a.replace "o" "#" . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtr#t"]
                data.a.replace data.b "#" . to_vector . should_equal ["#lpha", "Bravo", "Ch#rlie", "Delta", "Ech#", "Foxtrot"]
                data.a.replace "o" "#" only_first=True . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtrot"]
                data.a.replace "a" "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                data.a.replace data.b "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtr#t"]
                data.a.replace data.b "#" Case_Sensitivity.Insensitive only_first=True . to_vector . should_equal ["#lpha", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtrot"]

            group_builder.specify "should allow regex based replacing" <|
                data.a.replace "[aeiou]".to_regex "#" . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                data.a.replace "[aeiou]".to_regex "#" . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                data.a.replace "([aeiou])(.*?)[aeiou]".to_regex "$1$2$1" . to_vector . should_equal ["Alpha", "Brava", "Charlae", "Delte", "Echo", "Foxtrot"]

            group_builder.specify "should handle unicode" <|
                table = table_builder [["x", ["xx", "asdf", "ab"]], ["patterns", ["", "", ""]], ["replacements", ["abc", "def", "ghi"]]]
                col = table.at "x"
                patterns = table.at "patterns"
                replacements = table.at "replacements"

                col.replace patterns replacements . to_vector . should_equal ["abcxx", "defasdfdef", "aghib"]

            group_builder.specify "should take pattern and replacement string columns" <|
                t = table_builder [["x", ["hello", "what", "yes"]], ["patterns", ["ell", "wh", "es"]], ["replacements", ["xyz", "qwer", "asdf"]]]
                col = t.at "x"
                patterns = t.at "patterns"
                replacements = t.at "replacements"

                col.replace patterns replacements . to_vector . should_equal ["hxyzo", "qwerat", "yasdf"]

            group_builder.specify "should only allow replace on Text columns" <|
                data.c.replace "a" "#" . should_fail_with Invalid_Value_Type
                data.a.replace 1 "#" . should_fail_with Invalid_Value_Type
                data.a.replace data.c "#" . should_fail_with Invalid_Value_Type
                data.a.replace "a" 1 . should_fail_with Invalid_Value_Type
                data.a.replace "a" data.c . should_fail_with Invalid_Value_Type

            group_builder.specify "should not replace if Empty term" <|
                data.a.replace '' "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]
                data.a.replace data.d "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]

            group_builder.specify "should infer correct return type" <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"

                c1 = c.replace "a" "---"
                c1.to_vector . should_equal ["foo", "b---r"]
                vt1 = c1.value_type
                Test.with_clue "c1.value_type="+vt1.to_display_text+": " <|
                    vt1.should_be_a (Value_Type.Char ...)
                    vt1.variable_length.should_be_true

            group_builder.specify "should infer correct return type (2)" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"
                c2 = c.cast (Value_Type.Char size=2 variable_length=False)
                c3 = c2.replace "a" "---"

                c3.to_vector . should_equal ["fo", "b---"]
                vt3 = c3.value_type
                Test.with_clue "c3.value_type="+vt3.to_display_text+": " <|
                    vt3.should_be_a (Value_Type.Char ...)
                    vt3.variable_length.should_be_true

    suite_builder.group prefix+"Column Operations - Text Trim" group_builder->
        data = Trim_Data.setup create_connection_fn setup.table_builder

        group_builder.teardown <|
            data.teardown

        group_builder.specify "should trim whitespace by default" <|
            with_mixed_columns_if_supported [["A", [" A ", ' \t\n\rA\r\n\t ', "xxxAxx"]]] t->
                a = t.at "A"
                a.trim . to_vector . should_equal ["A", "A", "xxxAxx"]
                a.trim Location.Start . to_vector . should_equal ["A ", 'A\r\n\t ', "xxxAxx"]
                a.trim Location.End . to_vector . should_equal [" A", ' \t\n\rA', "xxxAxx"]

       group_builder.specify "should trim custom characters" <|
            data.a.trim what='x' . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "A"]
            data.a.trim what='x' Location.Start . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "Axx"]
            data.a.trim what='x' Location.End . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "xxxA"]
            data.a.trim what=' ' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            data.a.trim what=' \t' . to_vector . should_equal ["A", '\n\rA\r\n', "xxxAxx"]
            data.a.trim what=' \r' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            data.a.trim what=data.b . to_vector . should_equal ["A", '\n\rA\r\n', "A"]

        group_builder.specify "should only allow trim on Text columns" <|
            data.c.trim what="a" . should_fail_with Invalid_Value_Type
            data.a.trim what=1 . should_fail_with Invalid_Value_Type
            data.a.trim what=data.c . should_fail_with Invalid_Value_Type

    suite_builder.group prefix+"Other Column Operations" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "is_in" <|
            t = table_builder [["X", [1, 2, 3, 4]], ["Y", [4, 3, 100, 200]]]
            x = t.at "X"
            y = t.at "Y"

            c1 = x.is_in  [2, 100, 5]
            c1.to_vector . should_equal [False, True, False, False]
            c1.value_type.should_equal Value_Type.Boolean

            c2 = x.is_in y
            c2.to_vector . should_equal [False, False, True, True]
            c2.value_type.should_equal Value_Type.Boolean

    suite_builder.group prefix+"Colum Operations - Names" group_builder->
        data = Names_Data.setup create_connection_fn setup.table_builder

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "arithmetic" <|
            ((data.t.at "a") + 42) . name . should_equal "[a] + 42"
            ((data.t.at "a") - (data.t.at "c")) . name . should_equal "[a] - [c]"
            ((data.t.at "a") * (data.t.at "c")) . name . should_equal "[a] * [c]"
            ((data.t.at "a") / (data.t.at "c")) . name . should_equal "[a] / [c]"
            ((data.t.at "a") % (data.t.at "c")) . name . should_equal "[a] % [c]"
            ((data.t.at "a") ^ (data.t.at "c")) . name . should_equal "[a] ^ [c]"
            ((data.t.at "b") + 'xyz') . name . should_equal "[b] + 'xyz'"
            ((data.t.at "b") + '\0') . name . should_equal "[b] + '\0'"

        group_builder.specify "comparison" <|
            ((data.t.at "b") == '\0\0') . name . should_equal "[b] == '\0\0'"
            ((data.t.at "b") != '\0\0') . name . should_equal "[b] != '\0\0'"
            ((data.t.at "a") < 0) . name . should_equal "[a] < 0"
            ((data.t.at "a") <= 0) . name . should_equal "[a] <= 0"
            ((data.t.at "a") > 0) . name . should_equal "[a] > 0"
            ((data.t.at "b") >= 'X') . name . should_equal "[b] >= 'X'"
            ((data.t.at "a").between (data.t.at "c") 42) . name . should_equal "[a] between [c] and 42"

        group_builder.specify "logical" <|
            ((data.t.at "d") || False) . name . should_equal "[d] || False"
            ((data.t.at "d") && True) . name . should_equal "[d] && True"
            ((data.t.at "d").not) . name . should_equal "not [d]"
            ((data.t.at "d").iif 10 20) . name . should_equal "if [d] then 10 else 20"

        group_builder.specify "text" <|
            data.t.at "b" . equals_ignore_case "abc" . name . should_equal "equals_ignore_case([b], 'abc')"
            data.t.at "b" . starts_with "abc" . name . should_equal "starts_with([b], 'abc')"
            data.t.at "b" . contains "abc" . name . should_equal "contains([b], 'abc')"
            data.t.at "b" . like "%abc%" . name . should_equal "[b] like '%abc%'"
            data.t.at "b" . ends_with "abc" . name . should_equal "ends_with([b], 'abc')"
            data.t.at "b" . is_empty . name . should_equal "[b] is empty"
            data.t.at "b" . fill_empty "<empty>" . name . should_equal "b"

        group_builder.specify "nulls" <|
            data.t.at "a" . coalesce [Nothing, 42] . name . should_equal "coalesce([a], Nothing, 42)"
            data.t.at "a" . is_nothing . name . should_equal "[a] is Nothing"
            data.t.at "a" . is_present . name . should_equal "is_present([a])"
            data.t.at "a" . is_blank . name . should_equal "is_blank([a])"
            data.t.at "a" . fill_nothing 100 . name . should_equal "a"

        group_builder.specify "misc"
            data.t.at "a" . min [1, 2] . name . should_equal "min([a], 1, 2)"
            data.t.at "a" . max 33 . name . should_equal "max([a], 33)"
            data.t.at "a" . is_in [1, 2, 3] . name . should_equal "[a] in [1, 2, 3]"

        group_builder.specify "composed operations" <|
            # These look a bit weird, but they are consistent with the column name escaping scheme.
            ((data.t.at "a" + 42) * (data.t.at "c")) . name . should_equal "[[a] + 42] * [c]"
            ((data.t.at "a" + 42) * (data.t.at "c") - 33) . name . should_equal "[[[a] + 42] * [c]] - 33"

        group_builder.specify "sort" <|
            data.t.at "a" . sort . name . should_equal "a"

        if setup.is_database.not then
            group_builder.specify "parse" <|
                t2 = table_builder [["X", ["1", "2", "3"]]]
                t2.at "X" . parse . name . should_equal "X"

            group_builder.specify "map and zip" <|
                data.t.at "a" . map (x -> x + 1) . name . should_equal "a"
                data.t.at "a" . zip (data.t.at "b") [_, _] . name . should_equal "[a] x [b]"

    suite_builder.group prefix+"Column.rename" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "should not allow illegal names" <|
            t = table_builder [["a", [1, 2, 3]]]
            c = t.at "a"

            c.rename Nothing . should_fail_with Invalid_Column_Names
            c.rename '' . should_fail_with Invalid_Column_Names
            c.rename 'a\0b' . should_fail_with Invalid_Column_Names
            c.rename '\0' . should_fail_with Invalid_Column_Names

    suite_builder.group prefix+"Column.const" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "Should allow the creation of constant columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const True . to_vector . should_equal [True, True, True]
            t.at "x" . const 12 . to_vector . should_equal [12, 12, 12]
            t.at "x" . const 12.3 . to_vector . should_equal [12.3, 12.3, 12.3]
            t.at "x" . const "asdf" . to_vector . should_equal ["asdf", "asdf", "asdf"]

        group_builder.specify "Should create the correct column name" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const 12 . name . should_equal "12"

        group_builder.specify "Should not allow the creation of a constant column of columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const (t.at "x") . should_fail_with Illegal_Argument

    suite_builder.group prefix+"Table.make_constant_column" group_builder->
        data = Data.setup create_connection_fn

        group_builder.teardown <|
            data.teardown

        table_builder cols =
            setup.table_builder cols connection=data.connection

        group_builder.specify "Should allow the creation of constant columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.make_constant_column True . to_vector . should_equal [True, True, True]
            t.make_constant_column 12 . to_vector . should_equal [12, 12, 12]
            t.make_constant_column 12.3 . to_vector . should_equal [12.3, 12.3, 12.3]
            t.make_constant_column "asdf" . to_vector . should_equal ["asdf", "asdf", "asdf"]

        group_builder.specify "Should allow the creation of constant columns on a table with no rows" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            empty = t.take 0
            constant = empty.make_constant_column 42
            empty2 = empty.set constant
            empty2.column_names.should_equal ['x', '42']

        group_builder.specify "Should create a column of the correct type on a table with no rows" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            empty = t.take 0
            [[False, .is_boolean], [42,  .is_integer], ["42",  .is_text], ["foo", .is_text], [1.1, .is_floating_point]].map pair->
                value = pair.at 0
                pred = pair.at 1
                c = empty.make_constant_column value
                pred c.value_type . should_be_true
                pred ((empty.set c).at c.name . value_type) . should_be_true

        nulls_db_pending = if setup.is_database then "Empty NULL columns are unsupported in the database backends"
        group_builder.specify "Should create a column of the correct type on a table with no rows" pending=nulls_db_pending <|
            t = table_builder [["x", ["1", "2", "3"]]]
            empty = t.take 0
            c = empty.make_constant_column Nothing
            c.value_type . should_equal Value_Type.Mixed
            (empty.set c).at c.name . value_type . should_equal Value_Type.Mixed

# A dummy value used to force the in-memory backend to trigger a infer a mixed type for the given column.
type Mixed_Type_Object
    Value

all_combinations variables =
    result = Vector.new_builder
    go current_choices =
        i = current_choices.length
        if i == variables.length then result.append current_choices else
            choices = variables.at i
            choices.each x->
                go (current_choices + [x])
    go []
    result.to_vector


drop_table connection table =
    case table of
        _ : Database_Table ->
            connection.drop_table table.name
        _ -> Nothing
