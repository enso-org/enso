from Standard.Base import all
import Standard.Base.Errors.Common.Arithmetic_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

from Standard.Table import Value_Type
from Standard.Table.Errors import all

from Standard.Database.Errors import SQL_Error

from Standard.Test import Test, Problems
import Standard.Test.Extensions

from project.Common_Table_Operations.Util import run_default_backend

main = run_default_backend spec

spec setup =
    prefix = setup.prefix
    table_builder = setup.table_builder
    Test.group prefix+"Boolean Column Operations" <|
        Test.specify "iif" <|
            t = table_builder [["X", [True, False, Nothing, True]]]
            c1 = t.at "X" . iif 22 33
            c1.to_vector . should_equal [22, 33, Nothing, 22]
            c1.value_type . is_integer . should_be_true

            c2 = t.at "X" . iif 22 33.0
            c2.to_vector . should_equal [22, 33, Nothing, 22]
            c2.value_type . is_floating_point . should_be_true

            c3 = t.at "X" . iif "A" "B"
            c3.to_vector . should_equal ["A", "B", Nothing, "A"]
            c3.value_type . is_text . should_be_true

            c4 = t.at "X" . iif Nothing "B"
            c4.to_vector . should_equal [Nothing, "B", Nothing, Nothing]
            c4.value_type . is_text . should_be_true

            c5 = t.at "X" . iif 42 Nothing
            c5.to_vector . should_equal [42, Nothing, Nothing, 42]
            c5.value_type . is_integer . should_be_true

            c6 = t.at "X" . iif Nothing Nothing
            c6.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

            t.at "X" . iif 22.0 False . should_fail_with No_Common_Type
            t.at "X" . iif 22 "0" . should_fail_with No_Common_Type

        Test.specify "iif on Columns" <|
            t1 = table_builder [["X", [True, False, Nothing, False]], ["Y", [1, 2, 3, 4]], ["Z", [1.5, 2.0, 3.5, 4.0]]]
            c1 = t1.at "X" . iif (t1.at "Y") (t1.at "Z")
            c1.value_type . is_floating_point . should_be_true
            c1.to_vector . should_equal [1, 2.0, Nothing, 4.0]

            t2 = table_builder [["X", [True, False]], ["Y", [1, 2]], ["Z", [1.5, 3.0]]]
            c2 = t2.at "X" . iif (t2.at "Y") (t2.at "Z")
            c2.to_vector . should_equal [1, 3]
            c2.value_type . is_floating_point . should_be_true

            t3 = table_builder [["X", [True, False]], ["Y", [10, 20]], ["Z", [False, True]]]
            t3.at "X" . iif (t3.at "Y") (t3.at "Z") . should_fail_with No_Common_Type
            t3.at "X" . iif (t3.at "Y") "<NA>" . should_fail_with No_Common_Type

        Test.specify "iif should correctly unify text columns of various lengths" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
            t0 = table_builder [["x", [False, True, False]], ["A", ["a", "b", "c"]], ["B", ["xyz", "abc", "def"]]]
            t1 = t0 . cast "A" (Value_Type.Char size=1 variable_length=False) . cast "B" (Value_Type.Char size=3 variable_length=False)

            x = t1.at "x"
            a = t1.at "A"
            b = t1.at "B"
            a.value_type.should_equal (Value_Type.Char size=1 variable_length=False)
            b.value_type.should_equal (Value_Type.Char size=3 variable_length=False)

            c = x.iif a b
            c.to_vector.should_equal ["xyz", "b", "def"]
            Test.with_clue "c.value_type="+c.value_type.to_display_text+": " <|
                c.value_type.variable_length.should_be_true

            d = b.cast (Value_Type.Char size=1 variable_length=False)
            e = x.iif a d
            e.to_vector.should_equal ["x", "b", "d"]
            e.value_type.should_equal (Value_Type.Char size=1 variable_length=False)

            f = b.cast (Value_Type.Char size=1 variable_length=True)
            g = x.iif a f
            g.to_vector.should_equal ["x", "b", "d"]
            Test.with_clue "g.value_type="+g.value_type.to_display_text+": " <|
                g.value_type.variable_length.should_be_true

        Test.specify "should allow to compute &&, || and not" <|
            t = table_builder [["X", [True, False, True]], ["Y", [True, False, False]]]
            x = t.at "X"
            y = t.at "Y"
            (x || y.not).to_vector . should_equal [True, True, True]
            (x || False).to_vector . should_equal [True, False, True]
            (x || True).to_vector . should_equal [True, True, True]
            (x && False).to_vector . should_equal [False, False, False]

        Test.specify "should return null if one of arguments is missing" pending="TODO null handling" <|
            t = table_builder [["X", [True, False, True]]]
            x = t.at "X"
            nulls = [Nothing, Nothing, Nothing, Nothing]
            (x && Nothing).to_vector . should_equal nulls
            (x || Nothing).to_vector . should_equal nulls

        Test.specify "should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']], ["Z", [True, False, Nothing]]]

            ((t.at "X") && (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") && (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") && True) . should_fail_with Invalid_Value_Type

            ((t.at "X") || (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") || (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") || True) . should_fail_with Invalid_Value_Type

            ((t.at "X") . not) . should_fail_with Invalid_Value_Type
            ((t.at "Y") . iif 10 20) . should_fail_with Invalid_Value_Type

    t2 = table_builder [["x", [1, 4, 5, Nothing]], ["y", [2.0, 3.25, 5.0, Nothing]]]
    x = t2.at "x"
    y = t2.at "y"
    Test.group prefix+"Column Operations - Equality & Null Handling" <|
        Test.specify "should provide basic == and != comparisons" pending="TODO figure out proper null handling" <|
            (x == y).to_vector . should_equal [False, False, True, Nothing]
            (x != y).to_vector . should_equal [True, True, False, Nothing]
            (x == 4).to_vector . should_equal [False, True, False, Nothing]
            (x == Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

        Test.specify "should allow to check which values are null"
            x.is_nothing.to_vector . should_equal [False, False, False, True]
            (x + Nothing).is_nothing.to_vector . should_equal [True, True, True, True]
            x.is_present.to_vector . should_equal [True, True, True, False]
            (x + Nothing).is_present.to_vector . should_equal [False, False, False, False]

        Test.specify "Column equality should handle nulls correctly" pending="TODO" <|
            a = [2, 3, Nothing, Nothing]
            b = [2, 4, Nothing, 5]
            r = [True, False, True, False]
            a.zip b (==) . should_equal r

            t = table_builder [["A", a], ["B", b]]
            c = (t.at "A") == (t.at "B")
            c.to_vector . should_equal r
            c.value_type.should_equal Value_Type.Boolean

        Test.specify "equals_ignore_case for ASCII strings" <|
            x = ["a", "B", "c", "DEF"]
            y = ["aa", "b", "c", "dEf"]
            r = [False, True, True, True]

            x.zip y (.equals_ignore_case) . should_equal r

            t = table_builder [["X", x], ["Y", y]]
            c = (t.at "X") . equals_ignore_case (t.at "Y")
            c.to_vector . should_equal r
            c.value_type.should_equal Value_Type.Boolean
            (t.at "X") . equals_ignore_case "Def" . to_vector . should_equal [False, False, False, True]

        Test.specify "equals_ignore_case should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']]]

            r1 = (t.at "X") . equals_ignore_case (t.at "Y") . to_vector
            r1.should_fail_with Invalid_Value_Type

            r2 = (t.at "Y") . equals_ignore_case (t.at "X") . to_vector
            r2.should_fail_with Invalid_Value_Type

            r3 = (t.at "Y") . equals_ignore_case 42 . to_vector
            r3.should_fail_with Invalid_Value_Type

        Test.specify "Text Column equality (including case-insensitive) should handle nulls correctly" pending="TODO" <|
            a = ["Z", "a", "b", Nothing, Nothing]
            b = ["Z", "A", "C", Nothing, "d"]
            r_sensitive   = [True, False, False, True, False]
            r_insensitive = [True, True,  False, True, False]

            a.zip b (==) . should_equal r_sensitive
            a.zip b (x-> y-> if x.is_nothing || y.is_nothing then x == y else x.equals_ignore_case y) . should_equal r_insensitive

            t = table_builder [["A", a], ["B", b]]
            ((t.at "A") == (t.at "B")) . to_vector . should_equal r_sensitive
            ((t.at "A").equals_ignore_case (t.at "B")) . to_vector . should_equal r_insensitive

        Test.specify "should allow to fill empty/nothing values" <|
            t = table_builder [["X", ["a", "", " ", Nothing, "b"]]]

            c1 = t.at "X" . fill_nothing "NA"
            c1.to_vector . should_equal ["a", "", " ", "NA", "b"]

            c2 = t.at "X" . fill_empty "<empty>"
            c2.to_vector . should_equal ["a", "<empty>", " ", "<empty>", "b"]

        Test.specify "should report a warning if checking equality on floating point columns" <|
            t = table_builder [["X", [1.0, 2.1, 3.2]], ["Y", [1.0, 2.0, 3.2]]]

            r1 = (t.at "X") == (t.at "Y")
            r1.to_vector . should_equal [True, False, True]
            Problems.expect_warning Floating_Point_Equality r1

            r2 = (t.at "X") != (t.at "Y")
            r2.to_vector . should_equal [False, True, False]
            Problems.expect_warning Floating_Point_Equality r2

    Test.group prefix+"Column Comparisons" <|
        Test.specify "should allow to compare numbers" <|
            x.value_type . is_integer . should_be_true
            y.value_type . is_floating_point . should_be_true

            (x < y).to_vector . should_equal [True, False, False, Nothing]
            (x <= y).to_vector . should_equal [True, False, True, Nothing]
            (x > y).to_vector . should_equal (x <= y).not.to_vector
            (x >= y).to_vector . should_equal (x < y).not.to_vector

            (x < 1000).to_vector . should_equal [True, True, True, Nothing]

            [(<), (<=), (>), (>=)].each op->
                op x y . value_type . should_equal Value_Type.Boolean
                op x y . to_vector . should_succeed
                op x 23 . to_vector . should_succeed
                op y 23 . to_vector . should_succeed
                op x 1.5 . to_vector . should_succeed

        Test.specify "should allow to compare texts" <|
            t0 = table_builder [["X", ["a", "b", "c"]], ["Y", ["a", "b", "d"]]]
            t = t0.cast "X" (Value_Type.Char size=1 variable_length=False)

            [(<), (<=), (>), (>=)].each op->
                op (t.at "X") (t.at "Y") . value_type . should_equal Value_Type.Boolean
                op (t.at "X") (t.at "Y") . to_vector . should_succeed
                op (t.at "X") "abc" . to_vector . should_succeed

        Test.specify "should allow to compare booleans" <|
            t = table_builder [["X", [True, False, True]], ["Y", [False, True, True]]]

            ((t.at "X") < (t.at "Y")).to_vector . should_equal [False, True, False]
            ((t.at "X") >= (t.at "Y")).to_vector . should_equal [True, False, True]
            ((t.at "X") <= (t.at "Y")).to_vector . should_equal [False, True, True]
            ((t.at "X") > (t.at "Y")).to_vector . should_equal [True, False, False]

            ((t.at "X") < True).to_vector . should_equal [False, True, False]
            ((t.at "X") >= True).to_vector . should_equal [True, False, True]
            ((t.at "X") <= True).to_vector . should_equal [True, True, True]
            ((t.at "X") > True).to_vector . should_equal [False, False, False]

        Test.specify "should report error if incomparable types are compared" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]

            [(<), (<=), (>), (>=)].each op->
                r1 = op (t.at "X") (t.at "Y")
                r1.should_fail_with Invalid_Value_Type
                r1.catch . should_be_a Invalid_Value_Type.Incomparable

                op (t.at "X") "FOO" . should_fail_with Invalid_Value_Type
                op (t.at "Y") 42 . should_fail_with Invalid_Value_Type
                op (t.at "Y") False . should_fail_with Invalid_Value_Type
                op (t.at "Z") 32 . should_fail_with Invalid_Value_Type
                op (t.at "Z") (t.at "X") . should_fail_with Invalid_Value_Type

        Test.specify "Between should return null if any of the values are null" pending="TODO" <|
            a = [2, 3, Nothing, 7,       5,       Nothing]
            b = [0, 5, 7,       Nothing, 7,       Nothing]
            c = [9, 8, 7,       7,       Nothing, Nothing]
            r = [True, False, Nothing, Nothing, Nothing, Nothing]

            t = table_builder [["A", a], ["B", b], ["C", c]]
            ((t.at "A").between (t.at "B") (t.at "C")) . to_vector . should_equal r

    Test.group prefix+"Arithmetic Column Operations" <|
        Test.specify "should allow basic operations" <|
            (x + y).to_vector . should_equal [3, 7.25, 10, Nothing]
            (x - y).to_vector . should_equal [-1.0, 0.75, 0.0, Nothing]
            (x * y).to_vector . should_equal [2.0, 13.0, 25.0, Nothing]

        Test.specify "should allow combining a column with a scalar" pending="TODO null handling" <|
            (x + 100).to_vector . should_equal [101, 104, 105, Nothing]
            (x * 10).to_vector . should_equal [10, 40, 50, Nothing]
            (x - 10).to_vector . should_equal [-9, -6, -5, Nothing]

        Test.specify "should correctly infer the types" <|
            (x + x).value_type . is_integer . should_be_true
            (x + y).value_type . is_floating_point . should_be_true
            (x + 2).value_type . is_integer . should_be_true
            (x + 1.5).value_type . is_floating_point . should_be_true

            (x - x).value_type . is_integer . should_be_true
            (x - y).value_type . is_floating_point . should_be_true
            (x - 2).value_type . is_integer . should_be_true
            (x - 1.5).value_type . is_floating_point . should_be_true

            (x * x).value_type . is_integer . should_be_true
            (x * y).value_type . is_floating_point . should_be_true
            (x * 2).value_type . is_integer . should_be_true
            (x * 1.5).value_type . is_floating_point . should_be_true

            (x ^ x).value_type . is_numeric . should_be_true

        Test.specify "should check types" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]
            x = t.at "X"
            y = t.at "Y"
            z = t.at "Z"

            (x + z) . should_fail_with Illegal_Argument
            (x + False) . should_fail_with Illegal_Argument

            # Mixing text and integers should not be allowed
            (x + y) . should_fail_with Illegal_Argument
            (x + "foo") . should_fail_with Illegal_Argument

            (x - z).should_fail_with Invalid_Value_Type
            (x - "a").should_fail_with Invalid_Value_Type
            (y - "a").should_fail_with Invalid_Value_Type
            (y - 42).should_fail_with Invalid_Value_Type

            (x * z).should_fail_with Invalid_Value_Type
            (x * "a").should_fail_with Invalid_Value_Type
            (y * "a").should_fail_with Invalid_Value_Type
            (y * 42).should_fail_with Invalid_Value_Type

            (x / z).should_fail_with Invalid_Value_Type
            (x / "a").should_fail_with Invalid_Value_Type
            (y / "a").should_fail_with Invalid_Value_Type
            (y / 42).should_fail_with Invalid_Value_Type

            (x ^ z).should_fail_with Invalid_Value_Type
            (x ^ "a").should_fail_with Invalid_Value_Type
            (y ^ "a").should_fail_with Invalid_Value_Type
            (y ^ 42).should_fail_with Invalid_Value_Type

        if setup.test_selection.is_nan_and_nothing_distinct then
            Test.specify "should support is_nan" <|
                t = table_builder [["X", [1.5, 2, Number.nan]], ["Y", [1, 2, 3]]]
                t.at "X" . is_nan . to_vector . should_equal [False, False, True]
                t.at "Y" . is_nan . should_fail_with Invalid_Value_Type
        Test.specify "should support is_blank" <|
            t = table_builder [["X", [1.5, 2, Number.nan, Nothing]], ["Y", [1, Nothing, 3, 4]]]
            t.at "X" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, False, True, True]
            t.at "Y" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, True, False, False]

        Test.specify "division should be aligned with the Enso arithmetic" <|
            a = [1, 5, 10, 100]
            b = [2, 2, 4, 5]
            r = [0.5, 2.5, 2.5, 20.0]
            a.zip b (/) . should_equal r

            t = table_builder [["A", a], ["B", b]]
            t.at "A" . value_type . is_integer . should_be_true
            t.at "B" . value_type . is_integer . should_be_true

            r2 = (t.at "A") / (t.at "B")
            r2 . to_vector . should_equal r
            r2.value_type . is_floating_point . should_be_true

            r3 = (t.at "A") / 2
            r3 . to_vector . should_equal [0.5, 2.5, 5.0, 50.0]
            r3.value_type . is_floating_point . should_be_true

            a2 = [1.2, 5, 10.2, 100]
            b2 = [1.2, 2, 2, 5]
            r4 = [1.0, 2.5, 5.1, 20.0]
            a2.zip b2 (/) . should_equal r4

            t2 = table_builder [["A", a2], ["B", b2]]
            t2.at "A" . value_type . is_floating_point . should_be_true
            t2.at "B" . value_type . is_floating_point . should_be_true

            r5 = (t2.at "A") / (t2.at "B")
            r5 . to_vector . should_equal r4
            r5.value_type . is_floating_point . should_be_true

            r6 = (t2.at "A") / 2
            r6 . to_vector . should_equal [0.6, 2.5, 5.1, 50.0]
            r6.value_type . is_floating_point . should_be_true

        db_pending = if setup.is_database then "Arithmetic error handling is currently not implemented for the Database backend."
        Test.specify "should allow division by 0 and report warnings" pending=db_pending <|
            t = table_builder [["a", [3, 1, 0]], ["b", [2, 0, 0]], ["c", [1.5, 1.5, 0.0]], ["d", [1.5, 0.0, 0.0]]]
            a = t.at "a"
            b = t.at "b"
            c = t.at "c"
            d = t.at "d"

            has_div_warnings location expected_rows result =
                Test.with_clue location <|
                    warnings = Problems.get_attached_warnings result
                    msg = "Division by zero (at rows " + expected_rows.to_text + ")."
                    warnings.first . should_equal (Arithmetic_Error.Error msg)

            r1 = a / b
            r1.to_vector.to_text . should_equal "[1.5, Infinity, NaN]"
            has_div_warnings "[a] / [b]" [1, 2] r1
            r2 = c / d
            r2.to_vector.to_text . should_equal "[1.0, Infinity, NaN]"
            has_div_warnings "[c] / [d]" [1, 2] r2
            r3 = a / d
            r3.to_vector.to_text . should_equal "[2.0, Infinity, NaN]"
            has_div_warnings "[a] / [d]" [1, 2] r3
            r4 = a / 0
            r4.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[a] / 0" [0, 1, 2] r4
            r5 = c / 0
            r5.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[c] / 0" [0, 1, 2] r5

            r6 = a % b
            r6.to_vector.to_text . should_equal "[1, Nothing, Nothing]"
            has_div_warnings "[a] % [b]" [1, 2] r6
            r7 = c % d
            r7.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[c] % [d]" [1, 2] r7
            r8 = a % d
            r8.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[a] % [d]" [1, 2] r8
            r9 = a % 0
            r9.to_vector.to_text . should_equal "[Nothing, Nothing, Nothing]"
            has_div_warnings "[a] % 0" [0, 1, 2] r9
            r10 = c % 0
            r10.to_vector.to_text . should_equal "[NaN, NaN, NaN]"
            has_div_warnings "[c] % 0" [0, 1, 2] r10

        Test.specify "should limit the number of rows listed in the message" pending=db_pending <|
            t1 = table_builder [["a", 0.up_to 200 . to_vector]]
            zero = t1.at "a" - t1.at "a"
            div = t1.at "a" / zero
            warnings = Problems.get_attached_warnings div
            warnings.not_empty.should_be_true
            warning = warnings.first
            warning.should_be_a Arithmetic_Error
            warning.message . should_equal "Division by zero (at rows [0, 1, 2, 3, 4, 5, 6, 7, 8, ...])."

        Test.specify "should return null if one of arguments is missing" <|
            nulls = [Nothing, Nothing, Nothing, Nothing]
            (x + Nothing).to_vector . should_equal nulls
            (x - Nothing).to_vector . should_equal nulls
            (x * Nothing).to_vector . should_equal nulls
            (x / Nothing).to_vector . should_equal nulls

    Test.group prefix+"Text Column Operations" <|
        t3 = table_builder [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]]
        s1 = t3.at "s1"
        s2 = t3.at "s2"
        Test.specify "should handle operations like starts_with, ends_with, contains" <|
            s1.starts_with s2 . to_vector . should_equal [True, False, False, False, Nothing]
            s1.starts_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, False, False, True, Nothing]
            s1.starts_with "foo" . to_vector . should_equal [True, False, False, False, Nothing]
            s1.starts_with "ba" . to_vector . should_equal [False, True, True, False, Nothing]
            s1.starts_with "ba" Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, True, True, Nothing]

            s1.contains s2 . to_vector . should_equal [True, True, True, False, Nothing]
            s1.contains s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]
            s1.contains "a" . to_vector . should_equal [True, True, True, False, Nothing]
            s1.contains "oo" . to_vector . should_equal [True, False, False, False, Nothing]
            s1.contains "a" Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]

            s1.ends_with s2 . to_vector . should_equal [False, True, False, False, Nothing]
            s1.ends_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, False, True, Nothing]
            s1.ends_with "ar" . to_vector . should_equal [True, True, False, False, Nothing]
            s1.ends_with "a" . to_vector . should_equal [False, False, False, False, Nothing]
            s1.ends_with "b" Case_Sensitivity.Insensitive . to_vector . should_equal [False, False, False, True, Nothing]

            s1.like s2 . to_vector . should_equal [False, False, False, False, Nothing]
            s1.like (s2+"%r") . to_vector . should_equal [True, False, False, False, Nothing]
            s1.like "%r%" . to_vector . should_equal [True, True, False, False, Nothing]

        Test.specify "should handle operations like is_empty, is_blank, fill_empty" <|
            t = table_builder [["s", ["", " ", "  ", Nothing, "foo"]], ["letters", ["a", "b", "c", "d", "e"]]]
            s = t.at "s"
            s.is_empty . to_vector . should_equal [True, False, False, True, False]
            s.is_blank . to_vector . should_equal [True, False, False, True, False]
            s.fill_empty "<>" . to_vector . should_equal ["<>", " ", "  ", "<>", "foo"]
            s.fill_empty (t.at "letters") . to_vector . should_equal ["a", " ", "  ", "d", "foo"]

        Test.specify "should check types" <|
            t4 = table_builder [["str", ['a', 'b']], ["int", [1, 2]]]
            str = t4.at "str"
            int = t4.at "int"
            str.starts_with int . should_fail_with Invalid_Value_Type
            str.ends_with int . should_fail_with Invalid_Value_Type
            str.contains int . should_fail_with Invalid_Value_Type
            str.like int . should_fail_with Invalid_Value_Type
            int.starts_with str . should_fail_with Invalid_Value_Type
            int.ends_with str . should_fail_with Invalid_Value_Type
            int.contains str . should_fail_with Invalid_Value_Type
            int.like str . should_fail_with Invalid_Value_Type
            str.starts_with 42 . should_fail_with Invalid_Value_Type
            str.ends_with 42 . should_fail_with Invalid_Value_Type
            str.contains 42 . should_fail_with Invalid_Value_Type
            str.like 42 . should_fail_with Invalid_Value_Type

            # Mixing text and integers should not be allowed
            (str + int) . should_fail_with Illegal_Argument

            int.fill_empty "<>" . should_fail_with Invalid_Value_Type
            str.fill_empty int . should_fail_with Invalid_Value_Type
            str.fill_empty 42 . should_fail_with Invalid_Value_Type

            int.is_empty . should_fail_with Invalid_Value_Type

        Test.specify "should return right types" <|
            [Case_Sensitivity.Default, Case_Sensitivity.Sensitive, Case_Sensitivity.Insensitive].each cs->
                s1.starts_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

                s1.starts_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

            s1.like s2 . value_type . should_equal Value_Type.Boolean
            s1.like "%r%" . value_type . should_equal Value_Type.Boolean

            s1.is_empty . value_type . should_equal Value_Type.Boolean
            s1.is_blank . value_type . should_equal Value_Type.Boolean
            s1.fill_empty "<>" . value_type . is_text . should_be_true
            s1.fill_empty s2 . value_type . is_text . should_be_true

        Test.specify "should support text concatenation with the + operator" <|
            c1 = s1 + s2
            c1.to_vector . should_equal ["foobarfoo", "barar", "baza", "BABb", Nothing]
            c1.value_type.is_text . should_be_true

            c2 = s1 + "_SUF"
            c2.to_vector . should_equal ["foobar_SUF", "bar_SUF", "baz_SUF", "BAB_SUF", Nothing]
            c2.value_type.is_text . should_be_true

            c3 = s1 + Nothing
            c3.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing]
            c3.value_type.is_text . should_be_true

    Test.group prefix+"Min/Max Operations" <|
        t = table_builder [["a", [1, 2, 3]], ["b", [4.5, 5.5, 6.5]], ["c", ['a', 'b', 'c']], ["d", [True, False, True]]]
        a = t.at "a"
        b = t.at "b"
        c = t.at "c"
        Test.specify "should allow one or more args and return the correct type" <|
            c1 = a.min 2
            c1.to_vector . should_equal [1, 2, 2]
            c1.value_type.is_integer . should_be_true

            c2 = a.max 2
            c2.to_vector . should_equal [2, 2, 3]
            c2.value_type.is_integer . should_be_true

            c3 = a.min [2.5, 2]
            c3.to_vector . should_equal [1, 2, 2]
            Test.with_clue "c3.value_type="+c3.value_type.to_display_text <|
                c3.value_type.is_floating_point . should_be_true

            c4 = a.max [2.5, 2]
            c4.to_vector . should_equal [2.5, 2.5, 3]
            c4.value_type.is_floating_point . should_be_true

            c5 = a.min b
            c5.to_vector . should_equal [1, 2, 3]
            Test.with_clue "c5.value_type="+c5.value_type.to_display_text+": " <|
                c5.value_type.is_floating_point . should_be_true

            c6 = a.max b
            c6.to_vector . should_equal [4.5, 5.5, 6.5]
            c6.value_type.is_floating_point . should_be_true

            c7 = a.min [a, b, 1]
            c7.to_vector . should_equal [1, 1, 1]
            c7.value_type.is_floating_point . should_be_true

            c8 = a.max [a, b, 1]
            c8.to_vector . should_equal [4.5, 5.5, 6.5]
            c8.value_type.is_floating_point . should_be_true

            c9 = (t.at "d").min False
            c9.to_vector . should_equal [False, False, False]
            c9.value_type.is_boolean . should_be_true

            c10 = (t.at "d").max False
            c10.to_vector . should_equal [True, False, True]
            c10.value_type.is_boolean . should_be_true

        Test.specify "should check types" <|
            [(.min), (.max)].each op->
                op a c . should_fail_with Invalid_Value_Type
                op a [1, 2, c] . should_fail_with Invalid_Value_Type
                op a [1, Nothing, c, Nothing] . should_fail_with Invalid_Value_Type
                op c 1 . should_fail_with Invalid_Value_Type
                op a True . should_fail_with Invalid_Value_Type

    Test.group prefix+"Column Operations - Text Replace" <|
        if setup.is_database.not then
            t4 = table_builder [["A", ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]], ["B", ["A","O","a","E","o","O"]], ["C", [1,2,3,4,5,6]], ["D", ['',Nothing,'',Nothing,'','']]]
            a = t4.at "A"
            b = t4.at "B"
            c = t4.at "C"
            d = t4.at "D"

            Test.specify "should allow simple replacing" <|
                a.replace "a" "#" . to_vector . should_equal ["Alph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                a.replace "o" "#" . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtr#t"]
                a.replace b "#" . to_vector . should_equal ["#lpha", "Bravo", "Ch#rlie", "Delta", "Ech#", "Foxtrot"]
                a.replace "o" "#" only_first=True . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtrot"]
                a.replace "a" "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                a.replace b "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtr#t"]
                a.replace b "#" Case_Sensitivity.Insensitive only_first=True . to_vector . should_equal ["#lpha", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtrot"]

            Test.specify "should allow regex based replacing" <|
                a.replace "[aeiou]" "#" use_regex=True . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                a.replace "[aeiou]" "#" use_regex=True . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                a.replace "([aeiou])(.*?)[aeiou]" "$1$2$1" use_regex=True . to_vector . should_equal ["Alpha", "Brava", "Charlae", "Delte", "Echo", "Foxtrot"]

            Test.specify "should only allow replace on Text columns" <|
                c.replace "a" "#" . should_fail_with Invalid_Value_Type
                a.replace 1 "#" . should_fail_with Invalid_Value_Type
                a.replace c "#" . should_fail_with Invalid_Value_Type
                a.replace "a" 1 . should_fail_with Invalid_Value_Type
                a.replace "a" c . should_fail_with Invalid_Value_Type

            Test.specify "should not replace if Empty term" <|
                a.replace '' "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]
                a.replace '' "#" use_regex=True . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]
                a.replace d "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]
                a.replace d "#" use_regex=True . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]

            Test.specify "should infer correct return type" <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"

                c1 = c.replace "a" "---"
                c1.to_vector . should_equal ["foo", "b---r"]
                vt1 = c1.value_type
                Test.with_clue "c1.value_type="+vt1.to_display_text+": " <|
                    vt1.should_be_a (Value_Type.Char ...)
                    vt1.variable_length.should_be_true

            Test.specify "should infer correct return type (2)" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"
                c2 = c.cast (Value_Type.Char size=2 variable_length=False)
                c3 = c2.replace "a" "---"

                c3.to_vector . should_equal ["fo", "b---"]
                vt3 = c3.value_type
                Test.with_clue "c3.value_type="+vt3.to_display_text+": " <|
                    vt3.should_be_a (Value_Type.Char ...)
                    vt3.variable_length.should_be_true

    Test.group prefix+"Column Operations - Text Trim" <|
        t5 = table_builder [["A", [" A ", ' \t\n\rA\r\n\t ', "xxxAxx"]], ["B", [" ",' \t',"x"]], ["C", [1,2,3]]]
        a = t5.at "A"
        b = t5.at "B"
        c = t5.at "C"

        Test.specify "should trim whitespace by default" <|
            a.trim . to_vector . should_equal ["A", "A", "xxxAxx"]
            a.trim Location.Start . to_vector . should_equal ["A ", 'A\r\n\t ', "xxxAxx"]
            a.trim Location.End . to_vector . should_equal [" A", ' \t\n\rA', "xxxAxx"]

       Test.specify "should trim custom characters" <|
            a.trim what='x' . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "A"]
            a.trim what='x' Location.Start . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "Axx"]
            a.trim what='x' Location.End . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "xxxA"]
            a.trim what=' ' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            a.trim what=' \t' . to_vector . should_equal ["A", '\n\rA\r\n', "xxxAxx"]
            a.trim what=' \r' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            a.trim what=b . to_vector . should_equal ["A", '\n\rA\r\n', "A"]

        Test.specify "should only allow trim on Text columns" <|
            c.trim what="a" . should_fail_with Invalid_Value_Type
            a.trim what=1 . should_fail_with Invalid_Value_Type
            a.trim what=c . should_fail_with Invalid_Value_Type

    Test.group prefix+"Other Column Operations" <|
        Test.specify "is_in" <|
            t = table_builder [["X", [1, 2, 3, 4]], ["Y", [4, 3, 100, 200]]]
            x = t.at "X"
            y = t.at "Y"

            c1 = x.is_in  [2, 100, 5]
            c1.to_vector . should_equal [False, True, False, False]
            c1.value_type.should_equal Value_Type.Boolean

            c2 = x.is_in y
            c2.to_vector . should_equal [False, False, True, True]
            c2.value_type.should_equal Value_Type.Boolean

    Test.group prefix+"Colum Operations - Names" <|
        t = table_builder [["a", [1, 2, 3]], ["b", ['x', 'y', 'z']], ["c", [1.0, 2.0, 3.0]], ["d", [True, False, True]]]
        Test.specify "arithmetic" <|
            ((t.at "a") + 42) . name . should_equal "[a] + 42"
            ((t.at "a") - (t.at "c")) . name . should_equal "[a] - [c]"
            ((t.at "a") * (t.at "c")) . name . should_equal "[a] * [c]"
            ((t.at "a") / (t.at "c")) . name . should_equal "[a] / [c]"
            ((t.at "a") % (t.at "c")) . name . should_equal "[a] % [c]"
            ((t.at "a") ^ (t.at "c")) . name . should_equal "[a] ^ [c]"
            ((t.at "b") + 'xyz') . name . should_equal "[b] + 'xyz'"
            ((t.at "b") + '\0') . name . should_equal "[b] + '\0'"

        Test.specify "comparison" <|
            ((t.at "b") == '\0\0') . name . should_equal "[b] == '\0\0'"
            ((t.at "b") != '\0\0') . name . should_equal "[b] != '\0\0'"
            ((t.at "a") < 0) . name . should_equal "[a] < 0"
            ((t.at "a") <= 0) . name . should_equal "[a] <= 0"
            ((t.at "a") > 0) . name . should_equal "[a] > 0"
            ((t.at "b") >= 'X') . name . should_equal "[b] >= 'X'"
            ((t.at "a").between (t.at "c") 42) . name . should_equal "[a] between [c] and 42"

        Test.specify "logical" <|
            ((t.at "d") || False) . name . should_equal "[d] || False"
            ((t.at "d") && True) . name . should_equal "[d] && True"
            ((t.at "d").not) . name . should_equal "not [d]"
            ((t.at "d").iif 10 20) . name . should_equal "if [d] then 10 else 20"

        Test.specify "text" <|
            t.at "b" . equals_ignore_case "abc" . name . should_equal "equals_ignore_case([b], 'abc')"
            t.at "b" . starts_with "abc" . name . should_equal "starts_with([b], 'abc')"
            t.at "b" . contains "abc" . name . should_equal "contains([b], 'abc')"
            t.at "b" . like "%abc%" . name . should_equal "[b] like '%abc%'"
            t.at "b" . ends_with "abc" . name . should_equal "ends_with([b], 'abc')"
            t.at "b" . is_empty . name . should_equal "[b] is empty"
            t.at "b" . fill_empty "<empty>" . name . should_equal "fill_empty([b], '<empty>')"

        Test.specify "nulls" <|
            t.at "a" . coalesce [Nothing, 42] . name . should_equal "coalesce([a], Nothing, 42)"
            t.at "a" . is_nothing . name . should_equal "[a] is null"
            t.at "a" . is_present . name . should_equal "is_present([a])"
            t.at "a" . is_blank . name . should_equal "is_blank([a])"
            t.at "a" . fill_nothing 100 . name . should_equal "fill_nothing([a], 100)"

        Test.specify "misc"
            t.at "a" . min [1, 2] . name . should_equal "min([a], 1, 2)"
            t.at "a" . max 33 . name . should_equal "max([a], 33)"
            t.at "a" . is_in [1, 2, 3] . name . should_equal "[a] in [1, 2, 3]"

        Test.specify "composed operations" <|
            # These look a bit weird, but they are consistent with the column name escaping scheme.
            ((t.at "a" + 42) * (t.at "c")) . name . should_equal "[[a]] + 42] * [c]"
            ((t.at "a" + 42) * (t.at "c") - 33) . name . should_equal "[[[a]]]] + 42]] * [c]]] - 33"

        Test.specify "sort" <|
            t.at "a" . sort . name . should_equal "a"

        if setup.is_database.not then
            Test.specify "parse" <|
                t2 = table_builder [["X", ["1", "2", "3"]]]
                t2.at "X" . parse . name . should_equal "X"

            Test.specify "map and zip" <|
                t.at "a" . map (x -> x + 1) . name . should_equal "a"
                t.at "a" . zip (t.at "b") [_, _] . name . should_equal "[a] x [b]"

    Test.group prefix+"Column.rename" <|
        Test.specify "should not allow illegal names" <|
            t = table_builder [["a", [1, 2, 3]]]
            c = t.at "a"

            c.rename Nothing . should_fail_with Illegal_Argument
            c.rename '' . should_fail_with Illegal_Argument
            c.rename 'a\0b' . should_fail_with Illegal_Argument
            c.rename '\0' . should_fail_with Illegal_Argument
