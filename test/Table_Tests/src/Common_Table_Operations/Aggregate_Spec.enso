from Standard.Base import all hiding First, Last

from Standard.Table import Table, Sort_Column
from Standard.Table.Data.Aggregate_Column.Aggregate_Column import all
import Standard.Table.Data.Expression.Expression_Error
from Standard.Table.Errors import all

from Standard.Database.Errors import Unsupported_Database_Operation

from Standard.Test import Test, Test_Suite, Problems
import Standard.Test.Extensions

from project.Common_Table_Operations.Util import run_default_backend

polyglot java import java.lang.Double

main = run_default_backend spec

type Test_Selection
    Config problem_handling=True advanced_stats=True text_concat=True text_shortest_longest=True first_last=True first_last_row_order=True std_dev=True multi_distinct=True aggregation_problems=True nan=True date_support=True

## Runs the common aggregate tests.
spec setup =
    prefix = setup.prefix
    table = setup.table
    empty_table = setup.empty_table
    table_builder = setup.table_builder
    materialize = setup.materialize
    is_database = setup.is_database
    test_selection = setup.aggregate_test_selection

    expect_column_names names table =
        table.columns . map .name . should_equal names frames_to_skip=2

    find_row key table (columns=Nothing) =
        table_columns = if columns.is_nothing then table.columns else columns.map x->(table.columns.at x)
        0.up_to table.row_count . find i->
            0.up_to key.length . all j-> (table_columns.at j . at i)==(key.at j)

    resolve_pending enabled_flag=Nothing =
        if enabled_flag.not then "Not supported." else Nothing

    Test.group prefix+"Table.aggregate should summarize whole table" <|
        Test.specify "should be able to count" <|
            grouped = table.aggregate [Count]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Count"
            materialized.columns.at 0 . at 0 . should_equal 2500

        Test.specify "should be able to count missing values" <|
            grouped = table.aggregate [Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 0 . at 0 . should_equal 236
            materialized.columns.at 1 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 1 . at 0 . should_equal 2264
            materialized.columns.at 2 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 2 . at 0 . should_equal 249
            materialized.columns.at 3 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 2251

        Test.specify "should be able to count distinct values" <|
            grouped = table.aggregate [Count_Distinct "Code", Count_Distinct "Index", Count_Distinct "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Count Distinct Code"
            materialized.columns.at 0 . at 0 . should_equal 2333
            materialized.columns.at 1 . name . should_equal "Count Distinct Index"
            materialized.columns.at 1 . at 0 . should_equal 10
            materialized.columns.at 2 . name . should_equal "Count Distinct Flag"
            materialized.columns.at 2 . at 0 . should_equal 2

        Test.specify "should be able to count distinct values over multiple columns" (pending = resolve_pending test_selection.multi_distinct) <|
            grouped = table.aggregate [Count_Distinct ["Index", "Flag"]]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Count Distinct Index Flag"
            materialized.columns.at 0 . at 0 . should_equal 20

        Test.specify "should be able to compute sum and average of values" <|
            grouped = table.aggregate [Sum "Value", Sum "ValueWithNothing", Average "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Sum Value"
            materialized.columns.at 0 . at 0 . should_equal -932.411550 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Sum ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal 2757.09 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Average Value"
            materialized.columns.at 2 . at 0 . should_equal -0.372965 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 1.228650 epsilon=0.000001

        Test.specify "should be able to compute standard deviation of values" (pending = resolve_pending test_selection.std_dev) <|
            grouped = table.aggregate [Standard_Deviation "Value", Standard_Deviation "ValueWithNothing", (Standard_Deviation "Value" population=True), (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 0 . at 0 . should_equal 56.708660 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal 58.588610 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Standard Deviation Value_1"
            materialized.columns.at 2 . at 0 . should_equal 56.697317 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Standard Deviation ValueWithNothing_1"
            materialized.columns.at 3 . at 0 . should_equal 58.575554 epsilon=0.000001

        Test.specify "should be able to create median, mode and percentile values" (pending = resolve_pending test_selection.advanced_stats) <|
            grouped = table.aggregate [Median "Index", Median "Value", Median "ValueWithNothing", Mode "Index", Percentile 0.25 "Value", Percentile 0.40 "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 6
            materialized.columns.at 0 . name . should_equal "Median Index"
            materialized.columns.at 0 . at 0 . should_equal 5 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Median Value"
            materialized.columns.at 1 . at 0 . should_equal 1.298375 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Median ValueWithNothing"
            materialized.columns.at 2 . at 0 . should_equal 2.235 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Mode Index"
            materialized.columns.at 3 . at 0 . should_equal 7
            materialized.columns.at 4 . name . should_equal "25%-ile Value"
            materialized.columns.at 4 . at 0 . should_equal -49.962710 epsilon=0.000001
            materialized.columns.at 5 . name . should_equal "40%-ile ValueWithNothing"
            materialized.columns.at 5 . at 0 . should_equal -17.960000 epsilon=0.000001

        Test.specify "should be able to get first and last values" (pending = resolve_pending test_selection.first_last) <|
            grouped = table.aggregate [First "Index" (order_by = [Sort_Column.Name "Hexadecimal", Sort_Column.Name "TextWithNothing"]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal 5
            materialized.columns.at 1 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal -89.78 epsilon=0.000001

        Test.specify "should be able to get first and last values with mixed ordering" (pending = resolve_pending test_selection.first_last) <|
            grouped = table.aggregate [First "TextWithNothing" (order_by = [Sort_Column.Name "Value" Sort_Direction.Descending, Sort_Column.Name "Code"]), First "TextWithNothing" (order_by = [Sort_Column.Name "Code", Sort_Column.Name "Value" Sort_Direction.Descending]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value" Sort_Direction.Descending])]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "First TextWithNothing"
            materialized.columns.at 0 . at 0 . should_equal "riwaiqq1io"
            materialized.columns.at 1 . name . should_equal "First TextWithNothing_1"
            materialized.columns.at 1 . at 0 . should_equal "j4i2ua7uft"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 2 . at 0 . should_equal -38.56 epsilon=0.000001

        Test.specify "should be able to get first and last values with default row order" (pending = resolve_pending test_selection.first_last_row_order) <|
            grouped = table.aggregate [First "Index", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal 7
            materialized.columns.at 1 . name . should_equal "Last Value"
            materialized.columns.at 1 . at 0 . should_equal 70.99931 epsilon=0.000001

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = table.aggregate [Minimum "Value", Maximum "Value", Minimum "ValueWithNothing", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Minimum Value"
            materialized.columns.at 0 . at 0 . should_equal -99.964200 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Maximum Value"
            materialized.columns.at 1 . at 0 . should_equal 99.977480 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Minimum ValueWithNothing"
            materialized.columns.at 2 . at 0 . should_equal -99.99 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 99.95 epsilon=0.000001

        Test.specify "should be able to get shortest and longest text values" (pending = resolve_pending test_selection.text_shortest_longest)  <|
            grouped = table.aggregate [Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 0 . at 0 . should_equal "f5"
            materialized.columns.at 1 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 1 . at 0 . should_equal "setp295gjvbanana"

        Test.specify "should be able to get concatenated text values" (pending = resolve_pending test_selection.text_concat)  <|
            grouped = table.aggregate [Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate Code"
            materialized.columns.at 0 . at 0 . length . should_equal 7500

    Test.group prefix+"Table.aggregate should summarize empty table" <|
        Test.specify "should be able to count" <|
            grouped = empty_table.aggregate [Count]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Count"
            materialized.columns.at 0 . at 0 . should_equal 0

        Test.specify "should be able to count missing values" <|
            grouped = empty_table.aggregate [Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 0 . at 0 . should_equal 0
            materialized.columns.at 1 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 1 . at 0 . should_equal 0
            materialized.columns.at 2 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 2 . at 0 . should_equal 0
            materialized.columns.at 3 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 0

        Test.specify "should be able to count distinct values" <|
            grouped = empty_table.aggregate [Count_Distinct "Code" (ignore_nothing=False), Count_Distinct "Code" (ignore_nothing=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Count Distinct Code"
            materialized.columns.at 0 . at 0 . should_equal 0
            materialized.columns.at 1 . name . should_equal "Count Distinct Code_1"
            materialized.columns.at 1 . at 0 . should_equal 0

        Test.specify "should be able to compute sum and average of values" <|
            grouped = empty_table.aggregate [Sum "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Sum Value"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to compute standard deviation of values" (pending = resolve_pending test_selection.std_dev) <|
            grouped = empty_table.aggregate [Standard_Deviation "Value", (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to create median, mode and percentile values" (pending = resolve_pending test_selection.advanced_stats) <|
            grouped = empty_table.aggregate [Median "Index", Mode "Index", Percentile 0.25 "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Median Index"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Mode Index"
            materialized.columns.at 1 . at 0 . should_equal Nothing
            materialized.columns.at 2 . name . should_equal "25%-ile Value"
            materialized.columns.at 2 . at 0 . should_equal Nothing

        Test.specify "should be able to get first and last values" (pending = resolve_pending test_selection.first_last) <|
            grouped = empty_table.aggregate [First "Index" (order_by = [Sort_Column.Name "Hexadecimal", Sort_Column.Name "TextWithNothing"]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get first and last values with default row order" (pending = resolve_pending test_selection.first_last_row_order) <|
            grouped = empty_table.aggregate [First "Index", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Last Value"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = empty_table.aggregate [Minimum "Value", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Minimum Value"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get shortest and longest text values" (pending = resolve_pending test_selection.text_shortest_longest) <|
            grouped = empty_table.aggregate [Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get concatenated text values" (pending = resolve_pending test_selection.text_concat) <|
            grouped = empty_table.aggregate [Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate Code"
            materialized.columns.at 0 . at 0 . should_equal Nothing

    Test.group prefix+"Table.aggregate should not summarize empty table when grouped" <|
        Test.specify "should be able to count" <|
            grouped = empty_table.aggregate [Group_By 0, Count]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Count"

        Test.specify "should be able to count missing values" <|
            grouped = empty_table.aggregate [Group_By 0, Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 5
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 2 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 3 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 4 . name . should_equal "Count Not Empty TextWithNothing"

        Test.specify "should be able to count distinct values" <|
            grouped = empty_table.aggregate [Group_By 0, Count_Distinct "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Count Distinct Code"

        Test.specify "should be able to compute sum and average of values" <|
            grouped = empty_table.aggregate [Group_By 0, Sum "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Sum Value"
            materialized.columns.at 2 . name . should_equal "Average ValueWithNothing"

        Test.specify "should be able to compute standard deviation of values" (pending = resolve_pending test_selection.std_dev) <|
            grouped = empty_table.aggregate [Group_By 0, Standard_Deviation "Value", (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 2 . name . should_equal "Standard Deviation ValueWithNothing"

        Test.specify "should be able to create median values" (pending = resolve_pending test_selection.advanced_stats) <|
            grouped = empty_table.aggregate [Group_By 0, Median "Index", Mode "Index", Percentile 0.25 "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Median Index"
            materialized.columns.at 2 . name . should_equal "Mode Index"
            materialized.columns.at 3 . name . should_equal "25%-ile Value"

        Test.specify "should be able to get first and last values" (pending = resolve_pending test_selection.first_last) <|
            grouped = empty_table.aggregate [Group_By 0, First "Index" (order_by = [Sort_Column.Name "Hexadecimal", Sort_Column.Name "TextWithNothing"]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "First Index"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"

        Test.specify "should be able to get first and last values with default row order" (pending = resolve_pending test_selection.first_last_row_order) <|
            grouped = empty_table.aggregate [Group_By 0, First "Index", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "First Index"
            materialized.columns.at 2 . name . should_equal "Last Value"

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = empty_table.aggregate [Group_By 0, Minimum "Value", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Minimum Value"
            materialized.columns.at 2 . name . should_equal "Maximum ValueWithNothing"

        Test.specify "should be able to get shortest and longest text values" (pending = resolve_pending test_selection.text_shortest_longest) <|
            grouped = empty_table.aggregate [Group_By 0, Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 2 . name . should_equal "Longest TextWithNothing"

        Test.specify "should be able to get concatenated text values" (pending = resolve_pending test_selection.text_concat) <|
            grouped = empty_table.aggregate [Group_By 0, Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Concatenate Code"

    Test.group prefix+"Table.aggregate should be able to group on single field" <|
        Test.specify "should be able to count" <|
            grouped = table.aggregate [Group_By "Index", Count]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count"
            materialized.columns.at 1 . at idx . should_equal 261

        Test.specify "should be able to count missing values" <|
            grouped = table.aggregate [Group_By "Index", Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 1 . at idx . should_equal 24
            materialized.columns.at 2 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 2 . at idx . should_equal 237
            materialized.columns.at 3 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 3 . at idx . should_equal 31
            materialized.columns.at 4 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 4 . at idx . should_equal 230

        Test.specify "should be able to count distinct values" <|
            grouped = table.aggregate [Group_By "Index", Count_Distinct "Code", Count_Distinct "Index", Count_Distinct "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Code"
            materialized.columns.at 1 . at idx . should_equal 260
            materialized.columns.at 2 . name . should_equal "Count Distinct Index"
            materialized.columns.at 2 . at idx . should_equal 1
            materialized.columns.at 3 . name . should_equal "Count Distinct Flag"
            materialized.columns.at 3 . at idx . should_equal 2

        Test.specify "should be able to count distinct values over multiple columns" (pending = resolve_pending test_selection.multi_distinct) <|
            grouped = table.aggregate [Group_By "Index", Count_Distinct ["Index", "Flag"]]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Index Flag"
            materialized.columns.at 1 . at idx . should_equal 2

        Test.specify "should be able to compute sum and average of values" <|
            grouped = table.aggregate [Group_By "Index", Sum "Value", Sum "ValueWithNothing", Average "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Sum Value"
            materialized.columns.at 1 . at idx . should_equal -447.847390 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Sum ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 151.86 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Average Value"
            materialized.columns.at 3 . at idx . should_equal -1.715890 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal 0.646213 epsilon=0.000001

        Test.specify "should be able to compute standard deviation of values" (pending = resolve_pending test_selection.std_dev) <|
            grouped = table.aggregate [Group_By "Index", Standard_Deviation "Value", Standard_Deviation "ValueWithNothing", (Standard_Deviation "Value" population=True), (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 1 . at idx . should_equal 60.272158 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 56.798691 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Standard Deviation Value_1"
            materialized.columns.at 3 . at idx . should_equal 60.156583 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Standard Deviation ValueWithNothing_1"
            materialized.columns.at 4 . at idx . should_equal 56.677714 epsilon=0.000001

        Test.specify "should be able to create median values" (pending = resolve_pending test_selection.advanced_stats) <|
            grouped = table.aggregate [Group_By "Index", Median "Index", Median "Value", Median "ValueWithNothing", Mode "Index", Percentile 0.25 "Value", Percentile 0.40 "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 7
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Median Index"
            materialized.columns.at 1 . at idx . should_equal 6 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Median Value"
            materialized.columns.at 2 . at idx . should_equal 2.041150 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Median ValueWithNothing"
            materialized.columns.at 3 . at idx . should_equal 1.38 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Mode Index"
            materialized.columns.at 4 . at idx . should_equal 6
            materialized.columns.at 5 . name . should_equal "25%-ile Value"
            materialized.columns.at 5 . at idx . should_equal -56.019100 epsilon=0.000001
            materialized.columns.at 6 . name . should_equal "40%-ile ValueWithNothing"
            materialized.columns.at 6 . at idx . should_equal -18.802000 epsilon=0.000001

        Test.specify "should be able to get first and last values" (pending = resolve_pending test_selection.first_last) <|
            grouped = table.aggregate [Group_By "Index", First "TextWithNothing" (order_by = [Sort_Column.Name "Value", Sort_Column.Name "Flag"]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [7] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "8g6kidngic"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal -89.78 epsilon=0.000001

        Test.specify "should be able to get first and last values with mixed ordering" (pending = resolve_pending test_selection.first_last) <|
            grouped = table.aggregate [Group_By "Index", First "TextWithNothing" (order_by = [Sort_Column.Name "Value" Sort_Direction.Descending, Sort_Column.Name "Flag"]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value" Sort_Direction.Descending])]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [7] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "riwaiqq1io"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal -63.75 epsilon=0.000001

        Test.specify "should be able to get first and last values with default row order" (pending = resolve_pending test_selection.first_last_row_order) <|
            grouped = table.aggregate [Group_By "Index", First "TextWithNothing", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "kmqxqkl6qx"
            materialized.columns.at 2 . name . should_equal "Last Value"
            materialized.columns.at 2 . at idx . should_equal 56.15916 epsilon=0.000001

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = table.aggregate [Group_By "Index", Minimum "Value", Maximum "Value", Minimum "ValueWithNothing", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Minimum Value"
            materialized.columns.at 1 . at idx . should_equal -99.605880 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Maximum Value"
            materialized.columns.at 2 . at idx . should_equal 99.12739 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Minimum ValueWithNothing"
            materialized.columns.at 3 . at idx . should_equal -99.99 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal 99.79 epsilon=0.000001

        Test.specify "should be able to get shortest and longest text values" (pending = resolve_pending test_selection.text_shortest_longest) <|
            grouped = table.aggregate [Group_By "Index", Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [1] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "f5"
            materialized.columns.at 2 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 2 . at idx . should_equal "byo6kn5l3sz"

        Test.specify "should be able to get concatenated text values" (pending = resolve_pending test_selection.text_concat) <|
            grouped = table.aggregate [Group_By "Index", Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Concatenate Code"
            materialized.columns.at 1 . at idx . length . should_equal 783

    Test.group prefix+"Table.aggregate should be able to group on multiple fields not in left columns" <|
        Test.specify "should be able to count" <|
            grouped = table.aggregate [Group_By "Flag", Count, Group_By "Index"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Flag"
            materialized.columns.at 2 . name . should_equal "Index"
            idx = find_row [False, 6] materialized [0, 2]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count"
            materialized.columns.at 1 . at idx . should_equal 127

        Test.specify "should be able to count missing values" <|
            grouped = table.aggregate [Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Group_By "Index", Count_Empty "TextWithNothing", Group_By "Flag", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 6
            materialized.columns.at 4 . name . should_equal "Flag"
            materialized.columns.at 2 . name . should_equal "Index"
            idx = find_row [False, 6] materialized [4, 2]
            idx.is_nothing . should_be_false
            materialized.columns.at 0 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 0 . at idx . should_equal 8
            materialized.columns.at 1 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 1 . at idx . should_equal 119
            materialized.columns.at 3 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 3 . at idx . should_equal 12
            materialized.columns.at 5 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 5 . at idx . should_equal 115

        Test.specify "should be able to count distinct values" <|
            grouped = table.aggregate [Group_By "Index", Count_Distinct "Code", Count_Distinct "Index", Count_Distinct "Flag", Group_By "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 4 . name . should_equal "Flag"
            idx = find_row [False, 6] materialized [4, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Code"
            materialized.columns.at 1 . at idx . should_equal 127
            materialized.columns.at 2 . name . should_equal "Count Distinct Index"
            materialized.columns.at 2 . at idx . should_equal 1
            materialized.columns.at 3 . name . should_equal "Count Distinct Flag"
            materialized.columns.at 3 . at idx . should_equal 1

        Test.specify "should be able to count distinct values over multiple columns" (pending = resolve_pending test_selection.multi_distinct) <|
            grouped = table.aggregate [Group_By "Index", Count_Distinct ["Index", "Flag"], Group_By "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 2 . name . should_equal "Flag"
            idx = find_row [False, 6] materialized [2, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Index Flag"
            materialized.columns.at 1 . at idx . should_equal 1

        Test.specify "should be able to compute sum and average of values" <|
            grouped = table.aggregate [Group_By "Index", Sum "Value", Sum "ValueWithNothing", Average "Value", Average "ValueWithNothing", Group_By "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 6
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 5 . name . should_equal "Flag"
            idx = find_row [False, 6] materialized [5, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Sum Value"
            materialized.columns.at 1 . at idx . should_equal -103.050170 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Sum ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 533.57 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Average Value"
            materialized.columns.at 3 . at idx . should_equal -0.811419 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal 4.721858 epsilon=0.000001

        Test.specify "should be able to compute standard deviation of values" (pending = resolve_pending test_selection.std_dev) <|
            grouped = table.aggregate [Group_By "Index", Group_By "Flag", Standard_Deviation "Value", Standard_Deviation "ValueWithNothing", (Standard_Deviation "Value" population=True), (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 6
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 1 . name . should_equal "Flag"
            idx = find_row [False, 6] materialized [1, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 2 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 2 . at idx . should_equal 58.979275 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 3 . at idx . should_equal 57.561756 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Standard Deviation Value_1"
            materialized.columns.at 4 . at idx . should_equal 58.746614 epsilon=0.000001
            materialized.columns.at 5 . name . should_equal "Standard Deviation ValueWithNothing_1"
            materialized.columns.at 5 . at idx . should_equal 57.306492 epsilon=0.000001

        Test.specify "should be able to create median values" (pending = resolve_pending test_selection.advanced_stats) <|
            grouped = table.aggregate [Median "Index", Median "Value", Median "ValueWithNothing", Mode "Index", Group_By "Index", Group_By "Flag", Percentile 0.25 "Value", Percentile 0.40 "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 8
            materialized.columns.at 5 . name . should_equal "Flag"
            materialized.columns.at 4 . name . should_equal "Index"
            idx = find_row [False, 6] materialized [5, 4]
            idx.is_nothing . should_be_false
            materialized.columns.at 0 . name . should_equal "Median Index"
            materialized.columns.at 0 . at idx . should_equal 6 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Median Value"
            materialized.columns.at 1 . at idx . should_equal 2.041150 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Median ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 3.55 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Mode Index"
            materialized.columns.at 3 . at idx . should_equal 6
            materialized.columns.at 6 . name . should_equal "25%-ile Value"
            materialized.columns.at 6 . at idx . should_equal -52.628925 epsilon=0.000001
            materialized.columns.at 7 . name . should_equal "40%-ile ValueWithNothing"
            materialized.columns.at 7 . at idx . should_equal -17.174000 epsilon=0.000001

        Test.specify "should be able to get first and last values" (pending = resolve_pending test_selection.first_last) <|
            grouped = table.aggregate [Group_By "Flag", First "TextWithNothing" (order_by = [Sort_Column.Name "Value", Sort_Column.Name "Flag"]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value"]), Group_By "Index"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Flag"
            materialized.columns.at 3 . name . should_equal "Index"
            idx = find_row [False, 7] materialized [0, 3]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "8g6kidngic"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal -89.78 epsilon=0.000001

        Test.specify "should be able to get first and last values with mixed ordering" (pending = resolve_pending test_selection.first_last) <|
            grouped = table.aggregate [Group_By "Flag", First "TextWithNothing" (order_by = [Sort_Column.Name "Value" Sort_Direction.Descending, Sort_Column.Name "Flag"]), Last "ValueWithNothing" (order_by = [Sort_Column.Name "Value" Sort_Direction.Descending]), Group_By "Index"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Flag"
            materialized.columns.at 3 . name . should_equal "Index"
            idx = find_row [True, 7] materialized [0, 3]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "13dir782ah"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 54.48 epsilon=0.000001

        Test.specify "should be able to get first and last values with default row order" (pending = resolve_pending test_selection.first_last_row_order) <|
            grouped = table.aggregate [Group_By "Flag", First "TextWithNothing", Last "Value", Group_By "Index"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Flag"
            materialized.columns.at 3 . name . should_equal "Index"
            idx = find_row [False, 6] materialized [0, 3]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "kmqxqkl6qx"
            materialized.columns.at 2 . name . should_equal "Last Value"
            materialized.columns.at 2 . at idx . should_equal 56.15916 epsilon=0.000001

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = table.aggregate [Group_By "Index", Minimum "Value", Maximum "Value", Group_By "Flag", Minimum "ValueWithNothing", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 6
            materialized.columns.at 3 . name . should_equal "Flag"
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [False, 6] materialized [3, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Minimum Value"
            materialized.columns.at 1 . at idx . should_equal -99.605880 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Maximum Value"
            materialized.columns.at 2 . at idx . should_equal 96.488390 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Minimum ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal -99.99 epsilon=0.000001
            materialized.columns.at 5 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 5 . at idx . should_equal 97.17 epsilon=0.000001

        Test.specify "should be able to get shortest and longest text values" (pending = resolve_pending test_selection.text_shortest_longest) <|
            grouped = table.aggregate [Group_By "Index", Group_By "Flag", Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 4
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 1 . name . should_equal "Flag"
            idx = find_row [1, False] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 2 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 2 . at idx . should_equal "f5"
            materialized.columns.at 3 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 3 . at idx . should_equal "byo6kn5l3sz"

        Test.specify "should be able to get concatenated text values" (pending = resolve_pending test_selection.text_concat) <|
            grouped = table.aggregate [Group_By "Index", Group_By "Flag", Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.column_count . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 1 . name . should_equal "Flag"
            idx = find_row [6, False] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 2 . name . should_equal "Concatenate Code"
            materialized.columns.at 2 . at idx . length . should_equal 381

    Test.group prefix+"Table.aggregate Shortest" (pending = resolve_pending test_selection.text_shortest_longest) <|
        Test.specify "should correctly handle empty strings versus missing (null) strings" <|
            table = table_builder [["A", ["abcd", "f", ""]], ["B", [Nothing, "f", "abc"]]]
            result = table.aggregate [Shortest "A", Shortest "B"]
            result.row_count . should_equal 1
            materialized = materialize result
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "Shortest A"
            materialized.columns.at 0 . to_vector . should_equal [""]
            materialized.columns.at 1 . name . should_equal "Shortest B"
            materialized.columns.at 1 . to_vector . should_equal ["f"]

    Test.group prefix+"Table.aggregate Concatenate" (pending = resolve_pending test_selection.text_concat) <|
        Test.specify "should insert the separator, add prefix and suffix" <|
            table = table_builder [["A", ["foo", "bar", "foo", "foo"]], ["B", ["a", "b", "c", "d"]]]
            result = table.aggregate [Group_By "A", (Concatenate "B" prefix="[[" suffix="]]" separator="; ")]
            result.row_count . should_equal 2
            materialized = materialize result . order_by ([Sort_Column.Name "A"])
            materialized.column_count . should_equal 2
            materialized.columns.at 0 . name . should_equal "A"
            materialized.columns.at 0 . to_vector . should_equal ["bar", "foo"]
            materialized.columns.at 1 . name . should_equal "Concatenate B"
            materialized.columns.at 1 . to_vector . should_equal ["[[b]]", "[[a; c; d]]"]

        Test.specify "should correctly escape separator and quote characters but only if necessary" <|
            table = table_builder [["A", ["1,0", "b", "'c", "''", ","]]]
            result = table.aggregate [(Concatenate "A" prefix="[[" suffix="]]" separator="," quote_char="'")]
            result.row_count . should_equal 1
            materialized = materialize result
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate A"
            materialized.columns.at 0 . to_vector . should_equal ["[['1,0',b,'''c','''''',',']]"]

        Test.specify "should correctly handle missing values and empty values with quote character" <|
            table = table_builder [["A", ["1,0", "A", "", "", "B", Nothing, Nothing, "C"]]]
            result = table.aggregate [(Concatenate "A" prefix="[[" suffix="]]" separator="," quote_char="'")]
            result.row_count . should_equal 1
            materialized = materialize result
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate A"
            materialized.columns.at 0 . to_vector . should_equal ["[['1,0',A,'','',B,,,C]]"]

        Test.specify "will not be able to distinguish missing values from empty values without quote character" <|
            table = table_builder [["A", ["1,0", "A", "", "", "B", Nothing, Nothing, "C"]]]
            result = table.aggregate [(Concatenate "A" prefix="[[" suffix="]]" separator=",")]
            result.row_count . should_equal 1
            materialized = materialize result
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate A"
            materialized.columns.at 0 . to_vector . should_equal ["[[1,0,A,,,B,,,C]]"]

        Test.specify "should work with empty separator" <|
            table = table_builder [["A", ["1,0", "A", "", "", "B", Nothing, Nothing, "C"]]]
            result = table.aggregate [(Concatenate "A")]
            result.row_count . should_equal 1
            materialized = materialize result
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate A"
            materialized.columns.at 0 . to_vector . should_equal ["1,0ABC"]

        Test.specify "should work with empty separator but non-empty quote" <|
            table = table_builder [["A", ["1'0", "A", "", "", "B", Nothing, Nothing, "C"]]]
            result = table.aggregate [(Concatenate "A" quote_char="'")]
            result.row_count . should_equal 1
            materialized = materialize result
            materialized.column_count . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate A"
            materialized.columns.at 0 . to_vector . should_equal ["'1''0'A''''BC"]

    Test.group prefix+"Table.aggregate Count_Distinct" <|
        Test.specify "should correctly count missing values" <|
            get_value t =
                columns = materialize t . columns
                columns.length . should_equal 1 frames_to_skip=1
                columns.first.length  . should_equal 1 frames_to_skip=1
                columns.first . at 0

            t1 = table_builder [["A", []]]
            get_value (t1.aggregate [Count_Distinct "A" (ignore_nothing=True)]) . should_equal 0
            get_value (t1.aggregate [Count_Distinct "A" (ignore_nothing=False)]) . should_equal 0

            t2 = table_builder [["A", [Nothing, Nothing]]]
            get_value (t2.aggregate [Count_Distinct "A" (ignore_nothing=True)]) . should_equal 0
            get_value (t2.aggregate [Count_Distinct "A" (ignore_nothing=False)]) . should_equal 1

            t3 = table_builder [["A", [1, 2]]]
            get_value (t3.aggregate [Count_Distinct "A" (ignore_nothing=True)]) . should_equal 2
            get_value (t3.aggregate [Count_Distinct "A" (ignore_nothing=False)]) . should_equal 2

            t4 = table_builder [["A", [1, 2, Nothing, Nothing]]]
            get_value (t4.aggregate [Count_Distinct "A" (ignore_nothing=True)]) . should_equal 2
            get_value (t4.aggregate [Count_Distinct "A" (ignore_nothing=False)]) . should_equal 3

            t5 = table_builder [["G", ["foo", "foo", "bar", "foo"]], ["A", [Nothing, 0, Nothing, Nothing]]]

            r1 = t5.aggregate [Group_By "G", Count_Distinct "A" (ignore_nothing=True)]
            r1.row_count . should_equal 2
            m1 = materialize r1 . order_by ([Sort_Column.Name "G"])
            m1.column_count . should_equal 2
            m1.columns.first.to_vector . should_equal ["bar", "foo"]
            m1.columns.second.to_vector . should_equal [0, 1]

            r2 = t5.aggregate [Group_By "G", Count_Distinct "A" (ignore_nothing=False)]
            r2.row_count . should_equal 2
            m2 = materialize r2 . order_by ([Sort_Column.Name "G"])
            m2.column_count . should_equal 2
            m2.columns.first.to_vector . should_equal ["bar", "foo"]
            m2.columns.second.to_vector . should_equal [1, 2]

        Test.specify "should correctly count all-null keys in multi-column mode" (pending = resolve_pending test_selection.multi_distinct) <|
            table = table_builder [["A", ["foo", "foo", Nothing, Nothing, Nothing]], ["B", ["baz", Nothing, Nothing, Nothing, "baz"]], ["C", [1, 2, 3, Nothing, 5]]]

            r2 = table.aggregate [Count_Distinct ["A", "B"] (ignore_nothing=False)]
            r2.row_count.should_equal 1
            m2 = materialize r2
            m2.column_count.should_equal 1
            m2.columns.first.name . should_equal "Count Distinct A B"
            m2.columns.first.to_vector . should_equal [4]

            r1 = table.aggregate [Count_Distinct ["A", "B"] (ignore_nothing=True)]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count.should_equal 1
            m1.columns.first.name . should_equal "Count Distinct A B"
            m1.columns.first.to_vector . should_equal [3]

    Test.group prefix+"Table.aggregate Standard_Deviation" pending=(resolve_pending test_selection.std_dev) <|
        Test.specify "should correctly handle single elements" <|
            r1 = table_builder [["X", [1]]] . aggregate [Standard_Deviation "X" (population=False), Standard_Deviation "X" (population=True)]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 2
            m1.columns.first.at 0 . should_equal Nothing
            m1.columns.second.at 0 . should_equal 0

    Test.group prefix+"Table.aggregate should correctly select result types" <|
        Test.specify "widening to decimals on Average" <|
            table = table_builder [["G", ["a", "a", "b", "b"]], ["X", [0, 1, 1, Nothing]]]
            r1 = table.aggregate [Average "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            m1.columns.first.at 0 . should_equal (2/3) epsilon=0.00001

            r2 = table.aggregate [Group_By "G", Average "X"]
            r2.row_count.should_equal 2
            m2 = materialize r2 . order_by ([Sort_Column.Name "G"])
            m2.column_count . should_equal 2
            m2.columns.first.to_vector . should_equal ["a", "b"]
            m2.columns.second.to_vector . should_equal [0.5, 1]

        Test.specify "widening to decimals on Median" (pending = resolve_pending test_selection.advanced_stats) <|
            table = table_builder [["X", [-1000, 0, 1, 100000, Nothing]]]
            r1 = table.aggregate [Median "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            m1.columns.first.to_vector . should_equal [0.5]

        Test.specify "widening to decimals on Percentile" (pending = resolve_pending test_selection.advanced_stats) <|
            table = table_builder [["X", [1, 2, 3, 4, 5, 6, Nothing]]]
            r1 = table.aggregate [Percentile 0.3 "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            m1.columns.first.to_vector . should_equal [2.5]

        Test.specify "widening to decimals on Standard_Deviation" (pending = resolve_pending test_selection.std_dev) <|
            table = table_builder [["X", [1, 2, 3, 4, Nothing]]]
            r1 = table.aggregate [Standard_Deviation "X" (population=True), Standard_Deviation "X" (population=False)]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 2
            m1.columns.first.at 0 . should_equal 1.1180339887499 epsilon=0.000001
            m1.columns.second.at 0 . should_equal 1.2909944487358 epsilon=0.000001

    expect_null_or_nan value =
        matches = case value of
            Nothing -> True
            _ : Decimal -> Double.isNaN value
            _       -> False
        if matches.not then
            loc = Meta.get_source_location 2
            Test.fail "Expected a Nothing or NaN but got: "+value.to_text+" (at "+loc+")."

    Test.group prefix+"Table.aggregate should correctly handle infinities" <|
        pos_inf = 1/0
        neg_inf = -1/0
        Test.specify "on Average" <|
            t1 = table_builder [["X", [Nothing, pos_inf, pos_inf, 0]]]
            r1 = t1.aggregate [Average "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            m1.columns.first.at 0 . should_equal pos_inf

            t2 = table_builder [["X", [Nothing, pos_inf, neg_inf, 0]]]
            r2 = t2.aggregate [Average "X"]
            r2.row_count.should_equal 1
            m2 = materialize r2
            m2.column_count . should_equal 1
            expect_null_or_nan <| m2.columns.first.at 0

        Test.specify "on Median" (pending = resolve_pending test_selection.advanced_stats) <|
            t1 = table_builder [["X", [Nothing, neg_inf, pos_inf, 0, pos_inf, pos_inf]]]
            r1 = t1.aggregate [Median "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            m1.columns.first.at 0 . should_equal pos_inf

            t2 = table_builder [["X", [pos_inf, pos_inf, neg_inf, neg_inf]]]
            r2 = t2.aggregate [Median "X"]
            r2.row_count.should_equal 1
            m2 = materialize r2
            m2.column_count . should_equal 1
            expect_null_or_nan <| m2.columns.first.at 0

            t3 = table_builder [["X", [pos_inf, pos_inf, Nothing, 0, 10, 20, neg_inf, neg_inf]]]
            r3 = t3.aggregate [Median "X"]
            r3.row_count.should_equal 1
            m3 = materialize r3
            m3.column_count . should_equal 1
            m3.columns.first.at 0 . should_equal 10

            t4 = table_builder [["X", [Nothing, pos_inf, pos_inf, 10, 12]]]
            r4 = t4.aggregate [Median "X"]
            r4.row_count.should_equal 1
            m4 = materialize r4
            m4.column_count . should_equal 1
            m4.columns.first.at 0 . should_equal pos_inf

        Test.specify "on Percentile" (pending = resolve_pending test_selection.advanced_stats) <|
            t1 = table_builder [["X", [Nothing, neg_inf, 2, 3, 4, pos_inf]]]
            r1 = t1.aggregate [Percentile 0.3 "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            m1.columns.first.at 0 . should_equal 2.2

            t2 = table_builder [["X", [Nothing, neg_inf, neg_inf, 3, 4, pos_inf]]]
            r2 = t2.aggregate [Percentile 0.25 "X"]
            r2.row_count.should_equal 1
            m2 = materialize r2
            m2.column_count . should_equal 1
            m2.columns.first.at 0 . should_equal neg_inf

            t3 = table_builder [["X", [Nothing, neg_inf, neg_inf, pos_inf, pos_inf, pos_inf]]]
            r3 = t3.aggregate [Percentile 0.3 "X"]
            r3.row_count.should_equal 1
            m3 = materialize r3
            m3.column_count . should_equal 1
            expect_null_or_nan <| m3.columns.first.at 0

        Test.specify "on Standard_Deviation" (pending = resolve_pending test_selection.std_dev) <|
            t1 = table_builder [["X", [neg_inf, 1]]]
            r1 = t1.aggregate [Standard_Deviation "X" (population=True), Standard_Deviation "X" (population=False)]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 2
            expect_null_or_nan <| m1.columns.first.at 0
            expect_null_or_nan <| m1.columns.second.at 0

    Test.group prefix+"Table.aggregate should correctly handle NaN" pending=(resolve_pending test_selection.nan) <|
        nan = 0.log 0
        Test.specify "on Average" <|
            t1 = table_builder [["X", [Nothing, nan, 0, 1, 2]]]
            r1 = t1.aggregate [Average "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            Double.isNaN (m1.columns.first.at 0) . should_be_true

        Test.specify "on Median" (pending = resolve_pending test_selection.advanced_stats) <|
            t1 = table_builder [["X", [Nothing, nan, 0, 1, 2]]]
            r1 = t1.aggregate [Median "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            Double.isNaN (m1.columns.first.at 0) . should_be_true

        Test.specify "on Percentile" (pending = resolve_pending test_selection.advanced_stats) <|
            t1 = table_builder [["X", [Nothing, nan, 0, 1, 2, 4, 5]]]
            r1 = t1.aggregate [Percentile 0.3 "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            Double.isNaN (m1.columns.first.at 0) . should_be_true

        Test.specify "on Mode" (pending = resolve_pending test_selection.advanced_stats) <|
            t1 = table_builder [["X", [Nothing, nan, nan, nan, nan, 4, 5]]]
            r1 = t1.aggregate [Mode "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            Double.isNaN (m1.columns.first.at 0) . should_be_true

        Test.specify "on Standard_Deviation" (pending = resolve_pending test_selection.std_dev) <|
            t1 = table_builder [["X", [Nothing, nan, 0, 1, 2]]]
            r1 = t1.aggregate [Standard_Deviation "X" (population=False), Standard_Deviation "X" (population=True)]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 2
            Double.isNaN (m1.columns.first.at 0) . should_be_true
            Double.isNaN (m1.columns.second.at 0) . should_be_true

    Test.group prefix+"Table.aggregate Mode" (pending = resolve_pending test_selection.advanced_stats) <|
        Test.specify "should ignore missing values" <|
            t1 = table_builder [["X", [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, 2, 2, 1]]]
            r1 = t1.aggregate [Mode "X"]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 1
            m1.columns.first.at 0 . should_equal 2

    Test.group prefix+"Table.aggregate First and Last" <|
        Test.specify "should not return the same value for groups with different values but equal ordering keys" (pending = resolve_pending test_selection.first_last) <|
            t1 = table_builder [["G", ["a", "a"]], ["X", [1, 2]]]
            order = [Sort_Column.Name "G"]
            r1 = t1.aggregate [First "X" (order_by=order), Last "X" (order_by=order)]
            r1.row_count.should_equal 1
            m1 = materialize r1
            m1.column_count . should_equal 2
            first = m1.columns.first.at 0
            last = m1.columns.second.at 0
            (first != last).should_be_true

    Test.group prefix+"Table.aggregate" <|
        Test.specify "should work even if no aggregations apart from groupings are specified" <|
            table = table_builder [["A", [1, 1, 2, 1]], ["B", [3, 2, 2, 3]], ["C", [11, 12, 13, 14]]]
            grouped = table.aggregate [Group_By "B", Group_By "A"]
            grouped.row_count . should_equal 3
            materialized = materialize grouped . order_by ([Sort_Column.Name "A", Sort_Column.Name "B"])
            materialized.column_count . should_equal 2
            materialized.columns.at 1 . name . should_equal "A"
            materialized.columns.at 1 . to_vector . should_equal [1, 1, 2]
            materialized.columns.at 0 . name . should_equal "B"
            materialized.columns.at 0 . to_vector . should_equal [2, 3, 2]

        if setup.test_selection.supports_unicode_normalization then
            Test.specify "should correctly handle Unicode normalization within grouping" <|
                table = table_builder [["A", ['s', 's\u0301', '', 's\u0301']], ["B", [1, 2, 4, 8]]]
                grouped = table.aggregate [Group_By "A", Sum "B"]
                grouped.row_count . should_equal 2
                materialized = materialize grouped . order_by ["A"]
                materialized.column_count . should_equal 2
                materialized.columns.at 0 . name . should_equal "A"
                materialized.columns.at 0 . to_vector . should_equal ['s', '']
                materialized.columns.at 1 . name . should_equal "Sum B"
                materialized.columns.at 1 . to_vector . should_equal [1, 14]

        if test_selection.date_support then
            Test.specify "should allow grouping by dates" <|
                dates = ["Date", [Date.new 1997, Date.new 2000 2 2, Date.new 2022 12 31, Date.new 2000 2 2, Date.new 1997]]
                times = ["Time", [Time_Of_Day.new, Time_Of_Day.new 0 0 0 500 100 900, Time_Of_Day.new 1 2 3, Time_Of_Day.new 0 0 0, Time_Of_Day.new 11 25 40]]
                datetimes = ["DateTime", [Date_Time.new 1999, Date_Time.new 2022 8 29 17 28 5, Date_Time.new 1999 1 1 0 0 0, Date_Time.new 1998, Date_Time.new 1998]]
                ints = ["Int", [1, 2, 4, 8, 16]]
                table = table_builder [dates, times, datetimes, ints]

                g1 = table.aggregate [Group_By "Date", Sum "Int"]
                m1 = materialize g1 . order_by (["Date"])
                m1.at "Date" . to_vector . should_equal [Date.new 1997, Date.new 2000 2 2, Date.new 2022 12 31]
                m1.at "Sum Int" . to_vector . should_equal [17, 10, 4]

                g2 = table.aggregate [Group_By "Time", Sum "Int"]
                m2 = materialize g2 . order_by (["Time"])
                m2.at "Time" . to_vector . should_equal [Time_Of_Day.new, Time_Of_Day.new 0 0 0 500 100 900, Time_Of_Day.new 1 2 3, Time_Of_Day.new 11 25 40]
                m2.at "Sum Int" . to_vector . should_equal [9, 2, 4, 16]

                g3 = table.aggregate [Group_By "DateTime", Sum "Int"]
                m3 = materialize g3 . order_by (["DateTime"])
                m3.at "DateTime" . to_vector . should_equal [Date_Time.new 1998, Date_Time.new 1999, Date_Time.new 2022 8 29 17 28 5]
                m3.at "Sum Int" . to_vector . should_equal [24, 5, 2]

        if test_selection.first_last && test_selection.first_last_row_order.not then
            Test.specify "should report a warning and ignore problematic columns if a feature is not supported" <|
                table = table_builder [["A", [1,2,Nothing,3]]]
                action = table.aggregate [Sum "A", First "A", Last "A"] on_problems=_
                tester result =
                    result.row_count . should_equal 1
                    materialized = materialize result
                    materialized.column_count . should_equal 1
                    materialized.columns.first.name . should_equal "Sum A"
                    materialized.columns.first.to_vector . should_equal [6]
                problems = [Unsupported_Database_Operation.Error "`First` aggregation requires at least one `order_by` column.", Unsupported_Database_Operation.Error "`Last` aggregation requires at least one `order_by` column."]
                Problems.test_problem_handling action problems tester

    Test.group prefix+"Table.aggregate+Expressions" <|
        ## TODO we probably should check all kinds of aggregate columns
           to verify that  all of them correctly support expressions.
        Test.specify "should allow expressions in aggregates" <|
            table = table_builder [["Index", [1, 1, 2, 2]], ["Value", [1, 2, 3, 4]]]
            t1 = table.aggregate [Group_By "Index", Sum "Value", Sum "[Value]*[Value]"]
            t1.column_count . should_equal 3
            r1 =  t1 |> materialize |> _.order_by "Index"
            r1.at "Index" . to_vector . should_equal [1, 2]
            r1.at "Sum Value" . to_vector . should_equal [3, 7]
            # Not using by name, as naming is not yet consistent between backends.
            # r1.at "Sum [Value]*[Value]" . to_vector . should_equal [5, 25]
            r1.at -1 . to_vector . should_equal [5, 25]

        Test.specify "should warn when encountering invalid expressions, but try to perform the aggregations that are still valid" <|
            action1 = table.aggregate [Group_By "Index", Sum "Value", Sum "[MISSING]*[MISSING]"] on_problems=_
            tester1 = expect_column_names ["Index", "Sum Value"]
            problems1 = [Invalid_Aggregate_Column.Error "[MISSING]*[MISSING]" (No_Such_Column.Error "MISSING")]
            Problems.test_problem_handling action1 problems1 tester1

            t2 = table.aggregate [Group_By "Index", Sum "Value", Sum "[[["] on_problems=Problem_Behavior.Ignore
            expect_column_names ["Index", "Sum Value"] t2
            err3 = table.aggregate [Group_By "Index", Sum "Value", Sum "[[["] on_problems=Problem_Behavior.Report_Error
            err3.should_fail_with Invalid_Aggregate_Column
            err3.catch.name . should_equal "[[["
            err3.catch.expression_error . should_be_a Expression_Error.Syntax_Error

            t4 = table.aggregate [Sum "[MISSING]*[MISSING]"]
            t4 . should_fail_with Invalid_Aggregate_Column
            err4 = t4.catch
            err4.name.should_equal "[MISSING]*[MISSING]"
            err4.expression_error.should_equal (No_Such_Column.Error "MISSING")

    Test.group prefix+"Table.aggregate should raise warnings when there are issues" pending=(resolve_pending test_selection.problem_handling) <|
        table =
            col1 = ["Index", [1, 2, 3]]
            col2 = ["Value", [1, 2, 3]]
            table_builder [col1, col2]

        Test.specify "should fail if there are no output columns, and promote any warnings to errors" <|
            [Problem_Behavior.Ignore, Problem_Behavior.Report_Warning, Problem_Behavior.Report_Error].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+": " <|
                t1 = table.aggregate [] on_problems=pb
                t1.should_fail_with No_Output_Columns

            t2 = table.aggregate [Sum "MISSING"]
            t2 . should_fail_with Invalid_Aggregate_Column
            t2.catch.name.should_equal "MISSING"

            t3 = table.aggregate [Sum 42]
            t3 . should_fail_with Column_Indexes_Out_Of_Range
            t3.catch.indexes.should_equal [42]

        Test.specify "should raise a warning when can't find a column by name, but a hard error if the missing column is in a Group_By" <|
            err1 = table.aggregate [Group_By "Missing", Group_By "Index", Group_By "Other_Missing"] on_problems=Problem_Behavior.Ignore
            err1.should_fail_with Invalid_Aggregate_Column
            err1.catch.name . should_equal "Missing"

            t1 = table.aggregate [Group_By "Index", Sum "Value", Sum "Missing"] on_problems=Problem_Behavior.Report_Warning
            t1.column_names . should_equal ["Index", "Sum Value"]
            warnings = Problems.get_attached_warnings t1
            warnings.not_empty . should_be_true
            warnings.first.should_be_a Invalid_Aggregate_Column
            warnings.first.name.should_equal "Missing"

            ## Even if there are missing columns both for group-by and
               aggregations, the groupby errors are reported separately.
            err2 = table.aggregate [Group_By "Index", Group_By "Unknown", Sum "Value", Sum "Missing", Group_By "Other Missing"] on_problems=Problem_Behavior.Report_Error
            err2.should_fail_with Invalid_Aggregate_Column
            err2.catch.name.should_equal "Unknown"

            err3 = table.aggregate [Group_By "Index", Sum "Value", Sum "Missing"] on_problems=Problem_Behavior.Ignore error_on_missing_columns=True
            err3.should_fail_with Invalid_Aggregate_Column
            err3.catch.name.should_equal "Missing"

            err4 = table.aggregate [Group_By 100, Group_By "Index", Group_By -42] on_problems=Problem_Behavior.Ignore
            err4.should_fail_with Column_Indexes_Out_Of_Range
            err4.catch.indexes.should_equal [100, -42]

            action2 = table.aggregate [Group_By "Index", Sum "Value", Sum 42] on_problems=_
            problems2 = [Column_Indexes_Out_Of_Range.Error [42]]
            tester2 = expect_column_names ["Index", "Sum Value"]
            Problems.test_problem_handling action2 problems2 tester2

            # As above, missing errors from group-by take precedence over aggregates.
            err5 = table.aggregate [Group_By "Index", Group_By 55, Sum "Value", Sum 144, Group_By -33] on_problems=Problem_Behavior.Report_Error
            err5.should_fail_with Column_Indexes_Out_Of_Range
            err5.catch.indexes.should_equal [55, -33]

            err6 = table.aggregate [Group_By "Index", Sum "Value", Sum 42] on_problems=Problem_Behavior.Ignore error_on_missing_columns=True
            err6.catch . should_equal (Column_Indexes_Out_Of_Range.Error [42])

        Test.specify "should raise a warning when an invalid output name" <|
            action = table.aggregate [Group_By "Index" ""] on_problems=_
            problems = [Invalid_Output_Column_Names.Error [""]]
            tester = expect_column_names ["Column_1"]
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when a duplicate column name" <|
            action = table.aggregate [Group_By "Index", Group_By 0] on_problems=_
            problems = [Duplicate_Output_Column_Names.Error ["Index"]]
            tester = expect_column_names ["Index", "Index_1"]
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when a duplicate column name and rename default names first" <|
            action = table.aggregate [Group_By "Value", Group_By "Index" "Value"] on_problems=_
            problems = [Duplicate_Output_Column_Names.Error ["Value"]]
            tester = expect_column_names ["Value_1", "Value"]
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when duplicate column names" <|
            action = table.aggregate [Sum "Value" new_name="AGG1", Count new_name="AGG1"] on_problems=_
            problems = [Duplicate_Output_Column_Names.Error ["AGG1"]]
            tester = expect_column_names ["AGG1", "AGG1_1"]
            Problems.test_problem_handling action problems tester

        Test.specify "should allow partial matches on Count_Distinct" <|
            action = table.aggregate [Count_Distinct ["Missing", "Value"]] on_problems=_
            problems = [Missing_Input_Columns.Error ["Missing"]]
            tester = expect_column_names ["Count Distinct Value"]
            Problems.test_problem_handling action problems tester

        Test.specify "should ignore Count_Distinct if no columns matched" <|
            action = table.aggregate [Count_Distinct [-100], Count] on_problems=_
            problems = [Column_Indexes_Out_Of_Range.Error [-100]]
            tester = expect_column_names ["Count"]
            Problems.test_problem_handling action problems tester

    Test.group prefix+"Table.aggregate should raise warnings when there are issues computing aggregation" pending=(resolve_pending test_selection.aggregation_problems) <|
        table =
            col1 = ["Index", [1, 2, 3]]
            col2 = ["Value", [1, 2, 3.1]]
            col3 = ["Text", ["A", ",", "C"]]
            col4 = ["Mixed", ["A", 1, "C"]]
            Table.new [col1, col2, col3, col4]

        Test.specify "should warn if grouping on a floating point" <|
            action = table.aggregate [Group_By 1] on_problems=_
            # All rows are marked as floating point, because the integers get coerced to double when stored in DoubleStorage
            problems = [Floating_Point_Equality.Error "Value"]
            tester = expect_column_names ["Value"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if totaling on a non number" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Sum "Text"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Sum Text" [0] "Cannot convert to a number.")
                err.catch.to_display_text . should_equal "The Sum Text could not be calculated at [0]: Cannot convert to a number."

        Test.specify "should warn if averaging on a non number" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Average "Text"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Average Text" [0] "Cannot convert to a number.")

        Test.specify "should warn if calculating standard deviation on a non number" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Standard_Deviation "Text"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Standard Deviation Text" [0] "Cannot convert to a number.")

        Test.specify "should warn if median on a non number" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Median "Text"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Median Text" [0] "Cannot convert to a number.")

        Test.specify "should warn if trying shortest on a non text" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Shortest "Index"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Shortest Index" [0] "Not a text value.")

        Test.specify "should warn if trying count empties on a non text" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Count_Empty "Index"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Count Empty Index" [0] "Not a text value.")

        Test.specify "should warn if trying concatenate on a non text" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Concatenate "Index"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Concatenate Index" [0] "Not a text value.")

        Test.specify "should warn if trying concatenate unquoted delimiters" <|
            column = Concatenate "Text" separator=","
            action = table.aggregate [column] on_problems=_
            problems = [Unquoted_Delimiter.Error "Concatenate Text" [1]]
            tester = expect_column_names ["Concatenate Text"]
            Problems.test_problem_handling action problems tester

        Test.specify "should not fail if trying concatenate unquoted delimiters with no separator" <|
            column = Concatenate "Text" separator=""
            t = table_builder [["Text", ["A", "BC", "def"]]]
            result = t.aggregate [column] on_problems=Report_Error
            Problems.assume_no_problems result
            result.column_names . should_equal ["Concatenate Text"]
            result.at "Concatenate Text" . to_vector . should_equal ["ABCdef"]

        Test.specify "should warn if can't compare value for Min or Max" <|
            [Problem_Behavior.Report_Error, Problem_Behavior.Report_Warning, Problem_Behavior.Ignore].each pb-> Test.with_clue "Problem_Behavior="+pb.to_text+" " <|
                err = table.aggregate [Maximum "Mixed"] on_problems=pb
                err.should_fail_with Invalid_Aggregation
                err.catch . should_equal (Invalid_Aggregation.Error "Maximum Mixed" [1] "Cannot compare values.")

    Test.group prefix+"Table.aggregate should merge warnings when issues computing aggregation" pending=(resolve_pending test_selection.aggregation_problems) <|
        table =
            col1 = ["Key", ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"]]
            col2 = ["Value", [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]]
            col3 = ["Float", col2.second.map x->(1.5*x)]
            Table.new [col1, col2, col3]

        Test.specify "should merge Invalid Aggregation warnings" <|
            new_table = table.aggregate [Group_By "Key", Concatenate "Value"]
            err = new_table.catch
            err . should_be_a Invalid_Aggregation.Error
            err.column . should_equal "Concatenate Value"
            err.rows . length . should_equal 15

        Test.specify "should merge Floating Point Grouping warnings" <|
            new_table = table.aggregate [Group_By "Float", Count]
            problems = Problems.get_attached_warnings new_table
            problems.length . should_equal 1
            problems.at 0 . is_a Floating_Point_Equality.Error . should_be_true
            problems.at 0 . location . should_equal "Float"

    if is_database then
        Test.group prefix+"Table.aggregate should report unsupported operations but not block other aggregations in warning mode" <|
            expect_sum_and_unsupported_errors error_count result =
                result.column_count . should_equal 1
                result.row_count . should_equal 1
                result.columns.first.to_vector . should_equal [6]
                warnings = Problems.get_attached_warnings result
                warnings.length . should_equal error_count
                warnings.each warning->
                    warning.should_be_an Unsupported_Database_Operation.Error

            if test_selection.first_last_row_order.not then
                Test.specify "with First and Last in row order" <|
                    table = table_builder [["X", [1,2,3]]]
                    expect_sum_and_unsupported_errors 2 <|
                        table.aggregate [Sum "X", First "X", Last "X"]

            if test_selection.first_last.not then
                Test.specify "with First and Last with ordering" <|
                    table = table_builder [["A", [3,2,1]], ["X", [1,2,3]]]
                    order = [Sort_Column.Name "A"]
                    expect_sum_and_unsupported_errors 2 <|
                        table.aggregate [Sum "X", First "X" (order_by=order), Last "X" (order_by=order)]

            if test_selection.advanced_stats.not then
                Test.specify "with Median, Mode and Percentile" <|
                    table = table_builder [["X", [1,2,3]]]
                    expect_sum_and_unsupported_errors 3 <|
                        table.aggregate [Sum "X", Median "X", Mode "X", Percentile 0.3 "X"]

            if test_selection.std_dev.not then
                Test.specify "with Standard_Deviation" <|
                    table = table_builder [["X", [1,2,3]]]
                    expect_sum_and_unsupported_errors 1 <|
                        table.aggregate [Sum "X", Standard_Deviation "X"]

            if test_selection.text_shortest_longest.not then
                Test.specify "with Shortest and Longest" <|
                    table = table_builder [["X", [1,2,3]], ["Y", ["a", "bb", "ccc"]]]
                    expect_sum_and_unsupported_errors 2 <|
                        table.aggregate [Sum "X", Shortest "Y", Longest "Y"]

            if test_selection.text_concat.not then
                Test.specify "with Concatenate" <|
                    table = table_builder [["X", [1,2,3]], ["Y", ["a", "bb", "ccc"]]]
                    expect_sum_and_unsupported_errors 1 <|
                        table.aggregate [Sum "X", Concatenate "Y"]

            if test_selection.multi_distinct.not then
                Test.specify "with Count_Distinct on multiple fields" <|
                    table = table_builder [["X", [1,2,3]], ["Y", ["a", "bb", "ccc"]]]
                    expect_sum_and_unsupported_errors 1 <|
                        table.aggregate [Sum "X", Count_Distinct ["X", "Y"]]
