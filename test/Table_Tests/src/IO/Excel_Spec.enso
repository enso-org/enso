from Standard.Base import all
import Standard.Base.Errors.Common.Dry_Run_Operation
import Standard.Base.Errors.Common.Missing_Argument
import Standard.Base.Errors.File_Error.File_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Runtime.Context
import Standard.Base.Runtime.Managed_Resource.Managed_Resource
import Standard.Base.Runtime.Ref.Ref

from Standard.Table import Table, Match_Columns, Excel_Format, Excel_Range, Data_Formatter, Delimited_Format, Excel_Workbook

from Standard.Table.Errors import Invalid_Column_Names, Duplicate_Output_Column_Names, Invalid_Location, Range_Exceeded, Existing_Data, Column_Count_Mismatch, Column_Name_Mismatch, Empty_Sheet

from Standard.Test import all


import Standard.Examples

import project.Util

polyglot java import org.enso.table_test_helpers.RandomHelpers

spec_fmt suite_builder header file read_method sheet_count=5 =
    suite_builder.group header group_builder->
        group_builder.specify "should read a workbook in" <|
            wb = read_method file
            wb.sheet_count . should_equal sheet_count

        group_builder.specify "should read the specified sheet by index and use correct headers" <|
            t = read_method file (..Sheet 1)
            t.columns.map .name . should_equal ['Name', 'Quantity', 'Price']
            t.at 'Name' . to_vector . should_equal ['blouse', 't-shirt', 'trousers', 'shoes', 'skirt', 'dress']
            t.at 'Quantity' . to_vector . should_equal [10, 20, Nothing, 30, Nothing, 5]
            t.at 'Price' . to_vector . should_equal [22.3, 32, 43.2, 54, 31, Nothing]

        group_builder.specify "should read the specified sheet by index and properly format a table" <|
            t = read_method file (..Sheet 2 headers=False)
            t.columns.map .name . should_equal ['A', 'B', 'C', 'D', 'E']
            t.at 'A' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            t.at 'B' . to_vector . should_equal [Nothing, Nothing, 10, Nothing, Nothing, Nothing, Nothing]
            t.at 'C' . to_vector . should_equal [Nothing, 'baz', 20, Nothing, 'bar', Nothing, 30]
            t.at 'D' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            t.at 'E' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, 'foo', Nothing]

        group_builder.specify "should read the specified sheet by name and properly handle dates" <|
            t = read_method file (..Sheet 'Dates')
            t.columns.map .name . should_equal ['Student Name', 'Enrolment Date']
            t.at 'Enrolment Date' . map .day . to_vector . should_equal [2, 26, 4, 24, 31, 7]

        group_builder.specify "should give an informative error when reading an empty table" <|
            t = read_method file (..Sheet "Empty")
            t.should_fail_with Empty_Sheet

        group_builder.specify "should gracefully handle duplicate column names and formulas" <|
            t = read_method file (..Sheet "Duplicate Columns")
            t.columns.map .name . should_equal ['Item', 'Price', 'Quantity', 'Price 1']
            t.at 'Price 1' . to_vector . should_equal [20, 40, 0, 60, 0, 10]

        group_builder.specify "should allow reading with cell range specified" <|
            t_1 = read_method file (..Range "Simple!B:C")
            t_1.columns.map .name . should_equal ['Quantity', 'Price']
            t_1.at 'Quantity' . to_vector . should_equal [10, 20, Nothing, 30, Nothing, 5]
            t_1.at 'Price' . to_vector . should_equal [22.3, 32, 43.2, 54, 31, Nothing]

            t_2 = read_method file (..Range "Simple!3:5" headers=False)
            t_2.column_count.should_equal 3
            t_2.at 'A' . to_vector . should_equal ['t-shirt', 'trousers', 'shoes']
            t_2.at 'B' . to_vector . should_equal [20, Nothing, 30]
            t_2.at 'C' . to_vector . should_equal [32, 43.2, 54]

            t_3 = read_method file (..Range "Simple!B4:C5" headers=False)
            t_3.column_count.should_equal 2
            t_3.at 'B' . to_vector . should_equal [Nothing, 30]
            t_3.at 'C' . to_vector . should_equal [43.2, 54]

        group_builder.specify "should let you read all sheets into a single table" <|
            wb = read_method file
            action = wb.read_many on_problems=_
            tester table =
                table.row_count . should_equal 25
                table.column_names . should_equal ["Sheet Name", "Name", "Quantity", "Price", "A", "B", "C", "D", "E", "Student Name", "Enrolment Date", "Item", "Price 1"]
            problems = [Empty_Sheet.Error, Duplicate_Output_Column_Names.Error ["Price"]]
            Problems.test_problem_handling action problems tester ignore_warning_cardinality=True

        group_builder.specify "should let you read all sheets into a table of tables" <|
            wb = read_method file
            action = wb.read_many return=..Table_Of_Tables on_problems=_
            tester table =
                table.row_count . should_equal 5
                table.column_names . should_equal ["Sheet Name", "Table"]
            problems = [Empty_Sheet.Error, Duplicate_Output_Column_Names.Error ["Price"]]
            Problems.test_problem_handling action problems tester ignore_warning_cardinality=True

        group_builder.specify "should let you read some sheets from xlsx" <|
            wb = read_method file
            single_table = wb.read_many ["Simple", "Dates"]
            single_table.row_count . should_equal 12
            single_table.column_names . should_equal ["Sheet Name", "Name", "Quantity", "Price", "Student Name", "Enrolment Date"]
            Problems.assume_no_problems single_table

        group_builder.specify "should let you read some sheets with a bad name from xlsx" <|
            wb = read_method file
            single_table = wb.read_many ["Simple", "Dates", "Not A Sheet"]
            single_table.row_count . should_equal 12
            single_table.column_names . should_equal ["Sheet Name", "Name", "Quantity", "Price", "Student Name", "Enrolment Date"]
            single_table.has_warnings.should_be_true
            warning = Problems.expect_only_warning Invalid_Location single_table
            warning.location . should_equal "Not A Sheet"
            warning.to_display_text . should_contain "Unknown sheet or range name or invalid address: 'Not A Sheet'."

type Spec_Write_Data
    Value ~data counter suffix prefix

    table self = self.data.at 0
    clothes self = self.data.at 1
    sub_clothes self = self.data.at 2

    setup suffix =
        table = enso_project.data/'varied_column.csv' . read
        clothes = enso_project.data/'clothes.csv' . read
        sub_clothes = clothes.select_columns [0, 1]
        counter = Ref.new 0
        prefix = "out_" + (Random.integer 1 10000).to_text + "_"
        Spec_Write_Data.Value [table, clothes, sub_clothes] counter suffix prefix

    teardown self =
        enso_project.data/"transient" . list (self.prefix+"*") . each f->
            f.delete . catch Any error-> IO.println "[CLEANUP] Failed to delete "+f.to_text+": "+error.to_display_text

    create_out self suffix=self.suffix =
        i = self.counter.get + 1
        self.counter.put i
        f = enso_project.data / "transient" / (self.prefix + i.to_text + "." + suffix)
        Panic.rethrow f.delete_if_exists
        f

type Complex
    Value re:Float im:Float

type Complex_With_To_String
    Value re:Float im:Float
    to_text self = self.re.to_text + " + " + self.im.to_text + "i"

spec_write suite_builder suffix test_sheet_name =
    suite_builder.group ("Write " + suffix + " Files") group_builder->
        data = Spec_Write_Data.setup suffix

        group_builder.teardown <|
            data.teardown

        group_builder.specify 'should write a table to non-existent file as a new sheet with headers; and return the file object on success' <|
            out = data.create_out
            data.table.write out on_problems=..Report_Error . should_succeed . should_equal out
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal data.table
            written.close

        group_builder.specify 'should be able to round trip all the data types' <|
            alltypes = enso_project.data / "transient" / ("alltypes."+suffix)
            alltypes.delete_if_exists . should_succeed
            t1 = enso_project.data/'all_data_types.csv' . read
            t1.write alltypes (..Sheet "AllTypes") . should_succeed
            t2 = alltypes.read (..Sheet "AllTypes")
            t2.should_equal t1


        group_builder.specify 'should write a table to non-existent file in append mode as a new sheet with headers' <|
            out = data.create_out
            data.table.write out on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal data.table
            written.close

        group_builder.specify 'should write a table to existing file overriding EnsoSheet' <|
            out = data.create_out
            data.table.write out on_problems=..Report_Error . should_succeed
            data.table.write out on_problems=..Report_Error . should_succeed
            written_workbook = out.read
            written_workbook.sheet_count . should_equal 1
            written_workbook.sheet_names . should_equal ['EnsoSheet']
            written_workbook.read 'EnsoSheet' . should_equal data.table
            written_workbook.close

        group_builder.specify 'should write a table to existing file in overwrite mode as a new sheet with headers' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            data.table.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Overwrite on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another")
            written.should_equal data.table

        group_builder.specify 'should write a table to existing file in overwrite mode as a new sheet without headers' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            data.table.write out (..Sheet "NoHeaders") on_existing_file=Existing_File_Behavior.Overwrite on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "NoHeaders")
            written.should_equal (data.table.rename_columns ['A', 'B', 'C', 'D', 'E', 'F'])

        group_builder.specify 'should create new sheets at the start if index is 0' <|
            out = data.create_out
            data.table.write out (..Sheet 0) on_problems=..Report_Error . should_succeed
            data.clothes.write out (..Sheet 0) on_problems=..Report_Error . should_succeed
            read_1 = out.read (..Sheet "Sheet1")
            read_1 . should_equal data.table
            read_2 = out.read (..Sheet "Sheet2")
            read_2 . should_equal data.clothes
            written = out.read
            read_3 = written.sheet_names
            read_3 . should_equal ["Sheet2", "Sheet1"]
            written.close

        group_builder.specify 'should write a table to specific single cell location of an existing sheet' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            data.table.write out (..Range "Another!G1") on_problems=..Report_Error . should_succeed
            written = out.read (..Range "Another!G1")
            written.should_equal data.table

        group_builder.specify 'should clear out an existing fixed range and replace' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            data.sub_clothes.write out (..Range "Another!A1:D20") on_problems=..Report_Error . should_succeed
            written = out.read (..Range "Another!A1")
            written.should_equal data.sub_clothes

        group_builder.specify 'should clear out an existing range and replace' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            data.sub_clothes.write out (..Range "Another!A1") on_problems=..Report_Error . should_succeed
            written = out.read (..Range "Another!A1")
            written.should_equal data.sub_clothes

        group_builder.specify 'should result in Invalid_Location error if trying to write in a bad location' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            data.sub_clothes.write out (..Range "DoesNotExist!A1") . should_fail_with Invalid_Location
            data.sub_clothes.write out (..Range "DoesNotExist!A1:B2") . should_fail_with Invalid_Location
            data.sub_clothes.write out (..Range "SillyRangeName") . should_fail_with Invalid_Location

        group_builder.specify 'should result in Range_Exceeded error if trying to write in too small a range' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            data.sub_clothes.write out (..Range "Another!A1:B2") . should_fail_with Range_Exceeded

        group_builder.specify 'should result in Existing_Data error if in Error mode and trying to replace' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            r1 = data.sub_clothes.write out (..Sheet 1) on_existing_file=Existing_File_Behavior.Error
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Already_Exists

            data.sub_clothes.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Error . should_fail_with File_Error
            data.sub_clothes.write out (..Range "Another!A1") on_existing_file=Existing_File_Behavior.Error . should_fail_with File_Error
            data.sub_clothes.write out (..Range "Sheet1!A9") on_existing_file=Existing_File_Behavior.Error . should_fail_with File_Error

            Test.with_clue "the original file should remain unmodified: " <|
                out.last_modified_time.should_equal lmd

        group_builder.specify 'should not allow adding a new sheet if in Error mode, even if sheet is not clashing' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            result = data.sub_clothes.write out (..Sheet "Testing") on_existing_file=Existing_File_Behavior.Error
            result.should_fail_with File_Error
            result.catch.should_be_a File_Error.Already_Exists
            Test.with_clue "the original file should remain unmodified: " <|
                out.last_modified_time.should_equal lmd

        group_builder.specify 'should write a table to non-existent file as a new sheet without headers' <|
            out = data.create_out
            data.table.write out (..Sheet "Sheet1" headers=False) on_problems=..Report_Error . should_succeed
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['Sheet1']
            written.read 'Sheet1' . should_equal (data.table.rename_columns ['A', 'B', 'C', 'D', 'E', 'F'])

            # We need to close the workbook to be able to delete it.
            written.close

        group_builder.specify 'should be able to append to a sheet by name' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a sheet by position' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a sheet by name out of order' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a single cell by name' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Range "Another!A1") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a single cell by position' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Range "Another!A1") on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a single cell by name out of order' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Range "Another!A1") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a range by name' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB', [4, 5]], ['CC', [True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a', 'b', 'c', 'd', 'e']], ['BB', [1, 2, 3, 4, 5]], ['CC', [True, False, False, True, False]]]
            extra_another.write out (..Range "Another!A1:D6") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a range by position' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Range "Another!A1:D6") on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a range by name not in top left' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Range "Random!K9") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Range "Random!K9") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a range by name after deduplication of names' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['AA 1',[True, False]], ['BB 1', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['AA 1',[True, False, False, True, False]]]
            extra_another.write out (..Range "Random!S3") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Range "Random!S3") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a range by position not in top left' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Range "Random!K9") on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=..Report_Error . should_succeed
            written = out.read (..Range "Random!K9") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should be able to append to a range by name out of order' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (..Range "Another!A1:D6") on_existing_file=Existing_File_Behavior.Append on_problems=..Report_Error . should_succeed
            written = out.read (..Sheet "Another") . select_columns [0, 1, 2]
            written.should_equal expected

        group_builder.specify 'should error gracefully if an unknown extension' <|
            out = data.create_out suffix="notxls"
            data.table.write out format=..Workbook on_problems=..Report_Error . should_fail_with Illegal_Argument
            data.table.write out format=..Sheet on_problems=..Report_Error . should_fail_with Illegal_Argument

        group_builder.specify 'should be able to write to a new dry run file' <|
            out = data.create_out
            temp = Context.Output.with_disabled <|
                result = data.table.write out on_problems=..Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true

                result.absolute.normalize.path . should_not_equal out.absolute.normalize.path

                written = result.read
                written.sheet_count . should_equal 1
                written.sheet_names . should_equal ['EnsoSheet']
                written.read 'EnsoSheet' . should_equal data.table
                written.close
                result
            temp.delete_if_exists

        group_builder.specify "should be able to write to a dry-run file, even if the dry-run workbook is open" <|
            out = data.create_out
            out.exists.should_be_false
            temp = Context.Output.with_disabled <|
                result = data.table.write out on_problems=..Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result
            temp.absolute.normalize.path . should_not_equal out.absolute.normalize.path
            out.exists.should_be_false

            opened_temp = temp.read
            opened_temp.sheet_names . should_equal ['EnsoSheet']

            temp2 = Context.Output.with_disabled <|
                result = data.table.write out (..Sheet "Another") on_problems=..Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result

            # The result should be written to the same dry-run file on second attempt.
            temp2.absolute.normalize.path . should_equal temp.absolute.normalize.path

            ## The write operation replaces the dry run file, basing off of the _original_ out file
               (which was empty in this example), so we still only get one sheet.
               Different example is tested in the test below, if the subsequent file happens to the returned
               dry-run object - then both updates are visible - see below.
            opened_temp.sheet_names . should_equal ['Another']

            opened_temp.close
            temp.delete_if_exists

        group_builder.specify "should be able to write to a dry-run file multiple times if the dry-run file object is threaded through" <|
            out = data.create_out
            temp1 = Context.Output.with_disabled <|
                result = data.table.write out on_problems=..Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result
            temp1.absolute.normalize.path . should_not_equal out.absolute.normalize.path

            opened_temp = temp1.read
            opened_temp.sheet_names . should_equal ['EnsoSheet']

            temp2 = Context.Output.with_disabled <|
                result = data.table.write temp1 (..Sheet "Another") on_problems=..Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result

            # The result should be written to the same file though.
            temp2.absolute.normalize.path . should_equal temp1.absolute.normalize.path

            # The write operation replaces the dry run file, basing off of the dry-run file itself - so both changes are visible.
            opened_temp.sheet_names . should_equal ['EnsoSheet', 'Another']

            opened_temp.close
            temp1.delete_if_exists

        group_builder.specify "should be able to create a backup, even if it is currently open" <|
            out = data.create_out
            bak = out.parent / (out.name+".bak")

            t1 = Table.new [["X", [1]]]
            t1.write out on_existing_file=Existing_File_Behavior.Backup on_problems=..Report_Error . should_succeed
            bak.exists.should_be_false

            t2 = Table.new [["X", [2]]]
            t2.write out on_existing_file=Existing_File_Behavior.Backup on_problems=..Report_Error . should_succeed
            bak.exists.should_be_true

            opened_out = out.read
            # We need to specify explicit format for the backup, because the extension is changed:
            opened_backup = bak.read (..Workbook xls_format=(suffix=="xls"))

            opened_out.read 'EnsoSheet' . should_equal t2
            opened_backup.read 'EnsoSheet' . should_equal t1

            t3 = Table.new [["X", [3]]]
            t3.write out on_existing_file=Existing_File_Behavior.Backup on_problems=..Report_Error . should_succeed

            opened_out.read 'EnsoSheet' . should_equal t3
            # The backup should actually have been updated
            opened_backup.read 'EnsoSheet' . should_equal t2

            opened_out.close
            opened_backup.close

            bak.delete_if_exists . should_succeed

        group_builder.specify 'should be able to write to an existing empty file' <|
            out = data.create_out
            [].write_bytes out

            out_bak = out.parent / (out.name+".bak")

            data.table.write out on_problems=..Report_Error . should_succeed . should_equal out
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal data.table

            Test.with_clue "should have created a backup file: " <|
                out_bak.exists.should_be_true
                out_bak.size.should_equal 0

            written.close
            out_bak.delete_if_exists . should_succeed

        group_builder.specify 'should fail to append to a sheet by name if missing columns' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']]]
            extra_another.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Append . should_fail_with Column_Name_Mismatch

        group_builder.specify 'should fail to append to a sheet by name if extra columns' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Append . should_fail_with Column_Name_Mismatch
            out.last_modified_time.should_equal lmd

        group_builder.specify 'should fail to append to a sheet by name if no headers' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (..Sheet "NoHeaders") on_existing_file=Existing_File_Behavior.Append . should_fail_with Illegal_Argument
            extra_another.write out (..Sheet "Another" headers=False) on_existing_file=Existing_File_Behavior.Append . should_fail_with Illegal_Argument
            out.last_modified_time.should_equal lmd

        group_builder.specify 'should fail to append to a sheet by position if too few columns' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']]]
            extra_another.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position . should_fail_with Column_Count_Mismatch
            out.last_modified_time.should_equal lmd

        group_builder.specify 'should fail to append to a sheet by position if too many columns' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (..Sheet "Another") on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position . should_fail_with Column_Count_Mismatch
            out.last_modified_time.should_equal lmd

        group_builder.specify 'should fail to append to a range by name if not large enough' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (..Range "Another!A1:D5") on_existing_file=Existing_File_Behavior.Append . should_fail_with Range_Exceeded
            out.last_modified_time.should_equal lmd

        group_builder.specify 'should fail to append to a range by name if it hits another table' <|
            out = data.create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (..Range "Random!B3") on_existing_file=Existing_File_Behavior.Append . should_fail_with Existing_Data
            out.last_modified_time.should_equal lmd

        group_builder.specify "should fail if the target file is read-only" <|
            f = enso_project.data / "transient" / ("permission."+suffix)
            if f.exists then Util.set_writable f True
            f.delete_if_exists

            initial_data = Table.new [["Y", [10, 20, 30]]]
            initial_data.write f . should_succeed
            Util.set_writable f False . should_succeed

            t1 = Table.new [["X", [1, 2, 3]]]
            [Existing_File_Behavior.Backup, Existing_File_Behavior.Overwrite, Existing_File_Behavior.Append].each behavior-> Test.with_clue behavior.to_text+": " <|
                f.exists . should_be_true

                r1 = t1.write f (..Sheet "Another") on_existing_file=behavior
                Test.with_clue "("+r1.catch.to_display_text+") " <|
                    r1.should_fail_with File_Error
                    r1.catch.should_be_a File_Error.Access_Denied

                read_table = Managed_Resource.bracket (f.read) (.close) workbook->
                    workbook.read "EnsoSheet"
                read_table.should_equal initial_data

            Util.set_writable f True
            f.delete

        group_builder.specify "should allow to write to a workbook that is open, and reflect that changes when the sheet is read again" <|
            out = data.create_out
            data.table.write out on_problems=..Report_Error . should_succeed

            workbook = out.read
            workbook.sheet_names.should_equal ["EnsoSheet"]
            workbook.to_text . should_equal "Excel_Workbook ("+out.name+")"

            # We can have the workbook open multiple times in parallel too.
            w2 = out.read

            t1 = workbook.read "EnsoSheet" headers=True
            t1.should_equal data.table

            [Existing_File_Behavior.Backup, Existing_File_Behavior.Overwrite].each behavior-> Test.with_clue behavior.to_text+": " <|
                t2 = Table.new [["X", [behavior.to_text, "B", "C", behavior.to_text+"..."]]]
                t2.write out on_existing_file=behavior . should_succeed

                workbook.sheet_names.should_equal ["EnsoSheet"]

                # If we read the table again, it has the new values in it:
                t3 = workbook.read "EnsoSheet" headers=True
                t3.should_equal t2

                t4 = w2.read "EnsoSheet" headers=True
                t4.should_equal t2

            # And finally test appending:
            (Table.new [["Z", ["a", "b"]]]).write out on_existing_file=Existing_File_Behavior.Overwrite . should_succeed
            (Table.new [["Z", ["c", "d"]]]).write out on_existing_file=Existing_File_Behavior.Append . should_succeed
            w2.read "EnsoSheet" headers=True . should_equal (Table.new [["Z", ["a", "b", "c", "d"]]])

            workbook.close
            w2.close

        group_builder.specify "should fail if the parent directory does not exist" <|
            parent = enso_project.data / "transient" / "nonexistent"
            parent.exists.should_be_false

            f = parent / ("foo."+suffix)
            t1 = Table.new [["X", [1, 2, 3]]]
            r1 = t1.write f (..Sheet "Another")
            Test.with_clue "("+r1.catch.to_display_text+") " <|
                r1.should_fail_with File_Error
                r1.catch.should_be_a File_Error.Not_Found

        group_builder.specify "should allow to write and read-back Unicode characters" <|
            encodings = enso_project.data / "transient" / ("encodings."+suffix)
            encodings.delete_if_exists . should_succeed

            t1 = Table.new [["A", ["A", "B", "😊", "D"]], ["B", [1, 2, 3, 4]]]
            t1.write encodings (..Sheet "Another") . should_succeed
            t2 = encodings.read (..Sheet "Another")
            t2.at "A" . to_vector . should_equal ["A", "B", "😊", "D"]
            encodings.delete

        group_builder.specify "should allow to writing custom types" <|
            custom_types = enso_project.data / "transient" / ("custom_types."+suffix)
            custom_types.delete_if_exists . should_succeed

            t1 = Table.new [["A", [Complex.Value 19 89, Complex.Value -1 -42]], ["B", [1, 2]]]
            t1.write custom_types (..Sheet "Another") . should_succeed
            t2 = custom_types.read (..Sheet "Another")
            t2.at "A" . to_vector . should_equal ["(Complex.Value 19.0 89.0)", "(Complex.Value -1.0 -42.0)"]
            custom_types.delete

        group_builder.specify "should allow to writing custom types that have defined to_string" <|
            custom_types2 = enso_project.data / "transient" / ("custom_types2."+suffix)
            custom_types2.delete_if_exists . should_succeed

            t1 = Table.new [["A", [Complex_With_To_String.Value 19 89, Complex_With_To_String.Value -1 -42]], ["B", [1, 2]]]
            t1.write custom_types2 (..Sheet "Another") . should_succeed
            t2 = custom_types2.read (..Sheet "Another")
            t2.at "A" . to_vector . should_equal ["19.0 + 89.0i", "-1.0 + -42.0i"]
            custom_types2.delete

        group_builder.specify "should be able to overwrite a pre-existing empty file" <|
            empty = enso_project.data / "transient" / ("empty."+suffix)
            [Existing_File_Behavior.Backup, Existing_File_Behavior.Overwrite, Existing_File_Behavior.Append].each behavior-> Test.with_clue behavior.to_text+": " <|
                empty.delete_if_exists . should_succeed
                "".write empty
                empty.exists.should_be_true
                empty.size.should_equal 0

                t1 = Table.new [["A", [behavior.to_text, "B", "C", "D"]], ["B", [1, 2, 3, 4]]]
                t1.write empty on_existing_file=behavior . should_succeed
                empty.exists.should_be_true

                t2 = empty.read (..Sheet "EnsoSheet")
                t2.should_equal t1
                empty.delete


check_range excel_range sheet_name tlbr_vector single_cell=False =
    excel_range.sheet_name . should_equal sheet_name
    excel_range.top_row . should_equal (tlbr_vector.at 0)
    excel_range.left_column . should_equal (tlbr_vector.at 1)
    excel_range.bottom_row . should_equal (tlbr_vector.at 2)
    excel_range.right_column . should_equal (tlbr_vector.at 3)
    excel_range.is_single_cell . should_equal single_cell


add_specs suite_builder =
    suite_builder.group 'Excel Range' group_builder->
        group_builder.specify 'should be able to parse A1 format' <|
            check_range (Excel_Range.from_address "Test!EE4") 'Test' [4, 135, 4, 135] True
            check_range (Excel_Range.from_address "Test!EE4:EE4") 'Test' [4, 135, 4, 135]
            check_range (Excel_Range.from_address "Test!A1:D5") 'Test' [1, 1, 5, 4]
            check_range (Excel_Range.from_address "Test!1234") 'Test' [1234, Nothing, 1234, Nothing]
            check_range (Excel_Range.from_address "Test!1:4") 'Test' [1, Nothing, 4, Nothing]
            check_range (Excel_Range.from_address "Test!CB") 'Test' [Nothing, 80, Nothing, 80]
            check_range (Excel_Range.from_address "Test!DD:XAZ") 'Test' [Nothing, 108, Nothing, 16276]
            check_range (Excel_Range.from_address "'Hello World'!$EE4") 'Hello World' [4, 135, 4, 135] single_cell=True
            check_range (Excel_Range.from_address "Test!A1:$D$5") 'Test' [1, 1, 5, 4]
            check_range (Excel_Range.from_address "Test!1234") 'Test' [1234, Nothing, 1234, Nothing]
            check_range (Excel_Range.from_address "Test!$1:$4") 'Test' [1, Nothing, 4, Nothing]
            check_range (Excel_Range.from_address "Test!$CB") 'Test' [Nothing, 80, Nothing, 80]
            check_range (Excel_Range.from_address "Test!$DD:$XAZ") 'Test' [Nothing, 108, Nothing, 16276]

        group_builder.specify 'should be able to parse RC format' <|
            check_range (Excel_Range.from_address "Test!R1C1") 'Test' [1, 1, 1, 1] True
            check_range (Excel_Range.from_address "Test!R1C1:R5C3") 'Test' [1, 1, 5, 3]

        group_builder.specify 'should fail gracefully for invalid patterns' <|
            Excel_Range.from_address "Test!$$QA1" . should_fail_with Illegal_Argument
            Excel_Range.from_address "Test!BADADDRESS" . should_fail_with Illegal_Argument

        group_builder.specify 'should allow Range creation for a cell' <|
            check_range (Excel_Range.for_cell "Hello World" 123 14) 'Hello World' [14, 123, 14, 123] True
            check_range (Excel_Range.for_cell "Hello World" "DS" 14) 'Hello World' [14, 123, 14, 123] True
            Excel_Range.for_cell "Test" 123 14 . address . should_equal "Test!DS14"
            Excel_Range.for_cell "Hello World" 123 14 . address . should_equal "'Hello World'!DS14"
            Excel_Range.for_cell "Test" 20000 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" "ZZZ" 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 0 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 1 10000000 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 1 0 . should_fail_with Illegal_Argument

        group_builder.specify 'should allow Range creation for a range' <|
            check_range (Excel_Range.for_range "Hello World" 55 120 123 14) 'Hello World' [14, 55, 120, 123]
            check_range (Excel_Range.for_range "Hello World" "BC" 120 "DS" 14) 'Hello World' [14, 55, 120, 123]
            Excel_Range.for_range "Test" 55 120 123 14 . address . should_equal "Test!BC14:DS120"
            Excel_Range.for_range "Hello World" 55 120 123 14 . address . should_equal "'Hello World'!BC14:DS120"
            Excel_Range.for_range "Test" 20000 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" "ZZZ" 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 0 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 20000 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 0 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 0 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 10000000 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 123 0 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 123 10000000 . should_fail_with Illegal_Argument

        group_builder.specify 'should allow Range creation for a column' <|
            check_range (Excel_Range.for_columns "Hello World" 123) 'Hello World' [Nothing, 123, Nothing, 123]
            check_range (Excel_Range.for_columns "Hello World" "DS") 'Hello World' [Nothing, 123, Nothing, 123]
            Excel_Range.for_columns "Test" 123 . address . should_equal "Test!DS"
            Excel_Range.for_columns "Hello World" 123 . address . should_equal "'Hello World'!DS"
            Excel_Range.for_columns "Test" 20000 . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" "ZZZ" . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 0 . should_fail_with Illegal_Argument

        group_builder.specify 'should allow Range creation for columns' <|
            check_range (Excel_Range.for_columns "Hello World" "BC" 123) 'Hello World' [Nothing, 55, Nothing, 123]
            check_range (Excel_Range.for_columns "Hello World" 55 "DS") 'Hello World' [Nothing, 55, Nothing, 123]
            Excel_Range.for_columns "Test" 55 123 . address . should_equal "Test!BC:DS"
            Excel_Range.for_columns "Hello World" "BC" "DS" . address . should_equal "'Hello World'!BC:DS"
            Excel_Range.for_columns "Test" 55 20000 . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 55 "ZZZ" . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 55 0 . should_fail_with Illegal_Argument

        group_builder.specify 'should allow Range creation for a row' <|
            check_range (Excel_Range.for_rows "Hello World" 123) 'Hello World' [123, Nothing, 123, Nothing]
            Excel_Range.for_rows "Test" 123 . address . should_equal "Test!123"
            Excel_Range.for_rows "Hello World" 123 . address . should_equal "'Hello World'!123"
            Excel_Range.for_rows "Test" 20000000 . should_fail_with Illegal_Argument
            Excel_Range.for_rows "Test" 0 . should_fail_with Illegal_Argument

        group_builder.specify 'should allow Range creation for rows' <|
            check_range (Excel_Range.for_rows "Hello World" 55 123) 'Hello World' [55, Nothing, 123, Nothing]
            Excel_Range.for_rows "Test" 55 123 . address . should_equal "Test!55:123"
            Excel_Range.for_rows "Hello World" 55 123 . address . should_equal "'Hello World'!55:123"
            Excel_Range.for_rows "Test" 55 20000000 . should_fail_with Illegal_Argument
            Excel_Range.for_rows "Test" 55 0 . should_fail_with Illegal_Argument

    xlsx_sheet = enso_project.data / "TestSheet.xlsx"
    xlsx_path = xlsx_sheet.path

    xls_sheet = enso_project.data / "TestSheetOld.xls"
    xls_path = xls_sheet.path

    sheet_names = ["Sheet1", "Another", "NoHeaders", "Random"]
    range_names = ["myData"]

    col_a = ["Test", "Here", "Is", "Data"]
    col_b = [1, 2, 3, 4]
    col_c = [Date.new 2022 06 12, Date.new 2022 10 20, Date.new 2022 07 30, Date.new 2022 10 15]
    col_d = [Time_Of_Day.new 12 34 56, Time_Of_Day.new 1 23 45, Time_Of_Day.new 2 46, Time_Of_Day.new 9]
    col_e = [Date_Time.new 2022 06 12 12 34 56, Date_Time.new 2022 10 20 1 23 45, Date_Time.new 2022 07 30 2 46, Date_Time.new 2022 10 15 9]

    check_column col expected =
        start = col.length - expected.length
        0.up_to start . map i->(col.at i . should_equal Nothing)
        start.up_to col.length . map i->(col.at i . should_equal (expected.at (i - start)))

    check_table table count=5 =
        table.column_count . should_equal count
        if count > 0 then check_column (table.at "A") col_a
        if count > 1 then check_column (table.at "B") col_b
        if count > 2 then check_column (table.at "C") col_c
        if count > 3 then check_column (table.at "D") col_d
        if count > 4 then check_column (table.at "E") col_e

    check_workbook workbook sheets=sheet_names.length ranges=range_names.length =
        workbook.is_a Excel_Workbook . should_be_true
        workbook.sheet_count . should_equal sheets
        workbook.named_ranges_count . should_equal ranges

    suite_builder.group "Read XLSX / XLS Files" group_builder->
        group_builder.specify "should let you read the workbook with Auto_Detect" <|
            check_workbook <| xlsx_sheet.read
            check_workbook <| Data.read xlsx_sheet
            check_workbook <| Data.read xlsx_path

            check_workbook <| xls_sheet.read
            check_workbook <| Data.read xls_sheet
            check_workbook <| Data.read xls_path

        group_builder.specify "should let you read the workbook with Excel" <|
            check_workbook <| xlsx_sheet.read ..Workbook
            check_workbook <| Data.read xlsx_sheet ..Workbook
            check_workbook <| Data.read xlsx_path ..Workbook

            check_workbook <| xls_sheet.read ..Workbook
            check_workbook <| Data.read xls_sheet ..Workbook
            check_workbook <| Data.read xls_path ..Workbook

        group_builder.specify "workbook should look like a database connection" <|
            workbook = xlsx_sheet.read

            workbook.database . should_equal xlsx_sheet.normalize.path
            workbook.schema . should_equal Nothing

            workbook.table_types . should_equal ['Worksheet', 'Named Range']

            workbook.tables.row_count . should_equal (sheet_names.length + range_names.length)
            workbook.tables.at "Name" . to_vector . should_equal_ignoring_order (sheet_names + range_names)

            workbook.tables types=["Worksheet"] . row_count . should_equal sheet_names.length
            workbook.tables types=["Named Range"] . row_count . should_equal range_names.length
            workbook.tables types=["XXX"] . row_count . should_equal 0

            workbook.tables "%not%" . row_count . should_equal 1
            workbook.tables "%not%" . at 'Name' . to_vector . should_equal ["Another"]

        group_builder.specify "should let you read the sheet names" <|
            xlsx_sheet.read . sheet_names . should_equal sheet_names
            xls_sheet.read . sheet_names . should_equal sheet_names

        group_builder.specify "should let you read the range names" <|
            xlsx_sheet.read . named_ranges . should_equal range_names
            xls_sheet.read . named_ranges . should_equal range_names

        group_builder.specify "should let you read by sheet index" <|
            table = xlsx_sheet.read (..Sheet 1)
            check_table table

            table_2 = xlsx_sheet.read (..Sheet 1 skip_rows=(table.row_count - col_a.length))
            table_2.row_count . should_equal col_a.length
            check_table table_2

        group_builder.specify "should let you read by sheet name" <|
            table = xlsx_sheet.read (..Sheet "Sheet1")
            check_table table

            table_2 = xlsx_sheet.read (..Sheet "Sheet1" skip_rows=(table.row_count - col_a.length))
            table_2.row_count . should_equal col_a.length
            check_table table_2

            table_3 = xlsx_sheet.read . read "Sheet1"
            check_table table_3

            table_4 = xlsx_sheet.read . sheet "Sheet1"
            check_table table_4

        group_builder.specify "should error if you read by an invalid sheet name" <|
            xlsx_sheet.read (..Sheet "NoSuchSheet") . should_fail_with Invalid_Location
            xlsx_sheet.read . read "NoSuchSheet" . should_fail_with Invalid_Location

        group_builder.specify "should let you read XLS by sheet index" <|
            table = xls_sheet.read (..Sheet 1)
            check_table table

            table_2 = xls_sheet.read (..Sheet 1 skip_rows=(table.row_count - col_a.length))
            table_2.row_count . should_equal col_a.length
            check_table table_2

            table_4 = xlsx_sheet.read . sheet 1
            check_table table_4

        group_builder.specify "should let you read XLS by sheet name" <|
            table = xls_sheet.read (..Sheet "Sheet1")
            check_table table

            table_2 = xls_sheet.read . read "Sheet1"
            check_table table_2

        group_builder.specify "should let you read by range" <|
            table = xlsx_sheet.read (..Range "Sheet1!A:C")
            check_table table 3

            table_2 = xlsx_sheet.read (..Range "Sheet1!A:C" skip_rows=(table.row_count - col_a.length))
            table_2.row_count . should_equal col_a.length
            check_table table_2 3

            check_table <| xlsx_sheet.read (..Range "Sheet1!10:13")
            check_table count=3 <| xlsx_sheet.read (..Range "Sheet1!A10:C13")

            check_table <| xlsx_sheet.read . read "Sheet1!10:13"
            check_table count=3 <| xlsx_sheet.read . read "Sheet1!A10:C13"

        group_builder.specify "should let you read by range name" <|
            table = xlsx_sheet.read (..Range "myData")
            table.row_count . should_equal col_a.length
            check_table table 3

            table_2 = xlsx_sheet.read . read "myData"
            table_2.row_count . should_equal col_a.length
            check_table table_2 3

        group_builder.specify "should let you restrict number of rows read and skip rows" <|
            table = xlsx_sheet.read (..Sheet "Sheet1")
            check_table table

            table_2 = xlsx_sheet.read (..Sheet "Sheet1" skip_rows=(table.row_count - col_a.length))
            table_2.row_count . should_equal col_a.length
            check_table table_2

            table_3 = xlsx_sheet.read (..Sheet "Sheet1" skip_rows=(table.row_count - col_a.length) row_limit=2)
            table_3.row_count . should_equal 2

            table_4 = xlsx_sheet.read (..Sheet "Sheet1" row_limit=6)
            table_4.row_count . should_equal 6

    suite_builder.group "Problems" group_builder->
        group_builder.specify "should report a user-friendly error message when format is missing a required argument" <|
            r = xlsx_sheet.read (..Range)
            r.should_fail_with Missing_Argument
            r.catch.to_display_text . should_contain "Provide a value for the argument `address`."

        group_builder.specify "should handle non-existing file gracefully" <|
            bad_file = enso_project.data / "DoesNotExists.xlsx"
            result = bad_file.read (..Range "Sheet1!A:C")
            result.should_fail_with File_Error
            result.catch.should_be_a File_Error.Not_Found

        group_builder.specify "should handle wrong xls_format gracefully" <|
            xlsx_sheet_copy = enso_project.data / "transient" / "TestSheetCopy.xlsx"
            xlsx_sheet_copy.delete_if_exists . should_succeed
            xlsx_sheet.copy_to xlsx_sheet_copy

            # At first, it fails with File_Error
            r1 = xlsx_sheet.read (..Range "Sheet1!A:C" xls_format=True)
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Corrupted_Format

            # If we now open it correctly
            r1_2 = xlsx_sheet.read
            r1_2.should_succeed

            # And then wrong again
            r1_3 = xlsx_sheet.read (..Range "Sheet1!A:C" xls_format=True)
            # It should still fail the same:
            r1_3.should_fail_with File_Error
            r1_3.catch.should_be_a File_Error.Corrupted_Format

            r2 = xls_sheet.read (..Range "Sheet1!A:C" xls_format=False)
            r2.should_fail_with File_Error
            r2.catch.should_be_a File_Error.Corrupted_Format
            xlsx_sheet_copy.delete

        group_builder.specify "should handle malformed XLS files gracefully" <|
            bad_file = enso_project.data / "transient" / "malformed.xls"
            "not really an XLS file contents...".write bad_file on_existing_file=Existing_File_Behavior.Overwrite

            r1 = bad_file.read
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Corrupted_Format
            r1.catch.to_display_text.should_contain "is corrupted"

            r1a = bad_file.read ..Workbook
            r1a.should_fail_with File_Error
            r1a.catch.should_be_a File_Error.Corrupted_Format

            r2 = bad_file.read (..Range "Sheet1!A:C")
            r2.should_fail_with File_Error
            r2.catch.should_be_a File_Error.Corrupted_Format
            r2.catch.to_display_text.should_contain "is corrupted"

            bad_file.delete

        group_builder.specify "will fail if an operation is performed on a closed workbook" <|
            workbook = xlsx_sheet.read
            workbook.sheet_count . should_equal 4

            workbook.close . should_equal Nothing

            workbook.sheet_count . should_fail_with Illegal_State
            workbook.close . should_equal Nothing
            workbook.read "Sheet1" . should_fail_with Illegal_State

        ci_pending = "This test takes a lot of time so it is disabled on CI."
        group_builder.specify "should be able to write and read a big XLSX file (>110MB)" pending=ci_pending <|
            n = 10^6
            IO.println "Generating big XLSX file "+Time_Of_Day.now.to_text
            rng = RandomHelpers.new 123
            v = Vector.new n _->
                rng.makeRandomString 190
            table = Table.new [["X", v]]
            big_file = enso_project.data / "transient" / "big.xlsx"
            big_file.delete_if_exists

            table.write big_file on_existing_file=Existing_File_Behavior.Overwrite on_problems=..Report_Error . should_succeed
            IO.println "Done                     "+Time_Of_Day.now.to_text

            # Verify that the file is as big as we expected.
            size = big_file.size / (1024*1024)
            Test.with_clue "size="+size.to_text+"MB " <|
                (size > 110).should_be_true

            workbook = big_file.read
            sheets = workbook.sheet_names
            sheets.length . should_equal 1
            read_table = workbook.read (sheets.at 0)
            read_table.row_count . should_equal n+1
            read_table.column_names.length . should_equal 1
            read_table.at 0 . at 0 . should_equal "X"
            read_table.at 0 . at 1 . should_equal (v.at 0)

            workbook.close
            big_file.delete_if_exists . should_succeed

        group_builder.specify "should be able to write and read a big XLS file (>110MB)" pending=ci_pending <|
            IO.println "Generating big XLS file "+Time_Of_Day.now.to_text
            rng = RandomHelpers.new 123
            # Here we instead create a 2D table, because XLS has a limit of 65536 rows and 16k columns.
            rows = 65000
            cols = 20
            table = Table.new <| Vector.new cols i->
                v = Vector.new rows _-> rng.makeRandomString 100
                ["col" + i.to_text, v]
            big_file = enso_project.data / "transient" / "big.xls"
            big_file.delete_if_exists

            table.write big_file on_existing_file=Existing_File_Behavior.Overwrite on_problems=..Report_Error . should_succeed
            IO.println "Done                    "+Time_Of_Day.now.to_text

            # Verify that the file is as big as we expected.
            size = big_file.size / (1024*1024)
            Test.with_clue "size="+size.to_text+"MB " <|
                (size > 110).should_be_true

            workbook = big_file.read
            sheets = workbook.sheet_names
            sheets.length . should_equal 1
            read_table = workbook.read (sheets.at 0)
            read_table.row_count . should_equal rows+1
            read_table.column_names.length . should_equal cols

            workbook.close
            big_file.delete_if_exists . should_succeed

    spec_fmt suite_builder 'XLSX reading' Examples.xlsx .read

    spec_fmt suite_builder 'XLS reading' Examples.xls .read

    suite_builder.group "Reading single cells correctly" group_builder->
        file = enso_project.data / "RangeTests.xlsx"

        check_table table col_names data =
            table.column_count . should_equal col_names.length
            table.columns.map .name . should_equal col_names
            data.each_with_index idx->values->
                table.at (col_names.at idx) . to_vector . should_equal values

        group_builder.specify "Simple table" <|
            check_table (file.read (..Range "Sheet1!A1")) ["AA", "BB"] [[1,2,3,4,5,6], ["A","B","C","D","E","F"]]
            check_table (file.read (..Range "Sheet1!A2")) ["A", "B"] [[1,2,3,4,5,6], ["A","B","C","D","E","F"]]
            check_table (file.read (..Range "Sheet1!A1:A1")) ["A"] [["AA"]]
            check_table (file.read (..Range "Sheet1!B1")) ["B"] [["BB", "A","B","C","D","E","F"]]
            check_table (file.read (..Range "Sheet1!B1" headers=True)) ["BB"] [["A","B","C","D","E","F"]]
            check_table (file.read (..Range "Sheet1!B2")) ["B"] [["A","B","C","D","E","F"]]

        group_builder.specify "Patchy table" <|
            check_table (file.read (..Range "Sheet1!D1")) ["A", "B", "F"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (..Range "Sheet1!D2")) ["D", "E", "F"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (..Range "Sheet1!E")) ["B"] [[4,4,Nothing,Nothing,Nothing,Nothing]]
            check_table (file.read (..Range "Sheet1!E1")) ["B", "F"] [[4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (..Range "Sheet1!E2")) ["E", "F"] [[4,4,Nothing], [6,Nothing,6]]

        group_builder.specify "Single cell" <|
            check_table (file.read (..Range "Sheet1!H1")) ["H"] [["Single Cell"]]
            check_table (file.read (..Range "Sheet1!H2")) ["H"] [[]]

        group_builder.specify "Single line" <|
            check_table (file.read (..Range "Sheet1!J1")) ["J", "K", "L"] [["Just"],["Some"],["Headers"]]

        group_builder.specify "Growing table" <|
            check_table (file.read (..Range "Sheet1!N1")) ["A", "Full", "Table", "Q"] [["Hello","World",Nothing,"Extend"],[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]
            check_table (file.read (..Range "Sheet1!O1")) ["Full", "Table", "Q"] [[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]
            check_table (file.read (..Range "Sheet1!O2")) ["O", "P", "Q"] [[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]

        group_builder.specify "Should handle blank headers without warnings" <|
            check_table (file.read (..Range "Sheet1!D1")) ["A", "B", "F"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]

        group_builder.specify "Should handle duplicate headers with warnings" <|
            action = file.read (..Range "Sheet1!S1") on_problems=_
            tester = check_table _ ["DD", "DD 1"] [[1,3], [2,4]]
            problems = [Duplicate_Output_Column_Names.Error ["DD"]]
            Problems.test_problem_handling action problems tester

    spec_write suite_builder "xlsx" 'TestSheet.xlsx'
    spec_write suite_builder "xls" 'TestSheetOld.xls'

main filter=Nothing =
    suite = Test.build suite_builder->
        add_specs suite_builder
    suite.run_with_filter filter
