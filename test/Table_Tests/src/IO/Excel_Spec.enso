from Standard.Base import all
import Standard.Base.Errors.File_Error.File_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

from Standard.Table import Table, Match_Columns, Excel, Excel_Range, Data_Formatter, Sheet_Names, Range_Names, Worksheet, Cell_Range, Delimited, Excel_Workbook

from Standard.Table.Errors import Invalid_Output_Column_Names, Duplicate_Output_Column_Names, Invalid_Location, Range_Exceeded, Existing_Data, Column_Count_Mismatch, Column_Name_Mismatch, Empty_Sheet_Error

from Standard.Test import Test, Test_Suite, Problems
import Standard.Test.Extensions

import Standard.Examples

import project.Util

spec_fmt header file read_method sheet_count=5 =
    Test.group header <|
        Test.specify "should read a workbook in" <|
            wb = read_method file
            wb.sheet_count . should_equal sheet_count

        Test.specify "should read the specified sheet by index and use correct headers" <|
            t = read_method file (Excel (Worksheet 1))
            t.columns.map .name . should_equal ['Name', 'Quantity', 'Price']
            t.at 'Name' . to_vector . should_equal ['blouse', 't-shirt', 'trousers', 'shoes', 'skirt', 'dress']
            t.at 'Quantity' . to_vector . should_equal [10, 20, Nothing, 30, Nothing, 5]
            t.at 'Price' . to_vector . should_equal [22.3, 32, 43.2, 54, 31, Nothing]

        Test.specify "should read the specified sheet by index and properly format a table" <|
            t = read_method file (Excel (Worksheet 2) headers=False)
            t.columns.map .name . should_equal ['A', 'B', 'C', 'D', 'E']
            t.at 'A' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            t.at 'B' . to_vector . should_equal [Nothing, Nothing, 10, Nothing, Nothing, Nothing, Nothing]
            t.at 'C' . to_vector . should_equal [Nothing, 'baz', 20, Nothing, 'bar', Nothing, 30]
            t.at 'D' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            t.at 'E' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, 'foo', Nothing]

        Test.specify "should read the specified sheet by name and properly handle dates" <|
            t = read_method file (Excel (Worksheet 'Dates'))
            t.columns.map .name . should_equal ['Student Name', 'Enrolment Date']
            t.at 'Enrolment Date' . map .day . to_vector . should_equal [2, 26, 4, 24, 31, 7]

        Test.specify "should give an informative error when reading an empty table" <|
            t = read_method file (Excel (Worksheet "Empty"))
            t.should_fail_with Empty_Sheet_Error

        Test.specify "should gracefully handle duplicate column names and formulas" <|
            t = read_method file (Excel (Worksheet "Duplicate Columns"))
            t.columns.map .name . should_equal ['Item', 'Price', 'Quantity', 'Price_1']
            t.at 'Price_1' . to_vector . should_equal [20, 40, 0, 60, 0, 10]

        Test.specify "should allow reading with cell range specified" <|
            t_1 = read_method file (Excel (Cell_Range "Simple!B:C"))
            t_1.columns.map .name . should_equal ['Quantity', 'Price']
            t_1.at 'Quantity' . to_vector . should_equal [10, 20, Nothing, 30, Nothing, 5]
            t_1.at 'Price' . to_vector . should_equal [22.3, 32, 43.2, 54, 31, Nothing]

            t_2 = read_method file (Excel (Cell_Range "Simple!3:5") headers=False)
            t_2.column_count.should_equal 3
            t_2.at 'A' . to_vector . should_equal ['t-shirt', 'trousers', 'shoes']
            t_2.at 'B' . to_vector . should_equal [20, Nothing, 30]
            t_2.at 'C' . to_vector . should_equal [32, 43.2, 54]

            t_3 = read_method file (Excel (Cell_Range "Simple!B4:C5") headers=False)
            t_3.column_count.should_equal 2
            t_3.at 'B' . to_vector . should_equal [Nothing, 30]
            t_3.at 'C' . to_vector . should_equal [43.2, 54]

spec_write suffix test_sheet_name =
    Test.group ("Write " + suffix + " Files") <|
        out = enso_project.data / ('out.' + suffix)
        out_bak = enso_project.data / ('out.' + suffix + '.bak')
        table = enso_project.data/'varied_column.csv' . read
        clothes = enso_project.data/'clothes.csv' . read
        sub_clothes = clothes.select_columns [0, 1]

        Test.specify 'should write a table to non-existent file as a new sheet with headers; and return the file object on success' <|
            out.delete_if_exists
            table.write out on_problems=Report_Error . should_succeed . should_equal out
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal table
            out.delete_if_exists

        Test.specify 'should write a table to non-existent file in append mode as a new sheet with headers' <|
            out.delete_if_exists
            table.write out on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal table
            out.delete_if_exists

        Test.specify 'should write a table to existing file overriding EnsoSheet' <|
            out.delete_if_exists
            table.write out on_problems=Report_Error . should_succeed
            table.write out on_problems=Report_Error . should_succeed
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal table
            out.delete_if_exists

        Test.specify 'should write a table to existing file in overwrite mode as a new sheet with headers' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            table.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Overwrite on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another"))
            written.should_equal table
            out.delete_if_exists

        Test.specify 'should write a table to existing file in overwrite mode as a new sheet without headers' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            table.write out (Excel (Worksheet "NoHeaders")) on_existing_file=Existing_File_Behavior.Overwrite on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "NoHeaders"))
            written.should_equal (table.rename_columns ['A', 'B', 'C', 'D', 'E', 'F'])
            out.delete_if_exists

        Test.specify 'should create new sheets at the start if index is 0' <|
            out.delete_if_exists
            table.write out (Excel (Worksheet 0)) on_problems=Report_Error . should_succeed
            clothes.write out (Excel (Worksheet 0)) on_problems=Report_Error . should_succeed
            read_1 = out.read (Excel (Worksheet "Sheet1"))
            read_1 . should_equal table
            read_2 = out.read (Excel (Worksheet "Sheet2"))
            read_2 . should_equal clothes
            read_3 = out.read (Excel (Sheet_Names))
            read_3 . should_equal ["Sheet2", "Sheet1"]
            out.delete_if_exists

        Test.specify 'should write a table to specific single cell location of an existing sheet' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            table.write out (Excel (Cell_Range "Another!G1")) on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Another!G1"))
            written.should_equal table
            out.delete_if_exists

        Test.specify 'should clear out an existing fixed range and replace' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "Another!A1:D20")) on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Another!A1"))
            written.should_equal sub_clothes
            out.delete_if_exists

        Test.specify 'should clear out an existing range and replace' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "Another!A1")) on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Another!A1"))
            written.should_equal sub_clothes
            out.delete_if_exists

        Test.specify 'should result in Invalid_Location error if trying to write in a bad location' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "DoesNotExist!A1")) . should_fail_with Invalid_Location
            sub_clothes.write out (Excel (Cell_Range "DoesNotExist!A1:B2")) . should_fail_with Invalid_Location
            sub_clothes.write out (Excel (Cell_Range "SillyRangeName")) . should_fail_with Invalid_Location
            out.delete_if_exists

        Test.specify 'should result in Range_Exceeded error if trying to write in too small a range' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "Another!A1:B2")) . should_fail_with Range_Exceeded
            out.delete_if_exists

        Test.specify 'should result in Existing_Data error if in Error mode and trying to replace' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            sub_clothes.write out (Excel (Worksheet 1)) on_existing_file=Existing_File_Behavior.Error . should_fail_with Existing_Data
            sub_clothes.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Error . should_fail_with Existing_Data
            sub_clothes.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Error . should_fail_with Existing_Data
            sub_clothes.write out (Excel (Cell_Range "Sheet1!A9")) on_existing_file=Existing_File_Behavior.Error . should_fail_with Existing_Data
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify 'should not allow adding a new sheet if in Error mode and not clashing' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            result = sub_clothes.write out (Excel (Worksheet "Testing")) on_existing_file=Existing_File_Behavior.Error
            result.should_fail_with File_Error
            result.catch.should_be_a File_Error.Already_Exists
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify 'should write a table to non-existent file as a new sheet without headers' <|
            out.delete_if_exists
            table.write out (Excel (Worksheet "Sheet1") headers=False) on_problems=Report_Error . should_succeed
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['Sheet1']
            written.read 'Sheet1' . should_equal (table.rename_columns ['A', 'B', 'C', 'D', 'E', 'F'])
            out.delete_if_exists

        Test.specify 'should be able to append to a sheet by name' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a sheet by position' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a sheet by name out of order' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a single cell by name' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a single cell by position' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a single cell by name out of order' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a range by name' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB', [4, 5]], ['CC', [True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a', 'b', 'c', 'd', 'e']], ['BB', [1, 2, 3, 4, 5]], ['CC', [True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D6")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a range by position' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D6")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a range by name not in top left' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Random!K9")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Random!K9")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a range by name after deduplication of names' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['AA_1',[True, False]], ['BB_1', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['AA_1',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Random!S3")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Random!S3")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a range by position not in top left' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Random!K9")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Random!K9")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should be able to append to a range by name out of order' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D6")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists

        Test.specify 'should fail to append to a sheet by name if missing columns' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Column_Name_Mismatch
            out.delete_if_exists

        Test.specify 'should fail to append to a sheet by name if extra columns' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Column_Name_Mismatch
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify 'should fail to append to a sheet by name if no headers' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Worksheet "NoHeaders")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Illegal_Argument
            extra_another.write out (Excel (Worksheet "Another") False) on_existing_file=Existing_File_Behavior.Append . should_fail_with Illegal_Argument
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify 'should fail to append to a sheet by position if too few columns' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position . should_fail_with Column_Count_Mismatch
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify 'should fail to append to a sheet by position if too many columns' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position . should_fail_with Column_Count_Mismatch
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify 'should fail to append to a range by name if not large enough' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D5")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Range_Exceeded
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify 'should fail to append to a range by name if it hits another table' <|
            out.delete_if_exists
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Cell_Range "Random!B3")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Existing_Data
            out.last_modified_time.should_equal lmd
            out.delete_if_exists

        Test.specify "should fail if the target file is read-only" <|
            f = enso_project.data / "transient" / "permission."+suffix
            if f.exists then Util.set_writable f True
            f.delete_if_exists

            initial_data = Table.new [["Y", [10, 20, 30]]]
            initial_data.write f
            Util.set_writable f False

            t1 = Table.new [["X", [1, 2, 3]]]
            [Existing_File_Behavior.Backup, Existing_File_Behavior.Overwrite, Existing_File_Behavior.Append].each behavior->
                r1 = t1.write f (Excel (Worksheet "Another")) on_existing_file=behavior
                r1.should_fail_with File_Error
                r1.catch.should_be_a File_Error.Access_Denied
                f.read . read "EnsoSheet" . should_equal initial_data

            Util.set_writable f True
            f.delete

        Test.specify "should fail if the parent directory does not exist" <|
            parent = enso_project.data / "transient" / "nonexistent"
            parent.exists.should_be_false

            f = parent / "foo."+suffix
            t1 = Table.new [["X", [1, 2, 3]]]
            r1 = t1.write f (Excel (Worksheet "Another"))
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Not_Found

        Test.specify "should allow to write and read-back Unicode characters" <|
            encodings = enso_project.data / "transient" / "encodings."+suffix
            t1 = Table.new [["A", ["A", "B", "ðŸ˜Š", "D"]], ["B", [1, 2, 3, 4]]]
            t1.write encodings (Excel (Worksheet "Another"))
            t2 = encodings.read (Excel (Worksheet "Another"))
            t2.at "A" . to_vector . should_equal ["A", "B", "ðŸ˜Š", "D"]
            encodings.delete

        out.delete_if_exists
        out_bak.delete_if_exists

spec =
    Test.group 'Excel Range' <|
        check_range excel_range sheet_name tlbr_vector single_cell=False =
            excel_range.sheet_name . should_equal sheet_name
            excel_range.top_row . should_equal (tlbr_vector.at 0)
            excel_range.left_column . should_equal (tlbr_vector.at 1)
            excel_range.bottom_row . should_equal (tlbr_vector.at 2)
            excel_range.right_column . should_equal (tlbr_vector.at 3)
            excel_range.is_single_cell . should_equal single_cell

        Test.specify 'should be able to parse A1 format' <|
            check_range (Excel_Range.from_address "Test!EE4") 'Test' [4, 135, 4, 135] True
            check_range (Excel_Range.from_address "Test!EE4:EE4") 'Test' [4, 135, 4, 135]
            check_range (Excel_Range.from_address "Test!A1:D5") 'Test' [1, 1, 5, 4]
            check_range (Excel_Range.from_address "Test!1234") 'Test' [1234, Nothing, 1234, Nothing]
            check_range (Excel_Range.from_address "Test!1:4") 'Test' [1, Nothing, 4, Nothing]
            check_range (Excel_Range.from_address "Test!CB") 'Test' [Nothing, 80, Nothing, 80]
            check_range (Excel_Range.from_address "Test!DD:XAZ") 'Test' [Nothing, 108, Nothing, 16276]
            check_range (Excel_Range.from_address "'Hello World'!$EE4") 'Hello World' [4, 135, 4, 135] single_cell=True
            check_range (Excel_Range.from_address "Test!A1:$D$5") 'Test' [1, 1, 5, 4]
            check_range (Excel_Range.from_address "Test!1234") 'Test' [1234, Nothing, 1234, Nothing]
            check_range (Excel_Range.from_address "Test!$1:$4") 'Test' [1, Nothing, 4, Nothing]
            check_range (Excel_Range.from_address "Test!$CB") 'Test' [Nothing, 80, Nothing, 80]
            check_range (Excel_Range.from_address "Test!$DD:$XAZ") 'Test' [Nothing, 108, Nothing, 16276]

        Test.specify 'should be able to parse RC format' <|
            check_range (Excel_Range.from_address "Test!R1C1") 'Test' [1, 1, 1, 1] True
            check_range (Excel_Range.from_address "Test!R1C1:R5C3") 'Test' [1, 1, 5, 3]

        Test.specify 'should fail gracefully for invalid patterns' <|
            Excel_Range.from_address "Test!$$QA1" . should_fail_with Illegal_Argument
            Excel_Range.from_address "Test!BADADDRESS" . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a cell' <|
            check_range (Excel_Range.for_cell "Hello World" 123 14) 'Hello World' [14, 123, 14, 123] True
            check_range (Excel_Range.for_cell "Hello World" "DS" 14) 'Hello World' [14, 123, 14, 123] True
            Excel_Range.for_cell "Test" 123 14 . address . should_equal "Test!DS14"
            Excel_Range.for_cell "Hello World" 123 14 . address . should_equal "'Hello World'!DS14"
            Excel_Range.for_cell "Test" 20000 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" "ZZZ" 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 0 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 1 10000000 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 1 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a range' <|
            check_range (Excel_Range.for_range "Hello World" 55 120 123 14) 'Hello World' [14, 55, 120, 123]
            check_range (Excel_Range.for_range "Hello World" "BC" 120 "DS" 14) 'Hello World' [14, 55, 120, 123]
            Excel_Range.for_range "Test" 55 120 123 14 . address . should_equal "Test!BC14:DS120"
            Excel_Range.for_range "Hello World" 55 120 123 14 . address . should_equal "'Hello World'!BC14:DS120"
            Excel_Range.for_range "Test" 20000 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" "ZZZ" 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 0 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 20000 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 0 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 0 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 10000000 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 123 0 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 123 10000000 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a column' <|
            check_range (Excel_Range.for_columns "Hello World" 123) 'Hello World' [Nothing, 123, Nothing, 123]
            check_range (Excel_Range.for_columns "Hello World" "DS") 'Hello World' [Nothing, 123, Nothing, 123]
            Excel_Range.for_columns "Test" 123 . address . should_equal "Test!DS"
            Excel_Range.for_columns "Hello World" 123 . address . should_equal "'Hello World'!DS"
            Excel_Range.for_columns "Test" 20000 . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" "ZZZ" . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for columns' <|
            check_range (Excel_Range.for_columns "Hello World" "BC" 123) 'Hello World' [Nothing, 55, Nothing, 123]
            check_range (Excel_Range.for_columns "Hello World" 55 "DS") 'Hello World' [Nothing, 55, Nothing, 123]
            Excel_Range.for_columns "Test" 55 123 . address . should_equal "Test!BC:DS"
            Excel_Range.for_columns "Hello World" "BC" "DS" . address . should_equal "'Hello World'!BC:DS"
            Excel_Range.for_columns "Test" 55 20000 . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 55 "ZZZ" . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 55 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a row' <|
            check_range (Excel_Range.for_rows "Hello World" 123) 'Hello World' [123, Nothing, 123, Nothing]
            Excel_Range.for_rows "Test" 123 . address . should_equal "Test!123"
            Excel_Range.for_rows "Hello World" 123 . address . should_equal "'Hello World'!123"
            Excel_Range.for_rows "Test" 20000000 . should_fail_with Illegal_Argument
            Excel_Range.for_rows "Test" 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for rows' <|
            check_range (Excel_Range.for_rows "Hello World" 55 123) 'Hello World' [55, Nothing, 123, Nothing]
            Excel_Range.for_rows "Test" 55 123 . address . should_equal "Test!55:123"
            Excel_Range.for_rows "Hello World" 55 123 . address . should_equal "'Hello World'!55:123"
            Excel_Range.for_rows "Test" 55 20000000 . should_fail_with Illegal_Argument
            Excel_Range.for_rows "Test" 55 0 . should_fail_with Illegal_Argument

    xlsx_sheet = enso_project.data / "TestSheet.xlsx"
    xlsx_path = xlsx_sheet.path

    xls_sheet = enso_project.data / "TestSheetOld.xls"
    xls_path = xls_sheet.path

    sheet_names = ["Sheet1", "Another", "NoHeaders", "Random"]
    range_names = ["myData"]

    col_a = ["Test", "Here", "Is", "Data"]
    col_b = [1, 2, 3, 4]
    col_c = [Date.new 2022 06 12, Date.new 2022 10 20, Date.new 2022 07 30, Date.new 2022 10 15]
    col_d = [Time_Of_Day.new 12 34 56, Time_Of_Day.new 1 23 45, Time_Of_Day.new 2 46, Time_Of_Day.new 9]
    col_e = [Date_Time.new 2022 06 12 12 34 56, Date_Time.new 2022 10 20 1 23 45, Date_Time.new 2022 07 30 2 46, Date_Time.new 2022 10 15 9]

    check_column col expected =
        start = col.length - expected.length
        0.up_to start . map i->(col.at i . should_equal Nothing)
        start.up_to col.length . map i->(col.at i . should_equal (expected.at (i - start)))

    check_table table count=5 =
        table.column_count . should_equal count
        if count > 0 then check_column (table.at "A") col_a
        if count > 1 then check_column (table.at "B") col_b
        if count > 2 then check_column (table.at "C") col_c
        if count > 3 then check_column (table.at "D") col_d
        if count > 4 then check_column (table.at "E") col_e

    check_workbook workbook sheets=sheet_names.length ranges=range_names.length =
        workbook.is_a Excel_Workbook . should_be_true
        workbook.sheet_count . should_equal sheets
        workbook.named_ranges_count . should_equal ranges

    Test.group "Read XLSX / XLS Files" <|
        Test.specify "should let you read the workbook with Auto_Detect" <|
            check_workbook <| xlsx_sheet.read
            check_workbook <| Data.read xlsx_sheet
            check_workbook <| Data.read xlsx_path

            check_workbook <| xls_sheet.read
            check_workbook <| Data.read xls_sheet
            check_workbook <| Data.read xls_path

        Test.specify "should let you read the workbook with Excel" <|
            check_workbook <| xlsx_sheet.read Excel
            check_workbook <| Data.read xlsx_sheet Excel
            check_workbook <| Data.read xlsx_path Excel

            check_workbook <| xls_sheet.read Excel
            check_workbook <| Data.read xls_sheet Excel
            check_workbook <| Data.read xls_path Excel

        Test.specify "workbook should look like a database connection" <|
            workbook = xlsx_sheet.read

            workbook.database . should_equal xlsx_sheet.normalize.path
            workbook.schema . should_equal Nothing

            workbook.table_types . should_equal ['Worksheet', 'Named Range']

            workbook.tables.row_count . should_equal (sheet_names.length + range_names.length)
            workbook.tables.at "Name" . to_vector . should_contain_the_same_elements_as (sheet_names + range_names)

            workbook.tables types=["Worksheet"] . row_count . should_equal sheet_names.length
            workbook.tables types=["Named Range"] . row_count . should_equal range_names.length
            workbook.tables types=["XXX"] . row_count . should_equal 0

            workbook.tables "%not%" . row_count . should_equal 1
            workbook.tables "%not%" . at 'Name' . to_vector . should_equal ["Another"]

        Test.specify "should let you read the sheet names" <|
            xlsx_sheet.read (Excel Sheet_Names) . should_equal sheet_names
            xls_sheet.read (Excel Sheet_Names) . should_equal sheet_names
            xlsx_sheet.read . sheet_names . should_equal sheet_names

        Test.specify "should let you read the range names" <|
            xlsx_sheet.read (Excel Range_Names) . should_equal range_names
            xls_sheet.read (Excel Range_Names) . should_equal range_names
            xlsx_sheet.read . named_ranges . should_equal range_names

        Test.specify "should let you read by sheet index" <|
            table = xlsx_sheet.read (Excel (Worksheet 1))
            check_table table

            table_2 = xlsx_sheet.read (Excel (Worksheet 1 (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

        Test.specify "should let you read by sheet name" <|
            table = xlsx_sheet.read (Excel (Worksheet "Sheet1"))
            check_table table

            table_2 = xlsx_sheet.read (Excel (Worksheet "Sheet1" (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

            table_3 = xlsx_sheet.read . read "Sheet1"
            check_table table_3

        Test.specify "should let you read XLS by sheet index" <|
            table = xls_sheet.read (Excel (Worksheet 1))
            check_table table

            table_2 = xls_sheet.read (Excel (Worksheet 1 (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

        Test.specify "should let you read XLS by sheet name" <|
            table = xls_sheet.read (Excel (Worksheet "Sheet1"))
            check_table table

            table_2 = xls_sheet.read . read "Sheet1"
            check_table table_2

        Test.specify "should let you read by range" <|
            table = xlsx_sheet.read (Excel (Cell_Range "Sheet1!A:C"))
            check_table table 3

            table_2 = xlsx_sheet.read (Excel (Cell_Range "Sheet1!A:C" (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2 3

            check_table <| xlsx_sheet.read (Excel (Cell_Range "Sheet1!10:13"))
            check_table count=3 <| xlsx_sheet.read (Excel (Cell_Range "Sheet1!A10:C13"))

            check_table <| xlsx_sheet.read . read "Sheet1!10:13"
            check_table count=3 <| xlsx_sheet.read . read "Sheet1!A10:C13"

        Test.specify "should let you read by range name" <|
            table = xlsx_sheet.read (Excel (Cell_Range "myData"))
            table.row_count . should_equal col_a.length
            check_table table 3

            table_2 = xlsx_sheet.read . read "myData"
            table_2.row_count . should_equal col_a.length
            check_table table_2 3

        Test.specify "should let you restrict number of rows read and skip rows" <|
            table = xlsx_sheet.read (Excel (Worksheet "Sheet1"))
            check_table table

            table_2 = xlsx_sheet.read (Excel (Worksheet "Sheet1" (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

            table_3 = xlsx_sheet.read (Excel (Worksheet "Sheet1" (table.row_count - col_a.length) 2))
            table_3.row_count . should_equal 2

            table_4 = xlsx_sheet.read (Excel (Worksheet "Sheet1" row_limit=6))
            table_4.row_count . should_equal 6

    Test.group "Problems" <|
        Test.specify "should handle non-existing file gracefully" <|
            bad_file = enso_project.data / "DoesNotExists.xlsx"
            result = bad_file.read (Excel (Cell_Range "Sheet1!A:C"))
            result.should_fail_with File_Error
            result.catch.should_be_a File_Error.Not_Found

        Test.specify "should handle wrong xls_format gracefully" <|
            r1 = xlsx_sheet.read (Excel (Cell_Range "Sheet1!A:C") xls_format=True)
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Corrupted_Format

            r2 = xls_sheet.read (Excel (Cell_Range "Sheet1!A:C") xls_format=False)
            r2.should_fail_with File_Error
            r2.catch.should_be_a File_Error.Corrupted_Format

        Test.specify "should handle malformed XLS files gracefully" <|
            bad_file = enso_project.data / "transient" / "malformed.xls"
            "not really an XLS file contents...".write bad_file on_existing_file=Existing_File_Behavior.Overwrite

            r1 = bad_file.read
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Corrupted_Format
            r1.catch.to_display_text.should_contain "is corrupted"

            r1a = bad_file.read Excel
            r1a.should_fail_with File_Error
            r1a.catch.should_be_a File_Error.Corrupted_Format

            r1b = bad_file.read (Excel Sheet_Names)
            r1b.should_fail_with File_Error
            r1b.catch.should_be_a File_Error.Corrupted_Format

            r2 = bad_file.read (Excel (Cell_Range "Sheet1!A:C"))
            r2.should_fail_with File_Error
            r2.catch.should_be_a File_Error.Corrupted_Format
            r2.catch.to_display_text.should_contain "is corrupted"

            bad_file.delete

    spec_fmt 'XLSX reading' Examples.xlsx .read

    spec_fmt 'XLS reading' Examples.xls .read

    Test.group "Reading single cells correctly" <|
        file = enso_project.data / "RangeTests.xlsx"

        check_table table col_names data =
            table.column_count . should_equal col_names.length
            table.columns.map .name . should_equal col_names
            data.each_with_index idx->values->
                table.at (col_names.at idx) . to_vector . should_equal values

        Test.specify "Simple table" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!A1"))) ["AA", "BB"] [[1,2,3,4,5,6], ["A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!A2"))) ["A", "B"] [[1,2,3,4,5,6], ["A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!A1:A1"))) ["A"] [["AA"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!B1"))) ["B"] [["BB", "A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!B1") headers=True)) ["BB"] [["A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!B2"))) ["B"] [["A","B","C","D","E","F"]]

        Test.specify "Patchy table" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!D1"))) ["A", "B", "Column_1"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (Excel (Cell_Range "Sheet1!D2"))) ["D", "E", "F"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (Excel (Cell_Range "Sheet1!E"))) ["B"] [[4,4,Nothing,Nothing,Nothing,Nothing]]
            check_table (file.read (Excel (Cell_Range "Sheet1!E1"))) ["B", "Column_1"] [[4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (Excel (Cell_Range "Sheet1!E2"))) ["E", "F"] [[4,4,Nothing], [6,Nothing,6]]

        Test.specify "Single cell" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!H1"))) ["H"] [["Single Cell"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!H2"))) ["H"] [[]]

        Test.specify "Single line" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!J1"))) ["J", "K", "L"] [["Just"],["Some"],["Headers"]]

        Test.specify "Growing table" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!N1"))) ["A", "Full", "Table", "Column_1"] [["Hello","World",Nothing,"Extend"],[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!O1"))) ["Full", "Table", "Column_1"] [[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!O2"))) ["O", "P", "Q"] [[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]

        Test.specify "Should handle invalid headers with warnings" <|
            action = file.read (Excel (Cell_Range "Sheet1!D1")) on_problems=_
            tester = check_table _ ["A", "B", "Column_1"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]
            problems = [Invalid_Output_Column_Names.Error [""]]
            Problems.test_problem_handling action problems tester

        Test.specify "Should handle duplicate headers with warnings" <|
            action = file.read (Excel (Cell_Range "Sheet1!S1")) on_problems=_
            tester = check_table _ ["DD", "DD_1"] [[1,3], [2,4]]
            problems = [Duplicate_Output_Column_Names.Error ["DD"]]
            Problems.test_problem_handling action problems tester

    spec_write "xlsx" 'TestSheet.xlsx'
    spec_write "xls" 'TestSheetOld.xls'

main = Test_Suite.run_main spec
