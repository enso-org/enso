from Standard.Base import all

polyglot java import java.lang.Long

from Standard.Test import Test, Test_Suite
import Standard.Test.Extensions

type My_Warning
    Value reason

type My_Type
    Value a b c
My_Type.my_method self = self.a + self.b + self.c

type Wrap
    Value foo

rewrap w = case w of
    Wrap.Value a -> Wrap.Value a+1

poly_sum x y =
    Long.sum x y

get_foo x = x.foo

unwrap x = Integer.from x

reassign_test x =
    consed = Wrap.Value x
    reconsed = rewrap consed
    i = unwrap reconsed
    rereconsed = Wrap.Value i
    x1 = get_foo rereconsed
    prim_sum = 1 + x1
    r = poly_sum prim_sum 1
    r

baz value = Warning.attach value "I have warned you"
bar value = baz value
foo value = bar value

Integer.from (that:Wrap) = that.foo

attach_four_warnings value =
    v1 = Warning.attach 4 value
    v2 = Warning.attach 3 v1
    v3 = Warning.attach 2 v2
    v4 = Warning.attach 1 v3
    v4

odd_warning_mapper payload = case payload of
    _ : Integer -> if payload % 2 == 0 then Nothing else Maybe.Some (payload + 10)
    _ -> Nothing

odd_warning_filter payload = case payload of
    _ : Integer -> if payload % 2 == 0 then False else True
    _ -> False

map_odd_warnings value =
    Warning.map_attached_warnings odd_warning_mapper value

map_odd_warnings_and_errors value =
    Warning.map_warnings_and_errors odd_warning_mapper value

throw_a_bar =
    Panic.throw "bar"

Any.is_static_nothing x = x.is_nothing

spec = Test.group "Dataflow Warnings" <|
    Test.specify "should allow to attach multiple warnings and read them back" <|
        x = 1233
        y = Warning.attach "don't do this" x
        z = Warning.attach "I'm serious" y
        Warning.get_all z . map .value . should_equal ["I'm serious", "don't do this"]

    Test.specify "should thread warnings through constructor calls" <|
        z = Warning.attach (My_Warning.Value "warn!!!") 3
        y = Warning.attach (My_Warning.Value "warn!!") 2
        x = Warning.attach (My_Warning.Value "warn!") 1
        mtp = My_Type.Value x y z
        mtp.should_equal (My_Type.Value 1 2 3)
        Warning.get_all mtp . map .value . should_equal [My_Warning.Value "warn!", My_Warning.Value "warn!!", My_Warning.Value "warn!!!"]

    Test.specify "should thread warnings through method calls" <|
        mtp = My_Type.Value 1 2 3
        warned = Warning.attach "omgggg" mtp
        r = warned.my_method
        r.should_equal 6
        Warning.get_all r . map .value . should_equal ["omgggg"]

    Test.specify "should thread warnings through polyglot calls" <|
        y = Warning.attach "warn!!" 2
        x = Warning.attach "warn!" 1
        r = Long.sum x y
        r.should_equal 3
        Warning.get_all r . map .value . should_equal ['warn!', 'warn!!']

    Test.specify "should be passed correctly when combined with warnings added in branches" <|
        one = Warning.attach "first" "1"

        b = case one of
            _ : Text -> Warning.attach "a" True
            _        -> Warning.attach "b" False

        v = case b of
            True -> 0
            False -> 1

        v . should_equal 0
        Warning.get_all v . map .value . should_equal ["a", "first"]

    Test.specify "should thread warnings through case expressions" <|
        z = Warning.attach (My_Warning.Value "warn!!!") 3
        y = Warning.attach (My_Warning.Value "warn!!") 2
        x = Warning.attach (My_Warning.Value "warn!") 1
        mtp = My_Type.Value x y z
        r = case mtp of
            My_Type.Value a b c -> a + b + c
        r.should_equal 6
        Warning.get_all r . map .value . should_equal [My_Warning.Value "warn!", My_Warning.Value "warn!!", My_Warning.Value "warn!!!"]

    Test.specify "should thread warnings through conversions" <|
        z = Wrap.Value (Warning.attach 'warn!' 1)
        i = Integer.from z
        Warning.get_all i . map .value . should_equal ['warn!']

    Test.specify "should attach correct stacktraces" <|
        current = Runtime.get_stack_trace
        warned = foo "value"
        warning_stack = Warning.get_all warned . head . origin
        relevant = warning_stack . drop (Last current.length)
        relevant.map .name . should_equal (['baz', 'bar', 'foo'].map ('Warnings_Spec.'+))

    Test.specify "should attach reassignment info in the last-reassigned-first order" <|
        x = Warning.attach "warn!" 1
        r = reassign_test x
        warn = Warning.get_all r . head
        reassignments = warn.reassignments.map .name
        reassignments.should_equal ['Warnings_Spec.poly_sum', 'Small_Integer.+', 'Warnings_Spec.get_foo', 'Wrap.Value', 'Warnings_Spec.unwrap', 'Warnings_Spec.rewrap', 'Wrap.Value']

    Test.specify "should allow to set all warnings" <|
        warned = Warning.attach 1 <| Warning.attach 2 <| Warning.attach 3 <| Warning.attach 4 "foo"
        warnings = Warning.get_all warned
        filtered = warnings.filter x-> x.value % 2 == 0
        rewarned = Warning.set warned filtered
        rewarned.should_equal 'foo'
        Warning.get_all rewarned . map .value . should_contain_the_same_elements_as [2,4]

    Test.specify "should allow to map the warnings, selectively" <|
        warned = attach_four_warnings "foo"
        mapped = map_odd_warnings warned
        mapped . should_equal 'foo'
        Warning.get_all mapped . map .value . should_contain_the_same_elements_as [11, 2, 13, 4]

    Test.specify "should allow to map warnings and errors, selectively" <|
        warned = attach_four_warnings "foo"
        mapped = map_odd_warnings_and_errors warned
        mapped . should_equal 'foo'
        Warning.get_all mapped . map .value . should_contain_the_same_elements_as [11, 2, 13, 4]
        Warning.get_all mapped . map (w-> w.origin.first.name) . should_contain_the_same_elements_as ["Warnings_Spec.map_odd_warnings_and_errors", "Warnings_Spec.attach_four_warnings"]

        errored_2 = Error.throw 7
        mapped_2 = map_odd_warnings_and_errors errored_2
        mapped_2.catch . should_equal 17
        Warning.get_all mapped_2 . catch . should_equal 17

        errored_3 = Panic.recover Any throw_a_bar
        mapped_3 = map_odd_warnings_and_errors errored_3
        mapped_3.catch . should_equal "bar"
        mapped_3.stack_trace.second.name . should_equal "Warnings_Spec.throw_a_bar"
        Warning.get_all mapped_3 . catch . should_equal "bar"

    Test.specify "should allow to detach warnings, selectively" <|
        warned = attach_four_warnings "foo"
        detached_pair = Warning.detach_selected_warnings warned odd_warning_filter
        detached_pair . first . should_equal "foo"
        Warning.get_all (detached_pair . first) . map .value . should_equal [2,4]
        detached_pair.second . map .value . should_equal [1,3]

    Test.specify "should allow to map the warnings, selectively" <|
        x = Warning.attach "foo" 1
        result = x.is_static_nothing x
        result . should_equal False

    Test.specify "should be allowed in Vector" <|
        a = Warning.attach "a" 1
        b = Warning.attach "b" 2
        c = [a, b]
        d = Warning.attach "d" c
        c . should_equal [1, 2]
        Warning.get_all c . map .value . should_equal ["b", "a"]
        Warning.get_all d . map .value . should_equal ["d", "b", "a"]

    Test.specify "should be preserved after operations on Vector" <|
        even x = (Warning.attach x x) % 2
        res = [1,2,3,4].map even

        res . should_equal [1, 0, 1, 0]
        Warning.get_all res . map .value . should_equal [4, 3, 2, 1]
        res.at 0 . should_equal 1
        Warning.get_all (res.at 0) . map .value . should_equal [4, 3, 2, 1]

        slice = res.slice 1 4
        Warning.get_all slice . map .value . should_equal [4, 3, 2, 1]

        zero = even 0
        Warning.get_all zero . map .value . should_equal [0]

        v = 0.up_to 10 . to_vector
        r = v.map x->(if x % 2 == 0 then 10*x else Warning.attach 100*x x)
        r.should_equal [0, 1, 20, 3, 40, 5, 60, 7, 80, 9]
        Warning.get_all r . map .value . should_contain_the_same_elements_as [100, 300, 500, 700, 900]

    Test.specify "should be preserved after operations on multi-dimensional Vector" <|
        even x = (Warning.attach x x) % 2
        nested_range_even x =
            (0.up_to x).to_vector.map even
        res = [1, 2, 3, 4].map nested_range_even

        res . should_equal [[0], [0, 1], [0, 1, 0], [0, 1, 0, 1]]
        Warning.get_all res . map .value . should_equal [3, 2, 1, 0, 2, 1, 0, 1, 0, 0]
        Warning.get_all (res.at 2) . map .value . should_equal [3, 2, 1, 0, 2, 1, 0, 1, 0, 0]

main = Test_Suite.run_main spec
