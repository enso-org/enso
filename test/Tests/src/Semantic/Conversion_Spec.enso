from Standard.Base import all
import Standard.Base.Errors.Common.No_Such_Conversion
import Standard.Base.Errors.Common.Type_Error

import project.Semantic.Conversion.Methods
import project.Semantic.Conversion.Types
import project.Semantic.Conversion_Use.Hello

from Standard.Test import Test, Test_Suite
import Standard.Test.Extensions

polyglot java import java.lang.Object

type Foo
    Value foo
type Bar
    Value bar
type Baz
    Value baz
type Quux
    Value quux
type Quaffle
type My_Error
    Value err

type Not_Foo
    Value notfoo

Foo.from (that:Bar) = Foo.Value that.bar
Foo.from (that:Baz) = Foo.Value that.baz
Foo.from (that:Text) = Foo.Value that.length
Foo.from (that:Number) first_param=0 second_param=0 third_param=0 = Foo.Value [that, first_param, second_param, third_param]
Foo.from (that:Function) = Foo.Value (that 5)
Foo.from (that:Boolean) = Foo.Value that
Foo.from (that:Array) = Foo.Value that.length

Not_Foo.from (_:Boolean) = Not_Foo.Value True
Not_Foo.from (_:Any) = Not_Foo.Value "ANY!!!"

Foo.from (_:Quaffle) = Foo.Value "quaffle"
Foo.from (_:Error) = Foo.Value "oops"

type MultiNumber
    Value v

Integer.from (that:MultiNumber) = that.v * 19
Number.from (that:MultiNumber) = that.v * 0.3
Float.from (that:MultiNumber) = that.v * 0.7

foreign js make_str x = """
   return "js string"

foreign js call_function fn arg_1 = """
    return fn(arg_1, "a string");

Number.foo self = "foo called"

type Fool
    Value fool

    to_text : Text
    to_text self = "{FOOL " + self.fool.to_text + "}"

Fool.from (that : Any) = Fool.Value that

type Blob
    Text c:Text
    Binary b:File
    Json anything


Blob.from (that:Text) = Blob.Text that
Blob.from (that:File) = Blob.Binary that
Blob.from (that:Any) = Blob.Json that

spec =
    Test.group "Conversion" <|
        Test.specify "should be able to convert atoms" <|
            ((Foo.from (Baz.Value 10)).foo + (Foo.from (Bar.Value 20)).foo) . should_equal 30
            Foo.from Quaffle . foo . should_equal "quaffle"
        Test.specify "should be able to convert text" <|
            Foo.from "123" . foo . should_equal 3
        Test.specify "should be able to convert foreign text" <|
            Foo.from (make_str 4) . foo . should_equal 9
        Test.specify "should be able to convert numbers" <|
            Foo.from 4 . should_equal (Foo.Value [4, 0, 0, 0])
            Foo.from (10^100) . should_equal (Foo.Value [10^100, 0, 0, 0])
            Foo.from 4.5 . should_equal (Foo.Value [4.5, 0, 0, 0])
        Test.specify "should be able to convert dataflow errors" <|
            Foo.from (Error.throw <| My_Error.Value "i was bad") . should_equal (Foo.Value "oops")
        Test.specify "should be able to convert functions" <|
            Foo.from (e -> e) . foo . should_equal 5
        Test.specify "should be able to convert booleans" <|
            Foo.from True . foo . should_be_true
            Foo.from False . foo . should_be_false
        Test.specify "should be able to convert arrays" <|
            Foo.from [1,2,3].to_array . foo . should_equal 3
        Test.specify "should be able to convert Any" <|
            Not_Foo.from that=Quaffle . notfoo . should_equal "ANY!!!"
            Not_Foo.from 4 . notfoo . should_equal "ANY!!!"
            Not_Foo.from (e -> e) . notfoo . should_equal "ANY!!!"
            Not_Foo.from [1,2,3].to_array . notfoo . should_equal "ANY!!!"
            Not_Foo.from [1,2,3] . notfoo . should_equal "ANY!!!"
        Test.specify "apply Any conversion to foreign object" <|
            Not_Foo.from Object.new . notfoo . should_equal "ANY!!!"
        Test.specify "apply Any conversion to type" <|
            Not_Foo.from Boolean . notfoo . should_equal "ANY!!!"
        Test.specify "should call intrinsic object conversions for unimported constructors" <|
            Vector.from Methods.get_foo . should_equal ["foo"]
        Test.specify "should call extension conversions" <|
            Text.from Methods.get_bar . should_equal "bar"

        Test.specify "should fail graciously when there is no conversion" <|
            Panic.recover Any (Foo.from (Quux.Value 10)) . catch Any .to_display_text . should_equal "Could not find a conversion from `Quux.Value` to `Foo`."
        Test.specify "should fail graciously when the conversion target is invalid" <|
            Panic.recover Any (123.from (Quux.Value 10)) . catch Any .to_display_text . should_equal "123 is not a valid conversion target. Expected a type."

        Test.specify "should be callable with by-name arguments" <|
            .from self=Foo that=4 first_param=2 . should_equal (Foo.Value [4, 2, 0, 0])
        Test.specify "should support the use of multiple arguments" <|
            Foo.from that=4 second_param=1 2 . should_equal (Foo.Value [4, 2, 1, 0])

        Test.specify "should play nicely with polyglot" <|
            call_function .from Foo . should_equal (Foo.Value 8)

        Test.specify "should support the meta functions" <|
            meta_from = Meta.meta .from
            is_symbol = case meta_from of
                _ : Meta.Unresolved_Symbol -> True
                _ -> False
            is_symbol.should_be_true

            .from . to_text . should_equal "UnresolvedConversion"

            meta_from.name.should_equal "from"

            Meta.meta .foo . rename "from" . should_equal .from
            Meta.meta .foo . rename "from" Foo "hello" . should_equal (Foo.Value 5)

            meta_from.rename "foo" 123 . should_equal "foo called"
            meta_from.rename "foo" . should_equal .foo

        Test.specify "should not allow currying" <|
            Panic.recover Any (Foo.from) . catch Any .to_display_text . should_equal "Conversion currying without `that` argument is not supported."

        Test.specify "Use conversions to in Conversion_Use module" <|
            Hello.formulate [ Hello.Say "Proper", Hello.Say "Type" ] . should_equal "ProperType"
            Hello.formulate [ Foo.Value "Perform", Bar.Value "Conversion" ] . should_equal "PERFORM conversion!"

        Test.specify "Convert Foo.to Hello" <|
            hello = Foo.Value "Perform" . to Hello
            hello . msg . should_equal "PERFORM "

        Test.specify "Convert Bar.to Hello" <|
            hello = Bar.Value "Conversion" . to Hello
            hello . msg . should_equal "conversion!"

        Test.specify "Convert Bar.to Hello with other suffix" <|
            hello = Bar.Value "Conversion" . to Hello suffix="?"
            hello . msg . should_equal "conversion?"

        Test.specify "Idempotent convert Hello.to Hello" <|
            Hello.Say "Hi there!" . to Hello . msg . should_equal "Hi there!"

        Test.specify "Unknown convertion Text.to Hello" <|
            h = Panic.recover No_Such_Conversion <| "Hi there!" . to Hello
            h . should_fail_with No_Such_Conversion

        Test.specify "Use Any.to in Conversion_Use module" <|
            Hello.formulate_with_to [ Hello.Say "Proper", Hello.Say "Type" ] . should_equal "ProperType"
            Hello.formulate_with_to [ Foo.Value "Perform", Bar.Value "Conversion" ] . should_equal "PERFORM conversion!"

        Test.specify "Avoid parameter conversion of Blob into Blob" <|
            blob_me (b:Blob) = b

            once = blob_me "Ahoj"
            second = blob_me once

            Meta.type_of once . should_equal Blob
            Meta.type_of second . should_equal Blob
            once . should_equal second
            Meta.is_same_object once second . should_be_true

        Test.specify "Avoid Any.to conversion of Blob into Blob" <|
            blob_me b = b.to Blob

            once = blob_me "Ahoj"
            second = blob_me once

            Meta.type_of once . should_equal Blob
            Meta.type_of second . should_equal Blob
            once . should_equal second
            Meta.is_same_object once second . should_be_true

        Test.specify "Avoid inline conversion of Blob into Blob" <|
            once = "Ahoj" : Blob
            second = once : Blob

            Meta.type_of once . should_equal Blob
            Meta.type_of second . should_equal Blob
            once . should_equal second
            Meta.is_same_object once second . should_be_true

        Test.specify "Requesting Text & Foo" <|
            check a (n : Text & Foo) = case a of
                0 -> n.foo
                1 -> n.take (First 3)

            check 0 "Ahoj" . should_equal 4
            check 1 "Ahoj" . should_equal "Aho"

            # Boolean can be converted to Foo, but is not Text
            fail = Panic.recover Type_Error <| check 0 True
            fail . should_fail_with Type_Error

        Test.specify "Requesting Foo & Not_Foo & Boolean" <|
            check a (n : Foo & Not_Foo & Boolean) = case a of
                0 -> n.foo
                1 -> n.not
                2 -> n.notfoo

            check 0 True . should_be_true
            check 1 True . should_be_false
            check 2 True . should_be_true

            fail = Panic.recover Type_Error <| check 0 "not a boolean"
            fail . should_fail_with Type_Error

        Test.specify "Requesting Number & Integer & Float" <|
            m = MultiNumber.Value 5

            m.to Number . should_equal 1.5
            m.to Integer . should_equal 95
            m.to Float . should_equal 3.5

            to_1 (v : Number & Integer & Float) = v
            to_1 m . should_equal 1.5

            to_2 (v : Integer & Float & Number) = v
            to_2 m . should_equal 95

            to_3 (v : Float & Number & Integer) = v
            to_3 m . should_equal 3.5

            to_4 (v : Integer & Number & Float) = v
            to_4 m . should_equal 95

            to_5 (v : Float & Integer & Number) = v
            to_5 m . should_equal 3.5

            to_6 (v : Number & Float & Integer) = v
            to_6 m . should_equal 1.5

        Test.specify "Requesting Integer & Fool" <|
            do_number (x : Integer & Fool) =
                x.foo . should_equal "foo called"
                x.fool . should_equal 42
                x==x . should_be_true
                (x:Integer)==42 . should_be_true
                (x:Fool)==42 . should_be_false
                x==42 . should_be_true
                42==(x.to Integer) . should_be_true
                42==(x.to Fool) . should_be_false
                42==x . should_be_true
                100+(x:Integer) . should_equal 142
                (x:Integer)+100 . should_equal 142
                x+100 . should_equal 142
                100+x . should_equal 142
                x.to_text . should_equal "{FOOL 42}"
                (x:Fool).to_text . should_equal "{FOOL 42}"
                (x:Integer).to_text . should_equal "42"

            do_number 42

        Test.specify "Requesting Float & Fool" <|
            do_number (x : Float & Fool) =
                x.foo . should_equal "foo called"
                x.fool . should_equal 42.3
                x==x . should_be_true
                (x:Float)==42.3 . should_be_true
                (x:Fool)==42.3 . should_be_false
                x==42.3 . should_be_true
                42.3==(x.to Float) . should_be_true
                42.3==(x.to Fool) . should_be_false
                42.3==x . should_be_true
                100+(x:Float) . should_equal 142.3
                (x:Float)+100 . should_equal 142.3
                x+100 . should_equal 142.3
                100+x . should_equal 142.3
                x.to_text . should_equal "{FOOL 42.3}"
                (x:Fool).to_text . should_equal "{FOOL 42.3}"
                (x:Float).to_text . should_equal "42.3"

            do_number 42.3

        Test.specify "Requesting Boolean & Fool" <|
            do_boolean (x : Boolean & Fool) =
                x.fool . should_equal True
                x==x . should_be_true
                (x:Boolean) . should_be_true
                (x:Fool)==True . should_be_false
                x==True . should_be_true
                True==(x:Boolean) . should_be_true
                True==(x:Fool) . should_be_false
                True==x . should_be_true
                x.to_text . should_equal "{FOOL True}"
                (x:Fool).to_text . should_equal "{FOOL True}"
                (x:Boolean).to_text . should_equal "True"
                Panic.recover Any (x:Integer).to_text . should_fail_with Type_Error

            do_boolean True

        Test.specify "Requesting Text & Fool" <|
            do_text (x : Text & Fool) =
                x.fool . should_equal "Hello"
                x==x . should_be_true
                (x:Text)=="Hello" . should_be_true
                (x:Fool)=="Hello" . should_be_false
                x=="Hello" . should_be_true
                "Hello"==(x:Text) . should_be_true
                "Hello"==(x:Fool) . should_be_false
                "Hello"==x . should_be_true
                x.to_text . should_equal "Hello"
                (x:Fool).to_text . should_equal "{FOOL Hello}"
                (x:Text).to_text . should_equal "Hello"
                Panic.recover Any (x:Boolean).to_text . should_fail_with Type_Error

            do_text "Hello"

        Test.specify "Requesting Time_Of_Day & Fool" <|
            now = Time_Of_Day.now

            do_time (x : Time_Of_Day & Fool) =
                x.fool . should_equal now
                x==x . should_be_true
                (x:Time_Of_Day)==now . should_be_true
                (x:Fool)==now . should_be_false
                x==now . should_be_true
                now==(x:Time_Of_Day) . should_be_true
                now==(x:Fool) . should_be_false
                now==x . should_be_true
                x.to_text . should_equal now.to_text

            do_time now

        Test.specify "Requesting Date & Fool" <|
            now = Date.today

            do_date (x : Date & Fool) =
                x.fool . should_equal now
                x==x . should_be_true
                (x:Date)==now . should_be_true
                (x:Fool)==now . should_be_false
                x==now . should_be_true
                now==(x:Date) . should_be_true
                now==(x:Fool) . should_be_false
                now==x . should_be_true
                x.to_text . should_equal "{FOOL "+now.to_text+"}"

            do_date now

        Test.specify "Requesting Date_Time & Fool" <|
            now = Date_Time.now

            do_time (x : Date_Time & Fool) =
                x.fool . should_equal now
                x==x . should_be_true
                (x:Date_Time)==now . should_be_true
                (x:Fool)==now . should_be_false
                x==now . should_be_true
                now==(x:Date_Time) . should_be_true
                now==(x:Fool) . should_be_false
                now==x . should_be_true
                x.to_text . should_equal now.to_text

            do_time now

        Test.specify "Requesting Duration & Fool" <|
            now = Duration.new hours=5

            do_duration (x : Duration & Fool) =
                x.fool . should_equal now
                x==x . should_be_true
                (x:Duration)==now . should_be_true
                (x:Fool)==now . should_be_false
                x==now . should_be_true
                now==(x:Duration) . should_be_true
                now==(x:Fool) . should_be_false
                now==x . should_be_true
                x.to_text . should_equal "{FOOL "+now.to_text+"}"

            do_duration now

Hello.from (that:Foo) suffix=" " = Hello.Say <| (that.foo.to_case Case.Upper) + suffix
Hello.from (that:Bar) suffix="!" = Hello.Say <| (that.bar.to_case Case.Lower) + suffix

main = Test_Suite.run_main spec
