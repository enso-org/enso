class Bool:
    True
    False

    def toText: case self of
        True:  "True"
        False: "False"

    def toJSON: JSONBool self

    def shortRep: self . toText

    def and that: case self of
        True: case that of
            True: True
            False: False
        False: False

    def or that: case self of
        True: True
        False: case that of
            True:  True
            False: False

    def equals that: case self of
        True: case that of
            True:  True
            False: False
        False: case that of
            True:  False
            False: True

    def not: case self of
        True:  False
        False: True

def if_then_else pred ifTrue ifFalse: case pred of
    True:  ifTrue
    False: ifFalse

def switch: if_then_else

def id a: a

def const a b: a

def when p f: if p then f else None

def unless p f: if p then None else f

def seq a b:
    a
    b

class None:
    None

    def toText: "None"

    def shortRep: self.toText

    def toJSON: JSONNull

class Tuple2 a b:
    Tuple2 a b

    def shortRep: "(" + a.shortRep + ", " + b.shortRep + ")"

    def toJSON: case self of
        Tuple2 a b: JSONArray (Prepend a.toJSON (Prepend b.toJSON Empty))

    def first: case self of
        Tuple2 a b: a

    def second: case self of
        Tuple2 a b: b

    def map f: Tuple2 (f self.first) (f self.second)

    def toText: case self of
        Tuple2 a b: "Tuple2 " + a.toText + " " + b.toText

    def shortRep: case self of
        Tuple2 a b: "(" + a.shortRep + ", " + b.shortRep + ")"

    def equals that:
        self.first.equals that.first . and (self.second.equals that.second)

class Tuple3 a b c:
    Tuple3 a b c

    def toJSON: case self of
        Tuple3 a b c: JSONArray (Prepend a.toJSON (Prepend b.toJSON (Prepend c.toJSON Empty)))

    def first: case self of
        Tuple3 a b c: a

    def second: case self of
        Tuple3 a b c: b

    def third: case self of
        Tuple3 a b c: c

    def map f: Tuple3 (f self.first) (f self.second) (f self.third)

    def toText: case self of
        Tuple3 a b c: "Tuple3 " + a.toText + " " + b.toText + " " + c.toText

    def shortRep: case self of
        Tuple3 a b c: "(" + a.shortRep + ", " + b.shortRep + ", " + c.shortRep + ")"

    def equals that: case that of
        Tuple3 a b c: self.first.equals a . and (self.second.equals b) . and (self.third.equals c)
        other:        False

class Maybe a:
    Nothing
    Just a

    def toJSON: case (self) of
        Just a: a.toJSON
        Nothing: JSONNull

    def toList: case (self) of
        Just a: Prepend a Empty
        Nothing: Empty

    def fromJust: case self of
        Just a:  a
        Nothing: errorStr "Maybe.fromJust: Nothing"

    def fromMaybe defVal: case self of
        Just a: a
        Nothing: defVal

    def maybe defVal f: case self of
        Just a: f a
        Nothing: defVal

    def isJust: case self of
        Just a: True
        Nothing: False

    def isNothing: case self of
        Nothing: True
        Just a: False

    def map f: case self of
        Nothing: Nothing
        Just a: Just (f a)

    def toText: case self of
        Just a: "Just " + a.toText
        Nothing: "Nothing"

    def shortRep: case self of
        Just a: "Just " + a.shortRep
        Nothing: "Nothing"

    def toText: self.shortRep

    def equals that: case self of
        Just a: case that of
            Just b:  a.equals b
            Nothing: False
        Nothing: case that of
            Nothing: True
            other:   False

class List a:
    Empty
    Prepend a (List a)

    def head: case (self) of
        Empty: Nothing
        Prepend x xs: Just x

    def prepend a: Prepend a self

    def isEmpty: case self of
        Empty: True
        Prepend x xs: False

    def map f: case (self) of
        Empty: Empty
        Prepend x xs: Prepend (f x) (xs.map f)

    def sequence: case (self) of
        Empty: None
        Prepend x xs: seq x xs.sequence

    def each f: case (self) of
        Empty: Empty
        Prepend x xs:
            fst  = f x
            rest = xs . each f
            Prepend fst rest

    def take i: case (self) of
        Empty: Empty
        Prepend x xs: switch (0.equals i) Empty (Prepend x (xs.take i.pred))

    def drop i: case (self) of
        Empty: Empty
        Prepend x xs: if 0.equals i then self else xs . drop i.pred

    def at n: case (self) of
        Empty:        errorStr "List.at: index out of range"
        Prepend x xs: if 0.equals n then x else xs . at n.pred

    def fold a f: case (self) of
        Empty: a
        Prepend x xs: f x (xs.fold a f)

    def plus that: case (self) of
        Empty: that
        Prepend x xs: Prepend x (xs.plus that)

    def length: case (self) of
        Empty: 0
        Prepend x xs: xs.length.succ

    def shortRep: "List<" + self.length.shortRep + ">"

    def toText: self.shortRep

    def prependAll it: case (self) of
        Empty: Empty
        Prepend x xs: xs . prependAll it . prepend x . prepend it

    def intersperse sep: case (self) of
        Empty: Empty
        Prepend x xs: xs . prependAll sep . prepend x

    def toJSON: JSONArray (self . map (x: x.toJSON))

    def filter f: case (self) of
         Empty: Empty
         Prepend x xs: switch (f x) (Prepend x (xs.filter f)) (xs.filter f)

    def _merge that: case Tuple2 self that of
        Tuple2 (Prepend x xs) (Prepend y ys): if y < x then self . _merge ys . prepend y else xs . _merge that . prepend x
        Tuple2 x Empty: x
        Tuple2 Empty y: y

    def sort:
        halfLen = self.length.div 2
        case 0.equals halfLen of
            True: self
            False:
                fstHalf = self . take halfLen . sort
                sndHalf = self . drop halfLen . sort
                fstHalf._merge sndHalf

    def _prefixes i: Prepend (self.take i) (self._prefixes i.succ)

    def prefixes: self._prefixes 1

    def zipWith f that: case Tuple2 self that of
        Tuple2 (Prepend x xs) (Prepend y ys): Prepend (f x y) (xs.zipWith f ys)
        Tuple2 x y: Empty

    def zip l: self . zipWith Tuple2 l

    def _all f: case self of
        Empty: True
        Prepend x xs: if f x then xs . _all f else False

    def _any f: case self of
        Empty: False
        Prepend x xs: if f x then True else xs . _any f

    def equals that: case Tuple2 self that of
        Tuple2 Empty Empty: True
        Tuple2 (Prepend x xs) (Prepend y ys): if x.equals y then xs.equals ys else False
        other: False

    def sum:
        self.fold 0.0 (x: y: x.toReal . + y.toReal)

    def average:
        self.sum . / (self.length.toReal)

    def collect: case self of
        Empty: Empty
        Prepend (Just x) xs: Prepend x xs.collect
        Prepend Nothing xs:  xs.collect

class Map k v:
    Tip
    Bin Int k v (Map k v) (Map k v)

    def isEmpty: case self of
        Tip: True
        Bin s k v l r: False

    def size: case self of
        Tip: 0
        Bin s k v l r: s

    def toList: case self of
        Tip: Empty
        Bin s k v l r:
            l . toList . plus (Empty . prepend (Tuple2 k v)) . plus r.toList

    def map f: case self of
        Tip: Tip
        Bin s k v l r: Bin s k (f v) (l . map f) (r . map f)

    def toJSON: JSONObject (self . map (x : x.toJSON))

    def lookup k: case self of
        Tip: Nothing
        Bin s kx x l r:
            if kx.equals k then Just x else (if kx < k then r.lookup k else l.lookup k)

    def insert k v: case self of
        Tip: Bin 1 k v Tip Tip
        Bin s kx x l r:
            case kx.equals k of
                True: Bin s kx v l r
                False: case kx < k of
                    True:
                        newR = r.insert k v
                        Bin (l.size + newR.size) kx x l newR
                    False:
                        newL = l.insert k v
                        Bin (newL.size + r.size) kx x newL r

    def equals that: case Tuple2 self that of
        Tuple2 Tip Tip: True
        Tuple2 (Bin s1 k1 v1 l1 r1) (Bin s2 k2 v2 l2 r2):
            if s1.equals s2 . and (k1.equals k2) . and (v1.equals v2) then l1.equals l2 . and (r1.equals r2) else False
        other: False

class JSON:
    JSONNumber Real
    JSONString Text
    JSONBool   Bool
    JSONArray  (List JSON)
    JSONObject (Map Text JSON)
    JSONNull

    def toJSON: self

    def render: case self of
        JSONNumber d: d.shortRep
        JSONString s: s.escapeJSON
        JSONArray  l: "[" + (l . map (x : x.render) . intersperse "," . fold "" (+)) + "]"
        JSONBool   b: case b of
            True:  "true"
            False: "false"
        JSONNull: "null"
        JSONObject m: "{" + (m . toList . map ((Tuple2 k v): k.escapeJSON + ": " + v.render) . intersperse "," . fold "" (+)) + "}"

    def shortRep: self.render

    def lookup key: case self of
        JSONObject m: m.lookup key
        other: Nothing

    def toReal: case self of
        JSONNumber a: a
        other:        errorStr "Unable to convert to a number"

    def toText: case self of
        JSONString s: s
        other:        errorStr "Unable to convert to text"

    def toList: case self of
        JSONArray a: a
        other:       errorStr "Unable to convert to a list"

    def lookupReal key: case self . lookup key of
        Just val: val . toReal
        Nothing:  errorStr "Key not found"

    def lookupText key: case self . lookup key of
        Just val: val . toText
        Nothing:  errorStr "Key not found"

    def at n: case self of
        JSONArray a: a.at n
        other:       errorStr "Object not indexable"

    def map f: case self of
        JSONArray a:  a.map f
        JSONObject o: o.map f
        other:        errorStr "Cannot map over a non-iterable object"

    def filter f: case self of
        JSONArray a:  a.filter f
        JSONObject o: errorStr "Cannot use filter on JSONObject"
        other:        errorStr "Cannot filter a non-iterable object"

    def each f: case self of
        JSONArray a: a.each f
        other:       errorStr "Cannot call each on a non-iterable object"

    def sum: case self of
        JSONArray a: a.sum
        other:       errorStr "Cannot compute sum of a non-iterable object"

    def average: case self of
        JSONArray a: a.average
        other:       errorStr "Cannot compute average of a non-iterable object"

class MsgPack:
    MPNull
    MPBool   Bool
    MPInt    Int
    MPReal   Real
    MPString Text
    MPBinary Binary
    MPArray  (List MsgPack)
    MPMap    (List (Tuple2 MsgPack MsgPack))

    def toText: case self of
        MPNull:     "MPNull"
        MPBool b:   "MPBool " + b.shortRep
        MPInt i:    "MPInt " + i.shortRep
        MPReal r:   "MPReal" + r.shortRep
        MPString s: "MPString " + s
        MPBinary b: "MPBinary " + b.shortRep
        MPArray a:  "MPArray " + a.shortRep
        MPMap m:    "MPMap " + m.shortRep

    def toJSON: case self of
        MPNil:      JSONNull
        MPBool b:   JSONBool b
        MPInt i:    JSONNumber i.toReal
        MPReal r:   JSONNumber r
        MPString s: JSONString s
        MPBinary b: JSONString b.toText
        MPArray a:  a.toJSON
        MPMap   m:  m.toJSON

    def equals that: case self of
        MPNil: case that of
            MPNil:       True
            other:       False
        MPBool b: case that of
            MPBool b1:   b.equals b1
            other:       False
        MPInt i: case that of
            MPInt i1:    i.equals i1
            other:       False
        MPReal r: case that of
            MPReal r1:   r.equals r1
            other:       False
        MPString s: case that of
            MPString s1: s.equals s1
            other:       False
        MPBinary b:      False
        MPArray a: case that of
            MPArray a1:  a.equals a1
            other:       False
        MPMap m: case that of
            MPMap m1:    m.equals m1
            other:       False

    def shortRep: self.toText

    def toReal: case self of
        MPInt i:  i.toReal
        MPReal r: r
        other:    errorStr "Unable to convert to a number"

    def toList: case self of
        MPArray a: a
        other:     errorStr "Unable to convert to a list"

    def _lookup_list_key key pairList: case pairList of
        Empty: Nothing
        Prepend x xs: case x of
            Tuple2 a b: if a.equals key then Just b else self._lookup_list_key key xs

    def lookup key: case self of
        MPMap m: self._lookup_list_key key m
        other:   Nothing

    def hasKey key: case self.lookup key of
        Just v:  True
        Nothing: False

    def hasText key: self.hasKey (MPString key)

    def safeLookupText key: self.lookup (MPString key)

    def lookupText key: case self.safeLookupText key of
        Just val: val
        Nothing:  errorStr "Key not found"

    def at n: case self of
        MPArray a: a.at n
        other:     errorStr "Object not indexable"

    def sum: case self of
        MPArray a: a.sum
        other:     errorStr "Cannot compute sum of a non-iterable object"

    def average: case self of
        MPArray a: a.average
        other:     errorStr "Cannot compute average of a non-iterable object"

    def map f: case self of
        MPArray a: a.map f
        other:     errorStr "Cannot map over a non-iterable object"

    def filter f: case self of
        MPArray a: a.filter f
        other:     errorStr "Cannot filter a non-iterable object"

    def each f: case self of
        MPArray a: a.each f
        other:     errorStr "Cannot call each on a non-iterable object"

def newMVar:
    primNewMVar

def fork:
    primFork

class MVar:
    BogusConstructorForParser

    def take:  primTakeMVar self
    def read:  primReadMVar self
    def put v: primPutMVar  self v

class Stream a:
    Stream a (Stream a)

    def isStream: True

    def each f: case self of
        Stream elt s:
            f elt
            s.each f

    def foldFrom a f: case self of
        Stream elt s:
            new = f elt a
            Stream new (s.foldFrom new f)

    def fold f: case self of
        Stream elt s: s.foldFrom elt f

    def map f: case self of
        Stream elt s: Stream (f elt) (s.map f)

    def average:
        folder = el: (Tuple2 count sum): Tuple2 count.succ (sum + el)
        self . foldFrom (Tuple2 0 0.0) folder . map ((Tuple2 count sum): sum./ count.toReal)

def delayAsync time act:
    var = newMVar
    fork (seq (sleep time) (var.put act))
    var

def every time act:
    current = act
    future  = delayAsync time (every time act)
    Stream current future.read
