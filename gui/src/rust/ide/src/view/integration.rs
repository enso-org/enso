//! View of the node editor.
// TODO[ao] this module should be completely reworked when doing the
//  https://github.com/enso-org/ide/issues/597
//  There should be a wrapper for each view which "fences" the input : emitting events in this
//  wrapper should not notify the outputs.

use crate::prelude::*;

use crate::controller::graph::NodeTrees;
use crate::controller::searcher::suggestion::MatchInfo;
use crate::controller::searcher::Suggestions;
use crate::model::execution_context::ComputedValueInfo;
use crate::model::execution_context::LocalCall;
use crate::model::execution_context::ExpressionId;
use crate::model::execution_context::Visualization;
use crate::model::execution_context::VisualizationId;
use crate::model::execution_context::VisualizationUpdateData;
use crate::model::suggestion_database::EntryKind;

use bimap::BiMap;
use enso_data::text::TextChange;
use enso_frp as frp;
use ensogl::display::traits::*;
use ensogl_gui_components::list_view;
use ide_view::graph_editor;
use ide_view::graph_editor::component::node;
use ide_view::graph_editor::component::visualization;
use ide_view::graph_editor::EdgeEndpoint;
use ide_view::graph_editor::GraphEditor;
use ide_view::graph_editor::SharedHashMap;
use utils::channel::process_stream_with_handle;



// ==============
// === Errors ===
// ==============

/// Error returned by various function inside GraphIntegration, when our mappings from controller
/// items (node or connections) to displayed items are missing some information.
#[derive(Copy,Clone,Debug,Fail)]
enum MissingMappingFor {
    #[fail(display="Displayed node {:?} is not bound to any controller node.",_0)]
    DisplayedNode(graph_editor::NodeId),
    #[fail(display="Controller node {:?} is not bound to any displayed node",_0)]
    ControllerNode(ast::Id),
    #[fail(display="Displayed connection {:?} is not bound to any controller connection", _0)]
    DisplayedConnection(graph_editor::EdgeId),
}

/// Error raised when reached some fatal inconsistency in data provided by GraphEditor.
#[derive(Copy,Clone,Debug,Fail)]
#[fail(display="Discrepancy in a GraphEditor component")]
struct GraphEditorInconsistency;

#[derive(Copy,Clone,Debug,Fail)]
#[fail(display="No visualization associated with view node {} found.", _0)]
struct NoSuchVisualization(graph_editor::NodeId);

#[derive(Copy,Clone,Debug,Fail)]
#[fail(display="Graph node {} already has visualization attached.", _0)]
struct VisualizationAlreadyAttached(graph_editor::NodeId);

#[derive(Copy,Clone,Debug,Fail)]
#[fail(display="The Graph Integration hsd no SearcherController.")]
struct MissingSearcherController;


// ====================
// === FencedAction ===
// ====================

/// An utility to FRP network. It is wrapped closure in a set of FRP nodes. The closure is called
/// on `trigger`, and `is_running` contains information if we are still inside closure call. It
/// allows us to block some execution path to avoid infinite loops.
///
/// ### Example
///
/// Here we want to do some updates when node was added to graph, but not during set up.
/// ```rust,compile_fail
/// frp::new_network! { network
///     let set_up = FencedAction::fence(&network, |()| {
///         frp.add_node.emit(());
///         // other things.
///     });
///     def _update = frp.node_added.map2(&set_up.is_running, |id,is_set_up| {
///         if !is_set_up {
///             update_something(id)
///         }
///     });
/// }
/// // This will run the set up closure, but without calling update_something.
/// set_up.trigger.emit(());
/// ```
#[derive(CloneRef)]
struct FencedAction<Parameter:frp::Data> {
    trigger    : frp::Source<Parameter>,
    is_running : frp::Stream<bool>,
}

impl<Parameter:frp::Data> FencedAction<Parameter> {
    /// Wrap the `action` in `FencedAction`.
    fn fence(network:&frp::Network, action:impl Fn(&Parameter) + 'static) -> Self {
        frp::extend! { network
            trigger    <- source::<Parameter>();
            triggered  <- trigger.constant(());
            switch     <- any(...);
            switch     <+ triggered;
            performed  <- trigger.map(move |param| action(param));
            switch     <+ performed;
            is_running <- switch.toggle();
        }
        Self {trigger,is_running}
    }
}



// ==============================
// === GraphEditorIntegration ===
// ==============================

/// The identifier base that will be used to name the methods introduced by "collapse nodes"
/// refactoring. Names are typically generated by taking base and appending subsequent integers,
/// until the generated name does not collide with any known identifier.
const COLLAPSED_FUNCTION_NAME:&str = "func";

/// The gap between nodes in pixels on default node layout (when user did not set any position of
/// node - possibly when node was added by editing text).
const DEFAULT_GAP_BETWEEN_NODES : f32 = ide_view::project::NEW_NODE_Y_GAP;
/// The default X position of the node when user did not set any position of node - possibly when
/// node was added by editing text.
const DEFAULT_NODE_X_POSITION   : f32 = -100.0;
/// The default Y position of the node when user did not set any position of node - possibly when
/// node was added by editing text.
const DEFAULT_NODE_Y_POSITION   : f32 =  200.0;

/// A structure which handles integration between controller and graph_editor EnsoGl control.
/// All changes made by user in view are reflected in controller, and all controller notifications
/// update view accordingly.
//TODO[ao] soon we should rearrange modules and crates to avoid such long names.
#[allow(missing_docs)]
#[derive(Clone,CloneRef,Debug)]
pub struct Integration {
    model   : Rc<Model>,
    network : frp::Network,
}

impl Integration {
    /// Get GraphEditor.
    pub fn graph_editor(&self) -> GraphEditor {
        self.model.view.graph().clone_ref()
    }

    /// Get the controller associated with this graph editor.
    pub fn graph_controller(&self) -> &controller::ExecutedGraph {
        &self.model.graph
    }
}

#[derive(Debug)]
struct Model {
    logger                  : Logger,
    view                    : ide_view::project::View,
    graph                   : controller::ExecutedGraph,
    text                    : controller::Text,
    searcher                : RefCell<Option<controller::Searcher>>,
    project                 : model::Project,
    visualization           : controller::Visualization,
    node_views              : RefCell<BiMap<ast::Id,graph_editor::NodeId>>,
    node_view_by_expression : RefCell<HashMap<ast::Id,graph_editor::NodeId>>,
    expression_views        : RefCell<HashMap<graph_editor::NodeId,graph_editor::component::node::Expression>>,
    connection_views        : RefCell<BiMap<controller::graph::Connection,graph_editor::EdgeId>>,
    code_view               : CloneRefCell<ensogl_text::Text>,
    visualizations          : SharedHashMap<graph_editor::NodeId,VisualizationId>,
}


// === Construction And Setup ===

impl Integration {
    /// Constructor. It creates GraphEditor and integrates it with given controller handle.
    pub fn new
    ( view          : ide_view::project::View
    , graph         : controller::ExecutedGraph
    , text          : controller::Text
    , visualization : controller::Visualization
    , project       : model::Project
    ) -> Self {
        let logger       = Logger::new("ViewIntegration");
        let model        = Model::new(logger,view,graph,text,visualization,project);
        let model        = Rc::new(model);
        let editor_outs  = &model.view.graph().frp.output;
        let code_editor  = &model.view.code_editor().text_area();
        let searcher_frp = &model.view.searcher().frp;
        let project_frp  = &model.view.frp;
        frp::new_network! {network
            let invalidate = FencedAction::fence(&network,f!([model](()) {
                let result = model.refresh_graph_view();
                if let Err(err) = result {
                    error!(model.logger,"Error while invalidating graph: {err}");
                }
            }));
        }


        // === Breadcrumb Selection ===

        let breadcrumbs = &model.view.graph().model.breadcrumbs;
        frp::extend! {network
            eval_ breadcrumbs.output.breadcrumb_pop(model.node_exited_in_ui(&()).ok());
            eval  breadcrumbs.output.breadcrumb_push((local_call) {
                model.expression_entered_in_ui(&local_call.as_ref().map(|local_call| {
                    let definition = (**local_call.definition).clone();
                    let call       = local_call.call;
                    LocalCall{definition,call}
                })).ok()
            });
        }


        // === Project Renaming ===

        let breadcrumbs = &model.view.graph().model.breadcrumbs;
        frp::extend! {network
            eval breadcrumbs.output.project_name((name) {
                model.rename_project(name);
            });
        }


        // === UI Actions ===

        let inv                    = &invalidate.trigger;
        let node_editing_in_ui     = Model::node_editing_in_ui(Rc::downgrade(&model));
        let code_changed           = Self::ui_action(&model,Model::code_changed_in_ui          ,inv);
        let node_removed           = Self::ui_action(&model,Model::node_removed_in_ui          ,inv);
        let nodes_collapsed        = Self::ui_action(&model,Model::nodes_collapsed_in_ui       ,inv);
        let node_entered           = Self::ui_action(&model,Model::node_entered_in_ui          ,inv);
        let node_exited            = Self::ui_action(&model,Model::node_exited_in_ui           ,inv);
        let connection_created     = Self::ui_action(&model,Model::connection_created_in_ui    ,inv);
        let connection_removed     = Self::ui_action(&model,Model::connection_removed_in_ui    ,inv);
        let node_moved             = Self::ui_action(&model,Model::node_moved_in_ui            ,inv);
        let node_editing           = Self::ui_action(&model,node_editing_in_ui                 ,inv);
        let node_expression_set    = Self::ui_action(&model,Model::node_expression_set_in_ui   ,inv);
        let suggestion_picked      = Self::ui_action(&model,Model::suggestion_picked_in_ui     ,inv);
        let node_editing_committed = Self::ui_action(&model,Model::node_editing_committed_in_ui,inv);
        let visualization_enabled  = Self::ui_action(&model,Model::visualization_enabled_in_ui ,inv);
        let visualization_disabled = Self::ui_action(&model,Model::visualization_disabled_in_ui,inv);
        frp::extend! {network
            eval code_editor.content ((content) model.code_view.set(content.clone_ref()));

            // Notifications from graph controller
            let handle_graph_notification = FencedAction::fence(&network,
                f!((notification:&Option<controller::graph::executed::Notification>)
                    model.handle_graph_notification(notification);
            ));

            // Notifications from graph controller
            let handle_text_notification = FencedAction::fence(&network,
                f!((notification:&Option<controller::text::Notification>)
                    model.handle_text_notification(*notification);
            ));

            // Changes in Graph Editor
            is_handling_notification <- handle_graph_notification.is_running
                                     || handle_text_notification.is_running;
            is_hold                  <- is_handling_notification || invalidate.is_running;
            on_connection_removed    <- editor_outs.on_edge_endpoint_unset._0();
            _action <- code_editor.changed                  .map2(&is_hold,code_changed);
            _action <- editor_outs.node_removed             .map2(&is_hold,node_removed);
            _action <- editor_outs.nodes_collapsed          .map2(&is_hold,nodes_collapsed);
            _action <- editor_outs.node_entered             .map2(&is_hold,node_entered);
            _action <- editor_outs.node_exited              .map2(&is_hold,node_exited);
            _action <- editor_outs.on_edge_endpoints_set    .map2(&is_hold,connection_created);
            _action <- editor_outs.visualization_enabled    .map2(&is_hold,visualization_enabled);
            _action <- editor_outs.visualization_disabled   .map2(&is_hold,visualization_disabled);
            _action <- on_connection_removed                .map2(&is_hold,connection_removed);
            _action <- editor_outs.node_position_set_batched.map2(&is_hold,node_moved);
            _action <- editor_outs.node_being_edited        .map2(&is_hold,node_editing);
            _action <- editor_outs.node_expression_set      .map2(&is_hold,node_expression_set);
            _action <- searcher_frp.picked_entry            .map2(&is_hold,suggestion_picked);
            _action <- project_frp.editing_committed        .map2(&is_hold,node_editing_committed);

            eval_ project_frp.editing_committed (invalidate.trigger.emit(()));
            eval_ project_frp.editing_aborted   (invalidate.trigger.emit(()));
            eval_ project_frp.save_module       (model.module_saved_in_ui());
        }
        Self::connect_frp_to_graph_controller_notifications(&model,handle_graph_notification.trigger);
        Self::connect_frp_text_controller_notifications(&model,handle_text_notification.trigger);
        Self {model,network}
    }

    fn connect_frp_to_graph_controller_notifications
    ( model        : &Rc<Model>
    , frp_endpoint : frp::Source<Option<controller::graph::executed::Notification>>
    ) {
        let stream  = model.graph.subscribe();
        let weak    = Rc::downgrade(model);
        let logger  = model.logger.clone_ref();
        let handler = process_stream_with_handle(stream,weak,move |notification,_model| {
            info!(logger,"Processing notification {notification:?}");
            frp_endpoint.emit(&Some(notification));
            futures::future::ready(())
        });
        executor::global::spawn(handler);
    }

    fn connect_frp_text_controller_notifications
    ( model        : &Rc<Model>
    , frp_endpoint : frp::Source<Option<controller::text::Notification>>
    ) {
        let stream  = model.text.subscribe();
        let weak    = Rc::downgrade(model);
        let logger  = model.logger.clone_ref();
        let handler = process_stream_with_handle(stream,weak,move |notification,_model| {
            info!(logger,"Processing notification {notification:?}");
            frp_endpoint.emit(&Some(notification));
            futures::future::ready(())
        });
        executor::global::spawn(handler);
    }

    /// Convert a function being a method of GraphEditorIntegratedWithControllerModel to a closure
    /// suitable for connecting to GraphEditor frp network. Returned lambda takes `Parameter` and a
    /// bool, which indicates if this action is currently on hold (e.g. due to performing
    /// invalidation).
    fn ui_action<Action,Parameter>
    ( model      : &Rc<Model>
    , action     : Action
    , invalidate : &frp::Source<()>
    ) -> impl Fn(&Parameter,&bool)
    where Action : Fn(&Model,&Parameter)
            -> FallibleResult + 'static {
        f!([model,invalidate] (parameter,is_hold) {
            if !*is_hold {
                let result = action(&*model,parameter);
                if let Err(err) = result {
                    error!(model.logger,"Error while performing UI action on controllers: {err}");
                    info!(model.logger,"Invalidating displayed graph");
                    invalidate.emit(());
                }
            }
        })
    }
}

impl Model {
    fn new
    ( logger        : Logger
    , view          : ide_view::project::View
    , graph         : controller::ExecutedGraph
    , text          : controller::Text
    , visualization : controller::Visualization
    , project       : model::Project) -> Self {
        let node_views              = default();
        let node_view_by_expression = default();
        let connection_views        = default();
        let expression_views        = default();
        let code_view               = default();
        let visualizations          = default();
        let searcher                = default();
        let this                    = Model
            {view,graph,text,searcher,node_views,expression_views,connection_views,code_view,logger
            ,visualization,visualizations,project,node_view_by_expression};

        this.init_project_name();
        this.init_visualizations();
        if let Err(err) = this.refresh_graph_view() {
            error!(this.logger,"Error while initializing graph editor: {err}.");
        }
        if let Err(err) = this.refresh_code_editor() {
            error!(this.logger,"Error while initializing code editor: {err}.");
        }
        this
    }

    fn init_visualizations(&self) {
        let logger       = self.logger.clone_ref();
        let controller   = self.visualization.clone_ref();
        let graph_editor = self.view.graph().clone_ref();
        executor::global::spawn(async move {
            let identifiers  = controller.list_visualizations().await;
            let identifiers  = identifiers.unwrap_or_default();
            for identifier in identifiers {
                match controller.load_visualization(&identifier).await {
                    Ok(visualization) => {
                        graph_editor.frp.register_visualization.emit(Some(visualization));
                    }
                    Err(err) => {
                        error!(logger, "Error while loading visualization {identifier}: {err:?}");
                    }
                }
            }
            info!(logger, "Visualizations Initialized.");
        });
    }
}


// === Project renaming ===

impl Model {
    fn init_project_name(&self) {
        let project_name = self.project.name().to_string();
        self.view.graph().model.breadcrumbs.input.project_name.emit(project_name);
    }

    fn rename_project(&self, name:impl Str) {
        if self.project.name() != name.as_ref() {
            let project     = self.project.clone_ref();
            let breadcrumbs = self.view.graph().model.breadcrumbs.clone_ref();
            let logger      = self.logger.clone_ref();
            let name        = name.into();
            executor::global::spawn(async move {
                if let Err(e) = project.rename_project(name).await {
                    info!(logger, "The project couldn't be renamed: {e}");
                    breadcrumbs.cancel_project_name_editing.emit(());
                }
            });
        }
    }
}


// === Updating Graph View ===

impl Model {
    /// Refresh displayed code to be up to date with module state.
    pub fn refresh_code_editor(&self) -> FallibleResult {
        let current_code = self.code_view.get().to_string();
        let new_code     = self.graph.graph().module.ast().repr();
        if new_code != current_code {
            self.code_view.set(new_code.as_str().into());
            self.view.code_editor().text_area().set_content(new_code);
        }
        Ok(())
    }

    /// Reload whole displayed content to be up to date with module state.
    pub fn refresh_graph_view(&self) -> FallibleResult {
        info!(self.logger, "Refreshing the graph view.");
        use controller::graph::Connections;
        let Connections{trees,connections} = self.graph.connections()?;
        self.refresh_node_views(trees)?;
        self.refresh_connection_views(connections)?;
        Ok(())
    }

    fn refresh_node_views
    (&self, mut trees:HashMap<double_representation::node::Id,NodeTrees>) -> FallibleResult {
        let nodes = self.graph.graph().nodes()?;
        let ids   = nodes.iter().map(|node| node.info.id() ).collect();
        self.retain_node_views(&ids);
        for (i,node_info) in nodes.iter().enumerate() {
            let id          = node_info.info.id();
            let node_trees  = trees.remove(&id).unwrap_or_else(default);
            let x           = DEFAULT_NODE_X_POSITION;
            let y           = DEFAULT_NODE_Y_POSITION + i as f32 * -DEFAULT_GAP_BETWEEN_NODES;
            let default_pos = Vector2(x,y);
            let displayed   = self.node_views.borrow_mut().get_by_left(&id).cloned();
            match displayed {
                Some(displayed) => self.refresh_node_view(displayed, node_info, node_trees),
                None            => self.create_node_view(node_info,node_trees,default_pos),
            }
        }
        Ok(())
    }

    /// Retain only given nodes in displayed graph.
    fn retain_node_views(&self, ids:&HashSet<ast::Id>) {
        let to_remove = {
            let borrowed = self.node_views.borrow();
            let filtered = borrowed.iter().filter(|(id,_)| !ids.contains(id));
            filtered.map(|(k,v)| (*k,*v)).collect_vec()
        };
        for (id,displayed_id) in to_remove {
            self.view.graph().frp.input.remove_node.emit(&displayed_id);
            self.node_views.borrow_mut().remove_by_left(&id);
        }
    }

    fn create_node_view
    (&self, info:&controller::graph::Node, trees:NodeTrees, default_pos:Vector2) {
        let id           = info.info.id();
        let displayed_id = self.view.graph().add_node();
        self.refresh_node_view(displayed_id, info, trees);
        // If position wasn't present in metadata, we must initialize it.
        if info.metadata.as_ref().and_then(|md| md.position).is_none() {
            self.view.graph().frp.input.set_node_position.emit(&(displayed_id, default_pos));
        }
        self.node_views.borrow_mut().insert(id, displayed_id);
    }

    /// Return an asynchronous event processor that routes visualization update to the given's
    /// visualization respective FRP endpoint.
    fn visualization_update_handler
    ( &self
    , endpoint : frp::Any<(graph_editor::NodeId,visualization::Data)>
    , node_id  : graph_editor::NodeId
    ) -> impl FnMut(VisualizationUpdateData) -> futures::future::Ready<()> {
        // TODO [mwu]
        //  For now only JSON visualizations are supported, so we can just assume JSON data in the
        //  binary package.
        let logger = self.logger.clone_ref();
        move |update| {
            match Self::deserialize_visualization_data(update) {
                Ok (data)  => endpoint.emit((node_id,data)),
                Err(error) =>
                    // TODO [mwu]
                    //  We should consider having the visualization also accept error input.
                    error!(logger, "Failed to deserialize visualization update. {error}"),
            }
            futures::future::ready(())
        }
    }

    fn deserialize_visualization_data
    (data:VisualizationUpdateData) -> FallibleResult<visualization::Data> {
        let binary  = data.as_ref();
        let as_text = std::str::from_utf8(binary)?;
        let as_json : serde_json::Value = serde_json::from_str(as_text)?;
        Ok(visualization::Data::from(as_json))
    }

    fn refresh_node_view
    (&self, id:graph_editor::NodeId, node:&controller::graph::Node, trees:NodeTrees) {
        let position = node.metadata.as_ref().and_then(|md| md.position);
        if let Some(position) = position {
            self.view.graph().frp.input.set_node_position.emit(&(id, position.vector));
        }
        let expression     = node.info.expression().repr();
        let code_and_trees = graph_editor::component::node::Expression {
            code             : expression,
            input_span_tree  : trees.inputs,
            output_span_tree : trees.outputs.unwrap_or_else(default)
        };
        if !self.expression_views.borrow().get(&id).contains(&&code_and_trees) {
            for sub_expression in node.info.ast().iter_recursive() {
                if let Some(expr_id) = sub_expression.id {
                    self.node_view_by_expression.borrow_mut().insert(expr_id,id);
                }
            }
            self.view.graph().frp.input.set_node_expression.emit(&(id,code_and_trees.clone()));
            self.expression_views.borrow_mut().insert(id,code_and_trees);
        }

        // Set initially available type information on ports (identifiable expression's sub-parts).
        for expression_part in node.info.expression().iter_recursive() {
            if let Some(id) = expression_part.id {
                self.refresh_computed_info(id);
            }
        }
    }

    /// Like `refresh_computed_info` but for multiple expressions.
    fn refresh_computed_infos(&self, expressions_to_refresh:&[ExpressionId]) -> FallibleResult {
        debug!(self.logger, "Refreshing type information for IDs: {expressions_to_refresh:?}.");
        for id in expressions_to_refresh {
            self.refresh_computed_info(*id)
        }
        Ok(())
    }

    /// Look up the computed information for a given expression and pass the information to the
    /// graph editor view.
    ///
    /// The computed value information includes the expression type and the target method pointer.
    fn refresh_computed_info(&self, id:ExpressionId) {
        let info     = self.lookup_computed_info(&id);
        let info     = info.as_ref();
        let typename = info.and_then(|info| info.typename.clone().map(graph_editor::Type));
        if let Some(node_id) = self.node_view_by_expression.borrow().get(&id).cloned() {
            self.set_type(node_id,id,typename);
            let method_pointer = info.and_then(|info| {
                info.method_call.and_then(|entry_id| {
                    let opt_method = self.project.suggestion_db().lookup_method_ptr(entry_id).ok();
                    opt_method.map(|method| graph_editor::MethodPointer(Rc::new(method)))
                })
            });
            self.set_method_pointer(id,method_pointer);
        }
    }

    /// Set given type (or lack of such) on the given sub-expression.
    fn set_type(&self, node_id:graph_editor::NodeId, id:ExpressionId, typename:Option<graph_editor::Type>) {
        let event = (node_id,id,typename);
        self.view.graph().frp.input.set_expression_usage_type.emit(&event);
    }

    /// Set given method pointer (or lack of such) on the given sub-expression.
    fn set_method_pointer(&self, id:ExpressionId, method:Option<graph_editor::MethodPointer>) {
        let event = (id,method);
        self.view.graph().frp.input.set_method_pointer.emit(&event);
    }

    fn refresh_connection_views
    (&self, connections:Vec<controller::graph::Connection>) -> FallibleResult {
        self.retain_connection_views(&connections);
        for con in connections {
            if !self.connection_views.borrow().contains_left(&con) {
                let targets = self.edge_targets_from_controller_connection(con.clone())?;
                self.view.graph().frp.input.connect_nodes.emit(&targets);
                let edge_id = self.view.graph().frp.output.on_edge_add.value();
                self.connection_views.borrow_mut().insert(con, edge_id);
            }
        }
        Ok(())
    }

    fn edge_targets_from_controller_connection
    (&self, connection:controller::graph::Connection) -> FallibleResult<(EdgeEndpoint,EdgeEndpoint)> {
        let src_node = self.get_displayed_node_id(connection.source.node)?;
        let dst_node = self.get_displayed_node_id(connection.destination.node)?;
        let src      = EdgeEndpoint::new(src_node,connection.source.port);
        let data     = EdgeEndpoint::new(dst_node,connection.destination.port);
        Ok((src,data))
    }

    /// Retain only given connections in displayed graph.
    fn retain_connection_views(&self, connections:&[controller::graph::Connection]) {
        let to_remove = {
            let borrowed = self.connection_views.borrow();
            let filtered = borrowed.iter().filter(|(con,_)| !connections.contains(con));
            filtered.map(|(_,edge_id)| *edge_id).collect_vec()
        };
        for edge_id in to_remove {
            self.view.graph().frp.input.remove_edge.emit(&edge_id);
            self.connection_views.borrow_mut().remove_by_right(&edge_id);
        }
    }
}


// === Handling Controller Notifications ===

impl Model {
    /// Handle notification received from controller about the whole graph being invalidated.
    pub fn on_graph_invalidated(&self) -> FallibleResult {
        self.refresh_graph_view()
    }

    /// Handle notification received from controller about the whole graph being invalidated.
    pub fn on_text_invalidated(&self) -> FallibleResult {
        self.refresh_code_editor()
    }

    /// Handle notification received from controller about values having been entered.
    pub fn on_node_entered(&self, local_call:&LocalCall) -> FallibleResult {
        let definition = local_call.definition.clone().into();
        let call       = local_call.call;
        let local_call = graph_editor::LocalCall{definition,call};
        self.view.graph().frp.deselect_all_nodes.emit(&());
        self.view.graph().model.breadcrumbs.push_breadcrumb.emit(&Some(local_call));
        self.request_detaching_all_visualizations();
        self.refresh_graph_view()
    }

    /// Handle notification received from controller about node having been exited.
    pub fn on_node_exited(&self, id:double_representation::node::Id) -> FallibleResult {
        self.view.graph().frp.deselect_all_nodes.emit(&());
        self.request_detaching_all_visualizations();
        self.refresh_graph_view()?;
        self.view.graph().model.breadcrumbs.pop_breadcrumb.emit(());
        let id = self.get_displayed_node_id(id)?;
        self.view.graph().frp.select_node.emit(&id);
        Ok(())
    }

    /// Handle notification received from controller about values having been computed.
    pub fn on_values_computed(&self, expressions:&[ExpressionId]) -> FallibleResult {
        self.refresh_computed_infos(&expressions)
    }

    /// Request controller to detach all attached visualizations.
    pub fn request_detaching_all_visualizations(&self) {
        let controller = self.graph.clone_ref();
        let logger     = self.logger.clone_ref();
        let action     = async move {
            for result in controller.detach_all_visualizations().await {
                if let Err(err) = result {
                    error!(logger,"Failed to detach one of the visualizations: {err:?}.");
                }
            }
        };
        executor::global::spawn(action);
    }

    /// Handle notification received from Graph Controller.
    pub fn handle_graph_notification
    (&self, notification:&Option<controller::graph::executed::Notification>) {
        use controller::graph::executed::Notification;
        use controller::graph::Notification::Invalidate;

        debug!(self.logger, "Received notification {notification:?}");
        let result = match notification {
            Some(Notification::Graph(Invalidate))         => self.on_graph_invalidated(),
            Some(Notification::ComputedValueInfo(update)) => self.on_values_computed(update),
            Some(Notification::SteppedOutOfNode(id))      => self.on_node_exited(*id),
            Some(Notification::EnteredNode(local_call))   => self.on_node_entered(local_call),
            other => {
                warning!(self.logger,"Handling notification {other:?} is not implemented; \
                    performing full invalidation");
                self.refresh_graph_view()
            }
        };
        if let Err(err) = result {
            error!(self.logger,"Error while updating graph after receiving {notification:?} from \
                controller: {err}");
        }
    }

    /// Handle notification received from Text Controller.
    pub fn handle_text_notification(&self, notification:Option<controller::text::Notification>) {
        use controller::text::Notification;

        debug!(self.logger, "Received notification {notification:?}");
        let result = match notification {
            Some(Notification::Invalidate) => self.on_text_invalidated(),
            other => {
                warning!(self.logger,"Handling notification {other:?} is not implemented; \
                    performing full invalidation");
                self.refresh_code_editor()
            }
        };
        if let Err(err) = result {
            error!(self.logger,"Error while updating graph after receiving {notification:?} from \
                controller: {err}");
        }
    }

    pub fn handle_searcher_notification(&self, notification:controller::searcher::Notification) {
        use controller::searcher::Notification;
        use controller::searcher::UserAction;
        match notification {
            Notification::NewSuggestionList => with(self.searcher.borrow(), |searcher| {
                if let Some(searcher) = &*searcher {
                    match searcher.suggestions() {
                        Suggestions::Loading       => self.view.searcher().clear_suggestions(),
                        Suggestions::Loaded {list:suggestions} => {
                            let list_is_empty     = suggestions.matching_count() == 0;
                            let user_action       = searcher.current_user_action();
                            let intended_function = searcher.intended_function_suggestion();
                            let provider          = DataProviderForView
                                {suggestions,user_action,intended_function};
                            self.view.searcher().set_suggestions(Rc::new(provider));

                            // Usually we want to select first suggestion and display docs for it
                            // But not when user finished typing function or argument.
                            let starting_typing = user_action == UserAction::StartingTypingArgument;
                            if  !starting_typing && !list_is_empty {
                                self.view.searcher().select_suggestion(0);
                            }
                        },
                        Suggestions::Error(err)    => {
                            error!(self.logger, "Error while obtaining list from searcher: {err}");
                            self.view.searcher().clear_suggestions();
                        },
                    };
                }
            })
        }
    }
}


// === Passing UI Actions To Controllers ===

// These functions are called with FRP event values as arguments. The FRP values are always provided
// by reference, including "trivially-copy" types and Vecs, To keep code cleaner we take
// all parameters by reference.
#[allow(clippy::trivially_copy_pass_by_ref)]
#[allow(clippy::ptr_arg)]
impl Model {
    fn node_removed_in_ui(&self, node:&graph_editor::NodeId) -> FallibleResult {
        debug!(self.logger, "Removing node.");
        let id = self.get_controller_node_id(*node)?;
        self.node_views.borrow_mut().remove_by_left(&id);
        self.graph.graph().remove_node(id)?;
        Ok(())
    }

    fn node_moved_in_ui
    (&self, (displayed_id,pos):&(graph_editor::NodeId,Vector2)) -> FallibleResult {
        debug!(self.logger, "Moving node.");
        if let Ok(id) = self.get_controller_node_id(*displayed_id) {
            self.graph.graph().module.with_node_metadata(id, Box::new(|md| {
                md.position = Some(model::module::Position::new(pos.x,pos.y));
            }))?;
        }
        Ok(())
    }

    fn nodes_collapsed_in_ui
    (&self, (collapsed,_new_node_view_id):&(Vec<graph_editor::NodeId>,graph_editor::NodeId))
    -> FallibleResult {
        debug!(self.logger, "Collapsing node.");
        let ids          = self.get_controller_node_ids(collapsed)?;
        let _new_node_id = self.graph.graph().collapse(ids,COLLAPSED_FUNCTION_NAME)?;
        // TODO [mwu] https://github.com/enso-org/ide/issues/760
        //   As part of this issue, storing relation between new node's controller and view ids will
        //   be necessary.
        Ok(())
    }

    fn node_expression_set_in_ui
    (&self, (displayed_id,expression):&(graph_editor::NodeId,String)) -> FallibleResult {
        debug!(self.logger, "Setting node expression.");
        let searcher       = self.searcher.borrow();
        let code_and_trees = graph_editor::component::node::Expression::new_plain(expression);
        self.expression_views.borrow_mut().insert(*displayed_id,code_and_trees);
        if let Some(searcher) = searcher.as_ref() {
            searcher.set_input(expression.clone())?;
        }
        Ok(())
    }

    fn node_editing_in_ui(weak_self:Weak<Self>)
    -> impl Fn(&Self,&Option<graph_editor::NodeId>) -> FallibleResult {
        move |this,displayed_id| {
            if let Some(displayed_id) = displayed_id {
                debug!(this.logger, "Starting node editing.");
                let id   = this.get_controller_node_id(*displayed_id);
                let mode = match id {
                    Ok(node_id) => controller::searcher::Mode::EditNode {node_id},
                    Err(MissingMappingFor::DisplayedNode(id)) => {
                        let node_view = this.view.graph().model.nodes.get_cloned_ref(&id);
                        let position  = node_view.map(|node| node.position().xy());
                        let position  = position.map(|vector| model::module::Position{vector});
                        controller::searcher::Mode::NewNode {position}
                    },
                    Err(other) => return Err(other.into()),
                };
                let selected_nodes = this.view.graph().model.selected_nodes().iter().filter_map(|id| {
                    this.get_controller_node_id(*id).ok()
                }).collect_vec();
                let controller = this.graph.clone_ref();
                let searcher = controller::Searcher::new_from_graph_controller
                    (&this.logger,&this.project,controller,mode,selected_nodes)?;
                executor::global::spawn(searcher.subscribe().for_each(f!([weak_self](notification) {
                    if let Some(this) = weak_self.upgrade() {
                        this.handle_searcher_notification(notification);
                    }
                    futures::future::ready(())
                })));
                *this.searcher.borrow_mut() = Some(searcher);
            } else {
                debug!(this.logger, "Finishing node editing.");
            }
            Ok(())
        }
    }

    fn suggestion_picked_in_ui
    (&self, entry:&Option<ide_view::searcher::entry::Id>) -> FallibleResult {
        debug!(self.logger, "Picking suggestion.");
        if let Some(entry) = entry {
            let graph_frp      = &self.view.graph().frp;
            let error          = || MissingSearcherController;
            let searcher       = self.searcher.borrow().clone().ok_or_else(error)?;
            let error          = || GraphEditorInconsistency;
            let edited_node    = graph_frp.output.node_being_edited.value().ok_or_else(error)?;
            let code           = searcher.pick_completion_by_index(*entry)?;
            let code_and_trees = node::Expression::new_plain(code);
            graph_frp.input.set_node_expression.emit(&(edited_node,code_and_trees));
        }
        Ok(())
    }

    fn node_editing_committed_in_ui
    (&self, displayed_id:&graph_editor::NodeId) -> FallibleResult {
        debug!(self.logger, "Committing node expression.");
        let error = || MissingSearcherController;
        let searcher = self.searcher.borrow().clone().ok_or_else(error)?;
        *self.searcher.borrow_mut() = None;
        match searcher.commit_node() {
            Ok(node_id) => {
                self.node_views.borrow_mut().insert(node_id,*displayed_id);
                Ok(())
            }
            Err(err) => {
                self.view.graph().frp.remove_node.emit(displayed_id);
                Err(err)
            }
        }
    }

    fn connection_created_in_ui(&self, edge_id:&graph_editor::EdgeId) -> FallibleResult {
        debug!(self.logger, "Creating connection.");
        let displayed = self.view.graph().model.edges.get_cloned(&edge_id).ok_or(GraphEditorInconsistency)?;
        let con       = self.controller_connection_from_displayed(&displayed)?;
        let inserting = self.connection_views.borrow_mut().insert(con.clone(), *edge_id);
        if inserting.did_overwrite() {
            warning!(self.logger,"Created connection {edge_id} overwrite some old mappings in \
                GraphEditorIntegration.")
        }
        self.graph.connect(&con)?;
        Ok(())
    }

    fn connection_removed_in_ui(&self, edge_id:&graph_editor::EdgeId) -> FallibleResult {
        debug!(self.logger, "Removing connection.");
        let connection = self.get_controller_connection(*edge_id)?;
        self.connection_views.borrow_mut().remove_by_left(&connection);
        self.graph.disconnect(&connection)?;
        Ok(())
    }

    /// Create a controller-compatible description of the visualization based on the input received
    /// from the graph editor endpoints.
    fn prepare_visualization
    (&self, node_id:&graph_editor::NodeId) -> FallibleResult<Visualization> {
        use crate::model::module::QualifiedName;

        // TODO [mwu]
        //   Currently it is not possible to:
        //    * enter other module than the initial (namely, "Main")
        //    * describe that visualization's expression wishes to be evaluated in any other
        //      context.
        //   Because of that for now we will just hardcode the `visualization_module` using
        //   fixed defaults. In future this will be changed, then the editor will also get access
        //   to the customised values.
        let project_name:String  = self.project.name().into();
        let module_name          = crate::view::INITIAL_MODULE_NAME;
        let visualisation_module = QualifiedName::from_segments(project_name,&[module_name])?;
        let id                   = VisualizationId::new_v4();
        let expression           = crate::constants::SERIALIZE_TO_JSON_EXPRESSION.into();
        let ast_id               = self.get_controller_node_id(*node_id)?;
        Ok(Visualization{ast_id,expression,id,visualisation_module})
    }

    fn visualization_enabled_in_ui(&self, node_id:&graph_editor::NodeId) -> FallibleResult {
        // Do nothing if there is already a visualization attached.
        let err = || VisualizationAlreadyAttached(*node_id);
        self.get_controller_visualization_id(*node_id).is_err().ok_or_else(err)?;

        debug!(self.logger, "Attaching visualization on {node_id}.");
        let visualization  = self.prepare_visualization(node_id)?;
        let id             = visualization.id;
        let node_id        = *node_id;
        let controller     = self.graph.clone();
        let endpoint       = self.view.graph().frp.input.set_visualization_data.clone_ref();
        let update_handler = self.visualization_update_handler(endpoint,node_id);
        let logger         = self.logger.clone_ref();
        let visualizations = self.visualizations.clone_ref();

        // We cannot do this in the async block, as the user may decide to detach before server
        // confirms that we actually have attached.
        visualizations.insert(node_id.clone(),id);

        let attach_action  = async move {
            if let Ok(stream) = controller.attach_visualization(visualization).await {
                debug!(logger, "Successfully attached visualization {id} for node {node_id}.");
                let updates_handler = stream.for_each(update_handler);
                executor::global::spawn(updates_handler);
            } else {
                visualizations.remove(&node_id);
            }
        };
        executor::global::spawn(attach_action);
        Ok(())
    }

    fn visualization_disabled_in_ui(&self, node_id:&graph_editor::NodeId) -> FallibleResult {
        debug!(self.logger,"Node editor wants to detach visualization on {node_id}.");
        let id             = self.get_controller_visualization_id(*node_id)?;
        let graph          = self.graph.clone_ref();
        let logger         = self.logger.clone_ref();
        let visualizations = self.visualizations.clone_ref();
        let node_id        = *node_id;

        // We first detach to allow re-attaching even before server confirms the operation.
        visualizations.remove(&node_id);

        let detach_action = async move {
            if graph.detach_visualization(id).await.is_ok() {
                debug!(logger,"Successfully detached visualization {id} from node {node_id}.");
            } else {
                error!(logger,"Failed to detach visualization {id} from node {node_id}.");
                // TODO [mwu]
                //   We should somehow deal with this but we have really no information, how to.
                //   If this failed because e.g. the visualization was already removed (or another
                //   reason to that effect), we should just do nothing.
                //   But if it is issue like connectivity problem, then we should retry.
                //   But even if had better error recognition, we won't always know.
                //   So we should also handle errors like unexpected visualization updates and use
                //   them to drive cleanups on such discrepancies.
            }
        };

        crate::executor::global::spawn(detach_action);
        Ok(())
    }

    fn expression_entered_in_ui
    (&self, local_call:&Option<LocalCall>) -> FallibleResult {
        if let Some(local_call) = local_call {
            let local_call   = local_call.clone();
            let controller   = self.graph.clone_ref();
            let logger       = self.logger.clone_ref();
            let enter_action = async move {
                info!(logger,"Entering node.");
                if let Err(e) = controller.enter_method_pointer(&local_call).await {
                    error!(logger,"Entering node failed: {e}.");
                }
            };
            executor::global::spawn(enter_action);
        }
        Ok(())
    }

    fn node_entered_in_ui(&self, node_id:&graph_editor::NodeId) -> FallibleResult {
        debug!(self.logger,"Requesting entering the node {node_id}.");
        let call           = self.get_controller_node_id(*node_id)?;
        let method_pointer = self.graph.node_method_pointer(call)?;
        let definition     = (*method_pointer).clone();
        let local_call     = LocalCall{call,definition};
        self.expression_entered_in_ui(&Some(local_call))
    }

    fn node_exited_in_ui(&self, _:&()) -> FallibleResult {
        debug!(self.logger,"Requesting exiting the current node.");
        let controller = self.graph.clone_ref();
        let logger     = self.logger.clone_ref();
        let exit_node_action = async move {
            info!(logger,"Exiting node.");
            if let Err(e) = controller.exit_node().await {
                debug!(logger, "Exiting node failed: {e}.");
            }
        };
        executor::global::spawn(exit_node_action);
        Ok(())
    }

    fn code_changed_in_ui(&self, changes:&Vec<ensogl_text::Change>) -> FallibleResult {
        for change in changes {
            let range_start = data::text::Index::new(change.range.start.value as usize);
            let range_end   = data::text::Index::new(change.range.end.value   as usize);
            let converted = TextChange::replace(range_start..range_end,change.text.to_string());
            self.text.apply_text_change(converted)?;
        }
        Ok(())
    }

    fn module_saved_in_ui(&self) {
        let logger     = self.logger.clone_ref();
        let controller = self.text.clone_ref();
        let content    = self.code_view.get().to_string();
        executor::global::spawn(async move {
            if let Err(err) = controller.store_content(content).await {
                error!(logger, "Error while saving file: {err:?}");
            }
        });
    }
}


// === Utilities ===

impl Model {
    fn get_controller_node_id
    (&self, displayed_id:graph_editor::NodeId) -> Result<ast::Id, MissingMappingFor> {
        let err = MissingMappingFor::DisplayedNode(displayed_id);
        self.node_views.borrow().get_by_right(&displayed_id).cloned().ok_or(err)
    }

    fn get_controller_node_ids
    (&self, displayed_ids:impl IntoIterator<Item:std::borrow::Borrow<graph_editor::NodeId>>)
    -> Result<Vec<ast::Id>, MissingMappingFor> {
        use std::borrow::Borrow;
        Result::from_iter(displayed_ids.into_iter().map(|id| {
            let id = id.borrow();
            self.get_controller_node_id(*id)
        }))
    }

    fn get_displayed_node_id
    (&self, node_id:ast::Id) -> Result<graph_editor::NodeId, MissingMappingFor> {
        let err = MissingMappingFor::ControllerNode(node_id);
        self.node_views.borrow().get_by_left(&node_id).cloned().ok_or(err)
    }

    fn get_controller_connection
    (&self, displayed_id:graph_editor::EdgeId)
    -> Result<controller::graph::Connection, MissingMappingFor> {
        let err = MissingMappingFor::DisplayedConnection(displayed_id);
        self.connection_views.borrow().get_by_right(&displayed_id).cloned().ok_or(err)
    }

    fn controller_connection_from_displayed
    (&self, connection:&graph_editor::Edge) -> FallibleResult<controller::graph::Connection> {
        let src      = connection.source().ok_or(GraphEditorInconsistency {})?;
        let dst      = connection.target().ok_or(GraphEditorInconsistency {})?;
        let src_node = self.get_controller_node_id(src.node_id)?;
        let dst_node = self.get_controller_node_id(dst.node_id)?;
        Ok(controller::graph::Connection {
            source      : controller::graph::Endpoint::new(src_node,&src.port),
            destination : controller::graph::Endpoint::new(dst_node,&dst.port),
        })
    }

    fn get_controller_visualization_id
    (&self, node_id:graph_editor::NodeId) -> Result<VisualizationId,NoSuchVisualization> {
        let err = || NoSuchVisualization(node_id);
        self.visualizations.get_copied(&node_id).ok_or_else(err)
    }

    fn lookup_computed_info(&self, id:&ExpressionId) -> Option<Rc<ComputedValueInfo>> {
        let registry = self.graph.computed_value_info_registry();
        registry.get(id)
    }
}



// ===========================
// === DataProviderForView ===
// ===========================

#[derive(Clone,Debug)]
struct DataProviderForView {
    suggestions       : Rc<controller::searcher::suggestion::List>,
    user_action       : controller::searcher::UserAction,
    intended_function : Option<controller::searcher::suggestion::Completion>,
}

impl DataProviderForView {
    fn doc_placeholder_for(suggestion:&controller::searcher::suggestion::Completion) -> String {
        let title = match suggestion.kind {
            EntryKind::Atom     => "Atom",
            EntryKind::Function => "Function",
            EntryKind::Local    => "Local variable",
            EntryKind::Method   => "Method",
        };
        format!("{} `{}`\n\nNo documentation available", title,suggestion.code_to_insert(None))
    }
}

impl list_view::entry::ModelProvider for DataProviderForView {
    fn entry_count(&self) -> usize {
        self.suggestions.matching_count()
    }

    fn get(&self, id: usize) -> Option<list_view::entry::Model> {
        let suggestion = self.suggestions.get_cloned(id)?;
        if let MatchInfo::Matches {subsequence} = suggestion.match_info {
            let caption          = suggestion.suggestion.caption();
            let model            = list_view::entry::Model::new(caption.clone());
            let mut char_iter    = caption.char_indices().enumerate();
            let highlighted_iter = subsequence.indices.iter().filter_map(|idx| loop {
                if let Some(char) = char_iter.next() {
                    let (char_idx,(byte_id,char)) = char;
                    if char_idx == *idx {
                        let start = ensogl_text::Bytes(byte_id as i32);
                        let end   = ensogl_text::Bytes((byte_id + char.len_utf8()) as i32);
                        break Some(ensogl_text::Range::new(start,end))
                    }
                } else {
                    break None;
                }
            });
            let model = model.highlight(highlighted_iter);
            Some(model)
        } else {
            None
        }
    }
}

impl ide_view::searcher::DocumentationProvider for DataProviderForView {
    fn get(&self) -> Option<String> {
        use controller::searcher::UserAction::*;
        self.intended_function.as_ref().and_then(|function| match self.user_action {
            StartingTypingArgument => function.documentation.clone(),
            _                      => None
        })
    }

    fn get_for_entry(&self, id:usize) -> Option<String> {
        use controller::searcher::suggestion::Suggestion;
        match self.suggestions.get_cloned(id)?.suggestion {
            Suggestion::Completion(completion) => {
                let doc = completion.documentation.clone();
                Some(doc.unwrap_or_else(|| Self::doc_placeholder_for(&completion)))
            }
        }
    }
}


